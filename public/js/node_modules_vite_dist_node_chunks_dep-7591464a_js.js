/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["node_modules_vite_dist_node_chunks_dep-7591464a_js"],{

/***/ "./node_modules/picocolors/picocolors.browser.js":
/*!*******************************************************!*\
  !*** ./node_modules/picocolors/picocolors.browser.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("var x=String;\nvar create=function() {return {isColorSupported:false,reset:x,bold:x,dim:x,italic:x,underline:x,inverse:x,hidden:x,strikethrough:x,black:x,red:x,green:x,yellow:x,blue:x,magenta:x,cyan:x,white:x,gray:x,bgBlack:x,bgRed:x,bgGreen:x,bgYellow:x,bgBlue:x,bgMagenta:x,bgCyan:x,bgWhite:x}};\nmodule.exports=create();\nmodule.exports.createColors = create;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGljb2NvbG9ycy9waWNvY29sb3JzLmJyb3dzZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9waWNvY29sb3JzL3BpY29jb2xvcnMuYnJvd3Nlci5qcz9mYWE1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB4PVN0cmluZztcbnZhciBjcmVhdGU9ZnVuY3Rpb24oKSB7cmV0dXJuIHtpc0NvbG9yU3VwcG9ydGVkOmZhbHNlLHJlc2V0OngsYm9sZDp4LGRpbTp4LGl0YWxpYzp4LHVuZGVybGluZTp4LGludmVyc2U6eCxoaWRkZW46eCxzdHJpa2V0aHJvdWdoOngsYmxhY2s6eCxyZWQ6eCxncmVlbjp4LHllbGxvdzp4LGJsdWU6eCxtYWdlbnRhOngsY3lhbjp4LHdoaXRlOngsZ3JheTp4LGJnQmxhY2s6eCxiZ1JlZDp4LGJnR3JlZW46eCxiZ1llbGxvdzp4LGJnQmx1ZTp4LGJnTWFnZW50YTp4LGJnQ3lhbjp4LGJnV2hpdGU6eH19O1xubW9kdWxlLmV4cG9ydHM9Y3JlYXRlKCk7XG5tb2R1bGUuZXhwb3J0cy5jcmVhdGVDb2xvcnMgPSBjcmVhdGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/picocolors/picocolors.browser.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/at-rule.js":
/*!*********************************************!*\
  !*** ./node_modules/postcss/lib/at-rule.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Container = __webpack_require__(/*! ./container */ \"./node_modules/postcss/lib/container.js\")\n\nclass AtRule extends Container {\n  constructor(defaults) {\n    super(defaults)\n    this.type = 'atrule'\n  }\n\n  append(...children) {\n    if (!this.proxyOf.nodes) this.nodes = []\n    return super.append(...children)\n  }\n\n  prepend(...children) {\n    if (!this.proxyOf.nodes) this.nodes = []\n    return super.prepend(...children)\n  }\n}\n\nmodule.exports = AtRule\nAtRule.default = AtRule\n\nContainer.registerAtRule(AtRule)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvYXQtcnVsZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQyw0REFBYTs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvYXQtcnVsZS5qcz9jZWY1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5sZXQgQ29udGFpbmVyID0gcmVxdWlyZSgnLi9jb250YWluZXInKVxuXG5jbGFzcyBBdFJ1bGUgZXh0ZW5kcyBDb250YWluZXIge1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0cykge1xuICAgIHN1cGVyKGRlZmF1bHRzKVxuICAgIHRoaXMudHlwZSA9ICdhdHJ1bGUnXG4gIH1cblxuICBhcHBlbmQoLi4uY2hpbGRyZW4pIHtcbiAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgdGhpcy5ub2RlcyA9IFtdXG4gICAgcmV0dXJuIHN1cGVyLmFwcGVuZCguLi5jaGlsZHJlbilcbiAgfVxuXG4gIHByZXBlbmQoLi4uY2hpbGRyZW4pIHtcbiAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgdGhpcy5ub2RlcyA9IFtdXG4gICAgcmV0dXJuIHN1cGVyLnByZXBlbmQoLi4uY2hpbGRyZW4pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBdFJ1bGVcbkF0UnVsZS5kZWZhdWx0ID0gQXRSdWxlXG5cbkNvbnRhaW5lci5yZWdpc3RlckF0UnVsZShBdFJ1bGUpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/at-rule.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/comment.js":
/*!*********************************************!*\
  !*** ./node_modules/postcss/lib/comment.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Node = __webpack_require__(/*! ./node */ \"./node_modules/postcss/lib/node.js\")\n\nclass Comment extends Node {\n  constructor(defaults) {\n    super(defaults)\n    this.type = 'comment'\n  }\n}\n\nmodule.exports = Comment\nComment.default = Comment\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvY29tbWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixXQUFXLG1CQUFPLENBQUMsa0RBQVE7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL2NvbW1lbnQuanM/M2Y4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubGV0IE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKVxuXG5jbGFzcyBDb21tZW50IGV4dGVuZHMgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKGRlZmF1bHRzKSB7XG4gICAgc3VwZXIoZGVmYXVsdHMpXG4gICAgdGhpcy50eXBlID0gJ2NvbW1lbnQnXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21tZW50XG5Db21tZW50LmRlZmF1bHQgPSBDb21tZW50XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/comment.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/container.js":
/*!***********************************************!*\
  !*** ./node_modules/postcss/lib/container.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet { isClean, my } = __webpack_require__(/*! ./symbols */ \"./node_modules/postcss/lib/symbols.js\")\nlet Declaration = __webpack_require__(/*! ./declaration */ \"./node_modules/postcss/lib/declaration.js\")\nlet Comment = __webpack_require__(/*! ./comment */ \"./node_modules/postcss/lib/comment.js\")\nlet Node = __webpack_require__(/*! ./node */ \"./node_modules/postcss/lib/node.js\")\n\nlet parse, Rule, AtRule, Root\n\nfunction cleanSource(nodes) {\n  return nodes.map(i => {\n    if (i.nodes) i.nodes = cleanSource(i.nodes)\n    delete i.source\n    return i\n  })\n}\n\nfunction markDirtyUp(node) {\n  node[isClean] = false\n  if (node.proxyOf.nodes) {\n    for (let i of node.proxyOf.nodes) {\n      markDirtyUp(i)\n    }\n  }\n}\n\nclass Container extends Node {\n  push(child) {\n    child.parent = this\n    this.proxyOf.nodes.push(child)\n    return this\n  }\n\n  each(callback) {\n    if (!this.proxyOf.nodes) return undefined\n    let iterator = this.getIterator()\n\n    let index, result\n    while (this.indexes[iterator] < this.proxyOf.nodes.length) {\n      index = this.indexes[iterator]\n      result = callback(this.proxyOf.nodes[index], index)\n      if (result === false) break\n\n      this.indexes[iterator] += 1\n    }\n\n    delete this.indexes[iterator]\n    return result\n  }\n\n  walk(callback) {\n    return this.each((child, i) => {\n      let result\n      try {\n        result = callback(child, i)\n      } catch (e) {\n        throw child.addToError(e)\n      }\n      if (result !== false && child.walk) {\n        result = child.walk(callback)\n      }\n\n      return result\n    })\n  }\n\n  walkDecls(prop, callback) {\n    if (!callback) {\n      callback = prop\n      return this.walk((child, i) => {\n        if (child.type === 'decl') {\n          return callback(child, i)\n        }\n      })\n    }\n    if (prop instanceof RegExp) {\n      return this.walk((child, i) => {\n        if (child.type === 'decl' && prop.test(child.prop)) {\n          return callback(child, i)\n        }\n      })\n    }\n    return this.walk((child, i) => {\n      if (child.type === 'decl' && child.prop === prop) {\n        return callback(child, i)\n      }\n    })\n  }\n\n  walkRules(selector, callback) {\n    if (!callback) {\n      callback = selector\n\n      return this.walk((child, i) => {\n        if (child.type === 'rule') {\n          return callback(child, i)\n        }\n      })\n    }\n    if (selector instanceof RegExp) {\n      return this.walk((child, i) => {\n        if (child.type === 'rule' && selector.test(child.selector)) {\n          return callback(child, i)\n        }\n      })\n    }\n    return this.walk((child, i) => {\n      if (child.type === 'rule' && child.selector === selector) {\n        return callback(child, i)\n      }\n    })\n  }\n\n  walkAtRules(name, callback) {\n    if (!callback) {\n      callback = name\n      return this.walk((child, i) => {\n        if (child.type === 'atrule') {\n          return callback(child, i)\n        }\n      })\n    }\n    if (name instanceof RegExp) {\n      return this.walk((child, i) => {\n        if (child.type === 'atrule' && name.test(child.name)) {\n          return callback(child, i)\n        }\n      })\n    }\n    return this.walk((child, i) => {\n      if (child.type === 'atrule' && child.name === name) {\n        return callback(child, i)\n      }\n    })\n  }\n\n  walkComments(callback) {\n    return this.walk((child, i) => {\n      if (child.type === 'comment') {\n        return callback(child, i)\n      }\n    })\n  }\n\n  append(...children) {\n    for (let child of children) {\n      let nodes = this.normalize(child, this.last)\n      for (let node of nodes) this.proxyOf.nodes.push(node)\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  prepend(...children) {\n    children = children.reverse()\n    for (let child of children) {\n      let nodes = this.normalize(child, this.first, 'prepend').reverse()\n      for (let node of nodes) this.proxyOf.nodes.unshift(node)\n      for (let id in this.indexes) {\n        this.indexes[id] = this.indexes[id] + nodes.length\n      }\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  cleanRaws(keepBetween) {\n    super.cleanRaws(keepBetween)\n    if (this.nodes) {\n      for (let node of this.nodes) node.cleanRaws(keepBetween)\n    }\n  }\n\n  insertBefore(exist, add) {\n    let existIndex = this.index(exist)\n    let type = existIndex === 0 ? 'prepend' : false\n    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse()\n    existIndex = this.index(exist)\n    for (let node of nodes) this.proxyOf.nodes.splice(existIndex, 0, node)\n\n    let index\n    for (let id in this.indexes) {\n      index = this.indexes[id]\n      if (existIndex <= index) {\n        this.indexes[id] = index + nodes.length\n      }\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  insertAfter(exist, add) {\n    let existIndex = this.index(exist)\n    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse()\n    existIndex = this.index(exist)\n    for (let node of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node)\n\n    let index\n    for (let id in this.indexes) {\n      index = this.indexes[id]\n      if (existIndex < index) {\n        this.indexes[id] = index + nodes.length\n      }\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  removeChild(child) {\n    child = this.index(child)\n    this.proxyOf.nodes[child].parent = undefined\n    this.proxyOf.nodes.splice(child, 1)\n\n    let index\n    for (let id in this.indexes) {\n      index = this.indexes[id]\n      if (index >= child) {\n        this.indexes[id] = index - 1\n      }\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  removeAll() {\n    for (let node of this.proxyOf.nodes) node.parent = undefined\n    this.proxyOf.nodes = []\n\n    this.markDirty()\n\n    return this\n  }\n\n  replaceValues(pattern, opts, callback) {\n    if (!callback) {\n      callback = opts\n      opts = {}\n    }\n\n    this.walkDecls(decl => {\n      if (opts.props && !opts.props.includes(decl.prop)) return\n      if (opts.fast && !decl.value.includes(opts.fast)) return\n\n      decl.value = decl.value.replace(pattern, callback)\n    })\n\n    this.markDirty()\n\n    return this\n  }\n\n  every(condition) {\n    return this.nodes.every(condition)\n  }\n\n  some(condition) {\n    return this.nodes.some(condition)\n  }\n\n  index(child) {\n    if (typeof child === 'number') return child\n    if (child.proxyOf) child = child.proxyOf\n    return this.proxyOf.nodes.indexOf(child)\n  }\n\n  get first() {\n    if (!this.proxyOf.nodes) return undefined\n    return this.proxyOf.nodes[0]\n  }\n\n  get last() {\n    if (!this.proxyOf.nodes) return undefined\n    return this.proxyOf.nodes[this.proxyOf.nodes.length - 1]\n  }\n\n  normalize(nodes, sample) {\n    if (typeof nodes === 'string') {\n      nodes = cleanSource(parse(nodes).nodes)\n    } else if (Array.isArray(nodes)) {\n      nodes = nodes.slice(0)\n      for (let i of nodes) {\n        if (i.parent) i.parent.removeChild(i, 'ignore')\n      }\n    } else if (nodes.type === 'root' && this.type !== 'document') {\n      nodes = nodes.nodes.slice(0)\n      for (let i of nodes) {\n        if (i.parent) i.parent.removeChild(i, 'ignore')\n      }\n    } else if (nodes.type) {\n      nodes = [nodes]\n    } else if (nodes.prop) {\n      if (typeof nodes.value === 'undefined') {\n        throw new Error('Value field is missed in node creation')\n      } else if (typeof nodes.value !== 'string') {\n        nodes.value = String(nodes.value)\n      }\n      nodes = [new Declaration(nodes)]\n    } else if (nodes.selector) {\n      nodes = [new Rule(nodes)]\n    } else if (nodes.name) {\n      nodes = [new AtRule(nodes)]\n    } else if (nodes.text) {\n      nodes = [new Comment(nodes)]\n    } else {\n      throw new Error('Unknown node type in node creation')\n    }\n\n    let processed = nodes.map(i => {\n      /* c8 ignore next */\n      if (!i[my]) Container.rebuild(i)\n      i = i.proxyOf\n      if (i.parent) i.parent.removeChild(i)\n      if (i[isClean]) markDirtyUp(i)\n      if (typeof i.raws.before === 'undefined') {\n        if (sample && typeof sample.raws.before !== 'undefined') {\n          i.raws.before = sample.raws.before.replace(/\\S/g, '')\n        }\n      }\n      i.parent = this.proxyOf\n      return i\n    })\n\n    return processed\n  }\n\n  getProxyProcessor() {\n    return {\n      set(node, prop, value) {\n        if (node[prop] === value) return true\n        node[prop] = value\n        if (prop === 'name' || prop === 'params' || prop === 'selector') {\n          node.markDirty()\n        }\n        return true\n      },\n\n      get(node, prop) {\n        if (prop === 'proxyOf') {\n          return node\n        } else if (!node[prop]) {\n          return node[prop]\n        } else if (\n          prop === 'each' ||\n          (typeof prop === 'string' && prop.startsWith('walk'))\n        ) {\n          return (...args) => {\n            return node[prop](\n              ...args.map(i => {\n                if (typeof i === 'function') {\n                  return (child, index) => i(child.toProxy(), index)\n                } else {\n                  return i\n                }\n              })\n            )\n          }\n        } else if (prop === 'every' || prop === 'some') {\n          return cb => {\n            return node[prop]((child, ...other) =>\n              cb(child.toProxy(), ...other)\n            )\n          }\n        } else if (prop === 'root') {\n          return () => node.root().toProxy()\n        } else if (prop === 'nodes') {\n          return node.nodes.map(i => i.toProxy())\n        } else if (prop === 'first' || prop === 'last') {\n          return node[prop].toProxy()\n        } else {\n          return node[prop]\n        }\n      }\n    }\n  }\n\n  getIterator() {\n    if (!this.lastEach) this.lastEach = 0\n    if (!this.indexes) this.indexes = {}\n\n    this.lastEach += 1\n    let iterator = this.lastEach\n    this.indexes[iterator] = 0\n\n    return iterator\n  }\n}\n\nContainer.registerParse = dependant => {\n  parse = dependant\n}\n\nContainer.registerRule = dependant => {\n  Rule = dependant\n}\n\nContainer.registerAtRule = dependant => {\n  AtRule = dependant\n}\n\nContainer.registerRoot = dependant => {\n  Root = dependant\n}\n\nmodule.exports = Container\nContainer.default = Container\n\n/* c8 ignore start */\nContainer.rebuild = node => {\n  if (node.type === 'atrule') {\n    Object.setPrototypeOf(node, AtRule.prototype)\n  } else if (node.type === 'rule') {\n    Object.setPrototypeOf(node, Rule.prototype)\n  } else if (node.type === 'decl') {\n    Object.setPrototypeOf(node, Declaration.prototype)\n  } else if (node.type === 'comment') {\n    Object.setPrototypeOf(node, Comment.prototype)\n  } else if (node.type === 'root') {\n    Object.setPrototypeOf(node, Root.prototype)\n  }\n\n  node[my] = true\n\n  if (node.nodes) {\n    node.nodes.forEach(child => {\n      Container.rebuild(child)\n    })\n  }\n}\n/* c8 ignore stop */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvY29udGFpbmVyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLE1BQU0sY0FBYyxFQUFFLG1CQUFPLENBQUMsd0RBQVc7QUFDekMsa0JBQWtCLG1CQUFPLENBQUMsZ0VBQWU7QUFDekMsY0FBYyxtQkFBTyxDQUFDLHdEQUFXO0FBQ2pDLFdBQVcsbUJBQU8sQ0FBQyxrREFBUTs7QUFFM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzL2xpYi9jb250YWluZXIuanM/NzllNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubGV0IHsgaXNDbGVhbiwgbXkgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5sZXQgRGVjbGFyYXRpb24gPSByZXF1aXJlKCcuL2RlY2xhcmF0aW9uJylcbmxldCBDb21tZW50ID0gcmVxdWlyZSgnLi9jb21tZW50JylcbmxldCBOb2RlID0gcmVxdWlyZSgnLi9ub2RlJylcblxubGV0IHBhcnNlLCBSdWxlLCBBdFJ1bGUsIFJvb3RcblxuZnVuY3Rpb24gY2xlYW5Tb3VyY2Uobm9kZXMpIHtcbiAgcmV0dXJuIG5vZGVzLm1hcChpID0+IHtcbiAgICBpZiAoaS5ub2RlcykgaS5ub2RlcyA9IGNsZWFuU291cmNlKGkubm9kZXMpXG4gICAgZGVsZXRlIGkuc291cmNlXG4gICAgcmV0dXJuIGlcbiAgfSlcbn1cblxuZnVuY3Rpb24gbWFya0RpcnR5VXAobm9kZSkge1xuICBub2RlW2lzQ2xlYW5dID0gZmFsc2VcbiAgaWYgKG5vZGUucHJveHlPZi5ub2Rlcykge1xuICAgIGZvciAobGV0IGkgb2Ygbm9kZS5wcm94eU9mLm5vZGVzKSB7XG4gICAgICBtYXJrRGlydHlVcChpKVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBDb250YWluZXIgZXh0ZW5kcyBOb2RlIHtcbiAgcHVzaChjaGlsZCkge1xuICAgIGNoaWxkLnBhcmVudCA9IHRoaXNcbiAgICB0aGlzLnByb3h5T2Yubm9kZXMucHVzaChjaGlsZClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZWFjaChjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgbGV0IGl0ZXJhdG9yID0gdGhpcy5nZXRJdGVyYXRvcigpXG5cbiAgICBsZXQgaW5kZXgsIHJlc3VsdFxuICAgIHdoaWxlICh0aGlzLmluZGV4ZXNbaXRlcmF0b3JdIDwgdGhpcy5wcm94eU9mLm5vZGVzLmxlbmd0aCkge1xuICAgICAgaW5kZXggPSB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdXG4gICAgICByZXN1bHQgPSBjYWxsYmFjayh0aGlzLnByb3h5T2Yubm9kZXNbaW5kZXhdLCBpbmRleClcbiAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSBicmVha1xuXG4gICAgICB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdICs9IDFcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5pbmRleGVzW2l0ZXJhdG9yXVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIHdhbGsoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKChjaGlsZCwgaSkgPT4ge1xuICAgICAgbGV0IHJlc3VsdFxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2soY2hpbGQsIGkpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGNoaWxkLmFkZFRvRXJyb3IoZSlcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgIT09IGZhbHNlICYmIGNoaWxkLndhbGspIHtcbiAgICAgICAgcmVzdWx0ID0gY2hpbGQud2FsayhjYWxsYmFjaylcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0pXG4gIH1cblxuICB3YWxrRGVjbHMocHJvcCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayA9IHByb3BcbiAgICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnZGVjbCcpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIGlmIChwcm9wIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaSkgPT4ge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ2RlY2wnICYmIHByb3AudGVzdChjaGlsZC5wcm9wKSkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkpID0+IHtcbiAgICAgIGlmIChjaGlsZC50eXBlID09PSAnZGVjbCcgJiYgY2hpbGQucHJvcCA9PT0gcHJvcCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHdhbGtSdWxlcyhzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayA9IHNlbGVjdG9yXG5cbiAgICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSAncnVsZScpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIGlmIChzZWxlY3RvciBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdydWxlJyAmJiBzZWxlY3Rvci50ZXN0KGNoaWxkLnNlbGVjdG9yKSkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkpID0+IHtcbiAgICAgIGlmIChjaGlsZC50eXBlID09PSAncnVsZScgJiYgY2hpbGQuc2VsZWN0b3IgPT09IHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgd2Fsa0F0UnVsZXMobmFtZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayA9IG5hbWVcbiAgICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnYXRydWxlJykge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgaWYgKG5hbWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnYXRydWxlJyAmJiBuYW1lLnRlc3QoY2hpbGQubmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpKSA9PiB7XG4gICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ2F0cnVsZScgJiYgY2hpbGQubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHdhbGtDb21tZW50cyhjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpKSA9PiB7XG4gICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ2NvbW1lbnQnKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgYXBwZW5kKC4uLmNoaWxkcmVuKSB7XG4gICAgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgIGxldCBub2RlcyA9IHRoaXMubm9ybWFsaXplKGNoaWxkLCB0aGlzLmxhc3QpXG4gICAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKSB0aGlzLnByb3h5T2Yubm9kZXMucHVzaChub2RlKVxuICAgIH1cblxuICAgIHRoaXMubWFya0RpcnR5KClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcmVwZW5kKC4uLmNoaWxkcmVuKSB7XG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5yZXZlcnNlKClcbiAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgbGV0IG5vZGVzID0gdGhpcy5ub3JtYWxpemUoY2hpbGQsIHRoaXMuZmlyc3QsICdwcmVwZW5kJykucmV2ZXJzZSgpXG4gICAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKSB0aGlzLnByb3h5T2Yubm9kZXMudW5zaGlmdChub2RlKVxuICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy5pbmRleGVzKSB7XG4gICAgICAgIHRoaXMuaW5kZXhlc1tpZF0gPSB0aGlzLmluZGV4ZXNbaWRdICsgbm9kZXMubGVuZ3RoXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5tYXJrRGlydHkoKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGNsZWFuUmF3cyhrZWVwQmV0d2Vlbikge1xuICAgIHN1cGVyLmNsZWFuUmF3cyhrZWVwQmV0d2VlbilcbiAgICBpZiAodGhpcy5ub2Rlcykge1xuICAgICAgZm9yIChsZXQgbm9kZSBvZiB0aGlzLm5vZGVzKSBub2RlLmNsZWFuUmF3cyhrZWVwQmV0d2VlbilcbiAgICB9XG4gIH1cblxuICBpbnNlcnRCZWZvcmUoZXhpc3QsIGFkZCkge1xuICAgIGxldCBleGlzdEluZGV4ID0gdGhpcy5pbmRleChleGlzdClcbiAgICBsZXQgdHlwZSA9IGV4aXN0SW5kZXggPT09IDAgPyAncHJlcGVuZCcgOiBmYWxzZVxuICAgIGxldCBub2RlcyA9IHRoaXMubm9ybWFsaXplKGFkZCwgdGhpcy5wcm94eU9mLm5vZGVzW2V4aXN0SW5kZXhdLCB0eXBlKS5yZXZlcnNlKClcbiAgICBleGlzdEluZGV4ID0gdGhpcy5pbmRleChleGlzdClcbiAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKSB0aGlzLnByb3h5T2Yubm9kZXMuc3BsaWNlKGV4aXN0SW5kZXgsIDAsIG5vZGUpXG5cbiAgICBsZXQgaW5kZXhcbiAgICBmb3IgKGxldCBpZCBpbiB0aGlzLmluZGV4ZXMpIHtcbiAgICAgIGluZGV4ID0gdGhpcy5pbmRleGVzW2lkXVxuICAgICAgaWYgKGV4aXN0SW5kZXggPD0gaW5kZXgpIHtcbiAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IGluZGV4ICsgbm9kZXMubGVuZ3RoXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5tYXJrRGlydHkoKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGluc2VydEFmdGVyKGV4aXN0LCBhZGQpIHtcbiAgICBsZXQgZXhpc3RJbmRleCA9IHRoaXMuaW5kZXgoZXhpc3QpXG4gICAgbGV0IG5vZGVzID0gdGhpcy5ub3JtYWxpemUoYWRkLCB0aGlzLnByb3h5T2Yubm9kZXNbZXhpc3RJbmRleF0pLnJldmVyc2UoKVxuICAgIGV4aXN0SW5kZXggPSB0aGlzLmluZGV4KGV4aXN0KVxuICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpIHRoaXMucHJveHlPZi5ub2Rlcy5zcGxpY2UoZXhpc3RJbmRleCArIDEsIDAsIG5vZGUpXG5cbiAgICBsZXQgaW5kZXhcbiAgICBmb3IgKGxldCBpZCBpbiB0aGlzLmluZGV4ZXMpIHtcbiAgICAgIGluZGV4ID0gdGhpcy5pbmRleGVzW2lkXVxuICAgICAgaWYgKGV4aXN0SW5kZXggPCBpbmRleCkge1xuICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gaW5kZXggKyBub2Rlcy5sZW5ndGhcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm1hcmtEaXJ0eSgpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmVtb3ZlQ2hpbGQoY2hpbGQpIHtcbiAgICBjaGlsZCA9IHRoaXMuaW5kZXgoY2hpbGQpXG4gICAgdGhpcy5wcm94eU9mLm5vZGVzW2NoaWxkXS5wYXJlbnQgPSB1bmRlZmluZWRcbiAgICB0aGlzLnByb3h5T2Yubm9kZXMuc3BsaWNlKGNoaWxkLCAxKVxuXG4gICAgbGV0IGluZGV4XG4gICAgZm9yIChsZXQgaWQgaW4gdGhpcy5pbmRleGVzKSB7XG4gICAgICBpbmRleCA9IHRoaXMuaW5kZXhlc1tpZF1cbiAgICAgIGlmIChpbmRleCA+PSBjaGlsZCkge1xuICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gaW5kZXggLSAxXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5tYXJrRGlydHkoKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJlbW92ZUFsbCgpIHtcbiAgICBmb3IgKGxldCBub2RlIG9mIHRoaXMucHJveHlPZi5ub2Rlcykgbm9kZS5wYXJlbnQgPSB1bmRlZmluZWRcbiAgICB0aGlzLnByb3h5T2Yubm9kZXMgPSBbXVxuXG4gICAgdGhpcy5tYXJrRGlydHkoKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJlcGxhY2VWYWx1ZXMocGF0dGVybiwgb3B0cywgY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdHNcbiAgICAgIG9wdHMgPSB7fVxuICAgIH1cblxuICAgIHRoaXMud2Fsa0RlY2xzKGRlY2wgPT4ge1xuICAgICAgaWYgKG9wdHMucHJvcHMgJiYgIW9wdHMucHJvcHMuaW5jbHVkZXMoZGVjbC5wcm9wKSkgcmV0dXJuXG4gICAgICBpZiAob3B0cy5mYXN0ICYmICFkZWNsLnZhbHVlLmluY2x1ZGVzKG9wdHMuZmFzdCkpIHJldHVyblxuXG4gICAgICBkZWNsLnZhbHVlID0gZGVjbC52YWx1ZS5yZXBsYWNlKHBhdHRlcm4sIGNhbGxiYWNrKVxuICAgIH0pXG5cbiAgICB0aGlzLm1hcmtEaXJ0eSgpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZXZlcnkoY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMuZXZlcnkoY29uZGl0aW9uKVxuICB9XG5cbiAgc29tZShjb25kaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5zb21lKGNvbmRpdGlvbilcbiAgfVxuXG4gIGluZGV4KGNoaWxkKSB7XG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHJldHVybiBjaGlsZFxuICAgIGlmIChjaGlsZC5wcm94eU9mKSBjaGlsZCA9IGNoaWxkLnByb3h5T2ZcbiAgICByZXR1cm4gdGhpcy5wcm94eU9mLm5vZGVzLmluZGV4T2YoY2hpbGQpXG4gIH1cblxuICBnZXQgZmlyc3QoKSB7XG4gICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5wcm94eU9mLm5vZGVzWzBdXG4gIH1cblxuICBnZXQgbGFzdCgpIHtcbiAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLnByb3h5T2Yubm9kZXNbdGhpcy5wcm94eU9mLm5vZGVzLmxlbmd0aCAtIDFdXG4gIH1cblxuICBub3JtYWxpemUobm9kZXMsIHNhbXBsZSkge1xuICAgIGlmICh0eXBlb2Ygbm9kZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBub2RlcyA9IGNsZWFuU291cmNlKHBhcnNlKG5vZGVzKS5ub2RlcylcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobm9kZXMpKSB7XG4gICAgICBub2RlcyA9IG5vZGVzLnNsaWNlKDApXG4gICAgICBmb3IgKGxldCBpIG9mIG5vZGVzKSB7XG4gICAgICAgIGlmIChpLnBhcmVudCkgaS5wYXJlbnQucmVtb3ZlQ2hpbGQoaSwgJ2lnbm9yZScpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2Rlcy50eXBlID09PSAncm9vdCcgJiYgdGhpcy50eXBlICE9PSAnZG9jdW1lbnQnKSB7XG4gICAgICBub2RlcyA9IG5vZGVzLm5vZGVzLnNsaWNlKDApXG4gICAgICBmb3IgKGxldCBpIG9mIG5vZGVzKSB7XG4gICAgICAgIGlmIChpLnBhcmVudCkgaS5wYXJlbnQucmVtb3ZlQ2hpbGQoaSwgJ2lnbm9yZScpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2Rlcy50eXBlKSB7XG4gICAgICBub2RlcyA9IFtub2Rlc11cbiAgICB9IGVsc2UgaWYgKG5vZGVzLnByb3ApIHtcbiAgICAgIGlmICh0eXBlb2Ygbm9kZXMudmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgZmllbGQgaXMgbWlzc2VkIGluIG5vZGUgY3JlYXRpb24nKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZXMudmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5vZGVzLnZhbHVlID0gU3RyaW5nKG5vZGVzLnZhbHVlKVxuICAgICAgfVxuICAgICAgbm9kZXMgPSBbbmV3IERlY2xhcmF0aW9uKG5vZGVzKV1cbiAgICB9IGVsc2UgaWYgKG5vZGVzLnNlbGVjdG9yKSB7XG4gICAgICBub2RlcyA9IFtuZXcgUnVsZShub2RlcyldXG4gICAgfSBlbHNlIGlmIChub2Rlcy5uYW1lKSB7XG4gICAgICBub2RlcyA9IFtuZXcgQXRSdWxlKG5vZGVzKV1cbiAgICB9IGVsc2UgaWYgKG5vZGVzLnRleHQpIHtcbiAgICAgIG5vZGVzID0gW25ldyBDb21tZW50KG5vZGVzKV1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG5vZGUgdHlwZSBpbiBub2RlIGNyZWF0aW9uJylcbiAgICB9XG5cbiAgICBsZXQgcHJvY2Vzc2VkID0gbm9kZXMubWFwKGkgPT4ge1xuICAgICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICAgIGlmICghaVtteV0pIENvbnRhaW5lci5yZWJ1aWxkKGkpXG4gICAgICBpID0gaS5wcm94eU9mXG4gICAgICBpZiAoaS5wYXJlbnQpIGkucGFyZW50LnJlbW92ZUNoaWxkKGkpXG4gICAgICBpZiAoaVtpc0NsZWFuXSkgbWFya0RpcnR5VXAoaSlcbiAgICAgIGlmICh0eXBlb2YgaS5yYXdzLmJlZm9yZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHNhbXBsZSAmJiB0eXBlb2Ygc2FtcGxlLnJhd3MuYmVmb3JlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGkucmF3cy5iZWZvcmUgPSBzYW1wbGUucmF3cy5iZWZvcmUucmVwbGFjZSgvXFxTL2csICcnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpLnBhcmVudCA9IHRoaXMucHJveHlPZlxuICAgICAgcmV0dXJuIGlcbiAgICB9KVxuXG4gICAgcmV0dXJuIHByb2Nlc3NlZFxuICB9XG5cbiAgZ2V0UHJveHlQcm9jZXNzb3IoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldChub2RlLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICBpZiAobm9kZVtwcm9wXSA9PT0gdmFsdWUpIHJldHVybiB0cnVlXG4gICAgICAgIG5vZGVbcHJvcF0gPSB2YWx1ZVxuICAgICAgICBpZiAocHJvcCA9PT0gJ25hbWUnIHx8IHByb3AgPT09ICdwYXJhbXMnIHx8IHByb3AgPT09ICdzZWxlY3RvcicpIHtcbiAgICAgICAgICBub2RlLm1hcmtEaXJ0eSgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0sXG5cbiAgICAgIGdldChub2RlLCBwcm9wKSB7XG4gICAgICAgIGlmIChwcm9wID09PSAncHJveHlPZicpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZVxuICAgICAgICB9IGVsc2UgaWYgKCFub2RlW3Byb3BdKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGVbcHJvcF1cbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBwcm9wID09PSAnZWFjaCcgfHxcbiAgICAgICAgICAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnICYmIHByb3Auc3RhcnRzV2l0aCgnd2FsaycpKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBub2RlW3Byb3BdKFxuICAgICAgICAgICAgICAuLi5hcmdzLm1hcChpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAoY2hpbGQsIGluZGV4KSA9PiBpKGNoaWxkLnRvUHJveHkoKSwgaW5kZXgpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSAnZXZlcnknIHx8IHByb3AgPT09ICdzb21lJykge1xuICAgICAgICAgIHJldHVybiBjYiA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZVtwcm9wXSgoY2hpbGQsIC4uLm90aGVyKSA9PlxuICAgICAgICAgICAgICBjYihjaGlsZC50b1Byb3h5KCksIC4uLm90aGVyKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSAncm9vdCcpIHtcbiAgICAgICAgICByZXR1cm4gKCkgPT4gbm9kZS5yb290KCkudG9Qcm94eSgpXG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gJ25vZGVzJykge1xuICAgICAgICAgIHJldHVybiBub2RlLm5vZGVzLm1hcChpID0+IGkudG9Qcm94eSgpKVxuICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09ICdmaXJzdCcgfHwgcHJvcCA9PT0gJ2xhc3QnKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGVbcHJvcF0udG9Qcm94eSgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGVbcHJvcF1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldEl0ZXJhdG9yKCkge1xuICAgIGlmICghdGhpcy5sYXN0RWFjaCkgdGhpcy5sYXN0RWFjaCA9IDBcbiAgICBpZiAoIXRoaXMuaW5kZXhlcykgdGhpcy5pbmRleGVzID0ge31cblxuICAgIHRoaXMubGFzdEVhY2ggKz0gMVxuICAgIGxldCBpdGVyYXRvciA9IHRoaXMubGFzdEVhY2hcbiAgICB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdID0gMFxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cbn1cblxuQ29udGFpbmVyLnJlZ2lzdGVyUGFyc2UgPSBkZXBlbmRhbnQgPT4ge1xuICBwYXJzZSA9IGRlcGVuZGFudFxufVxuXG5Db250YWluZXIucmVnaXN0ZXJSdWxlID0gZGVwZW5kYW50ID0+IHtcbiAgUnVsZSA9IGRlcGVuZGFudFxufVxuXG5Db250YWluZXIucmVnaXN0ZXJBdFJ1bGUgPSBkZXBlbmRhbnQgPT4ge1xuICBBdFJ1bGUgPSBkZXBlbmRhbnRcbn1cblxuQ29udGFpbmVyLnJlZ2lzdGVyUm9vdCA9IGRlcGVuZGFudCA9PiB7XG4gIFJvb3QgPSBkZXBlbmRhbnRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb250YWluZXJcbkNvbnRhaW5lci5kZWZhdWx0ID0gQ29udGFpbmVyXG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuQ29udGFpbmVyLnJlYnVpbGQgPSBub2RlID0+IHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gJ2F0cnVsZScpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZSwgQXRSdWxlLnByb3RvdHlwZSlcbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdydWxlJykge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlLCBSdWxlLnByb3RvdHlwZSlcbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdkZWNsJykge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlLCBEZWNsYXJhdGlvbi5wcm90b3R5cGUpXG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAnY29tbWVudCcpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZSwgQ29tbWVudC5wcm90b3R5cGUpXG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAncm9vdCcpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZSwgUm9vdC5wcm90b3R5cGUpXG4gIH1cblxuICBub2RlW215XSA9IHRydWVcblxuICBpZiAobm9kZS5ub2Rlcykge1xuICAgIG5vZGUubm9kZXMuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBDb250YWluZXIucmVidWlsZChjaGlsZClcbiAgICB9KVxuICB9XG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/container.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/css-syntax-error.js":
/*!******************************************************!*\
  !*** ./node_modules/postcss/lib/css-syntax-error.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet pico = __webpack_require__(/*! picocolors */ \"./node_modules/picocolors/picocolors.browser.js\")\n\nlet terminalHighlight = __webpack_require__(/*! ./terminal-highlight */ \"?fe98\")\n\nclass CssSyntaxError extends Error {\n  constructor(message, line, column, source, file, plugin) {\n    super(message)\n    this.name = 'CssSyntaxError'\n    this.reason = message\n\n    if (file) {\n      this.file = file\n    }\n    if (source) {\n      this.source = source\n    }\n    if (plugin) {\n      this.plugin = plugin\n    }\n    if (typeof line !== 'undefined' && typeof column !== 'undefined') {\n      if (typeof line === 'number') {\n        this.line = line\n        this.column = column\n      } else {\n        this.line = line.line\n        this.column = line.column\n        this.endLine = column.line\n        this.endColumn = column.column\n      }\n    }\n\n    this.setMessage()\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, CssSyntaxError)\n    }\n  }\n\n  setMessage() {\n    this.message = this.plugin ? this.plugin + ': ' : ''\n    this.message += this.file ? this.file : '<css input>'\n    if (typeof this.line !== 'undefined') {\n      this.message += ':' + this.line + ':' + this.column\n    }\n    this.message += ': ' + this.reason\n  }\n\n  showSourceCode(color) {\n    if (!this.source) return ''\n\n    let css = this.source\n    if (color == null) color = pico.isColorSupported\n    if (terminalHighlight) {\n      if (color) css = terminalHighlight(css)\n    }\n\n    let lines = css.split(/\\r?\\n/)\n    let start = Math.max(this.line - 3, 0)\n    let end = Math.min(this.line + 2, lines.length)\n\n    let maxWidth = String(end).length\n\n    let mark, aside\n    if (color) {\n      let { bold, red, gray } = pico.createColors(true)\n      mark = text => bold(red(text))\n      aside = text => gray(text)\n    } else {\n      mark = aside = str => str\n    }\n\n    return lines\n      .slice(start, end)\n      .map((line, index) => {\n        let number = start + 1 + index\n        let gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | '\n        if (number === this.line) {\n          let spacing =\n            aside(gutter.replace(/\\d/g, ' ')) +\n            line.slice(0, this.column - 1).replace(/[^\\t]/g, ' ')\n          return mark('>') + aside(gutter) + line + '\\n ' + spacing + mark('^')\n        }\n        return ' ' + aside(gutter) + line\n      })\n      .join('\\n')\n  }\n\n  toString() {\n    let code = this.showSourceCode()\n    if (code) {\n      code = '\\n\\n' + code + '\\n'\n    }\n    return this.name + ': ' + this.message + code\n  }\n}\n\nmodule.exports = CssSyntaxError\nCssSyntaxError.default = CssSyntaxError\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvY3NzLXN5bnRheC1lcnJvci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixXQUFXLG1CQUFPLENBQUMsbUVBQVk7O0FBRS9CLHdCQUF3QixtQkFBTyxDQUFDLG1DQUFzQjs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL2Nzcy1zeW50YXgtZXJyb3IuanM/MTE3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubGV0IHBpY28gPSByZXF1aXJlKCdwaWNvY29sb3JzJylcblxubGV0IHRlcm1pbmFsSGlnaGxpZ2h0ID0gcmVxdWlyZSgnLi90ZXJtaW5hbC1oaWdobGlnaHQnKVxuXG5jbGFzcyBDc3NTeW50YXhFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgbGluZSwgY29sdW1uLCBzb3VyY2UsIGZpbGUsIHBsdWdpbikge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0Nzc1N5bnRheEVycm9yJ1xuICAgIHRoaXMucmVhc29uID0gbWVzc2FnZVxuXG4gICAgaWYgKGZpbGUpIHtcbiAgICAgIHRoaXMuZmlsZSA9IGZpbGVcbiAgICB9XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2VcbiAgICB9XG4gICAgaWYgKHBsdWdpbikge1xuICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW5cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBsaW5lICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29sdW1uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHR5cGVvZiBsaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLmxpbmUgPSBsaW5lXG4gICAgICAgIHRoaXMuY29sdW1uID0gY29sdW1uXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxpbmUgPSBsaW5lLmxpbmVcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBsaW5lLmNvbHVtblxuICAgICAgICB0aGlzLmVuZExpbmUgPSBjb2x1bW4ubGluZVxuICAgICAgICB0aGlzLmVuZENvbHVtbiA9IGNvbHVtbi5jb2x1bW5cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldE1lc3NhZ2UoKVxuXG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDc3NTeW50YXhFcnJvcilcbiAgICB9XG4gIH1cblxuICBzZXRNZXNzYWdlKCkge1xuICAgIHRoaXMubWVzc2FnZSA9IHRoaXMucGx1Z2luID8gdGhpcy5wbHVnaW4gKyAnOiAnIDogJydcbiAgICB0aGlzLm1lc3NhZ2UgKz0gdGhpcy5maWxlID8gdGhpcy5maWxlIDogJzxjc3MgaW5wdXQ+J1xuICAgIGlmICh0eXBlb2YgdGhpcy5saW5lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5tZXNzYWdlICs9ICc6JyArIHRoaXMubGluZSArICc6JyArIHRoaXMuY29sdW1uXG4gICAgfVxuICAgIHRoaXMubWVzc2FnZSArPSAnOiAnICsgdGhpcy5yZWFzb25cbiAgfVxuXG4gIHNob3dTb3VyY2VDb2RlKGNvbG9yKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZSkgcmV0dXJuICcnXG5cbiAgICBsZXQgY3NzID0gdGhpcy5zb3VyY2VcbiAgICBpZiAoY29sb3IgPT0gbnVsbCkgY29sb3IgPSBwaWNvLmlzQ29sb3JTdXBwb3J0ZWRcbiAgICBpZiAodGVybWluYWxIaWdobGlnaHQpIHtcbiAgICAgIGlmIChjb2xvcikgY3NzID0gdGVybWluYWxIaWdobGlnaHQoY3NzKVxuICAgIH1cblxuICAgIGxldCBsaW5lcyA9IGNzcy5zcGxpdCgvXFxyP1xcbi8pXG4gICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgodGhpcy5saW5lIC0gMywgMClcbiAgICBsZXQgZW5kID0gTWF0aC5taW4odGhpcy5saW5lICsgMiwgbGluZXMubGVuZ3RoKVxuXG4gICAgbGV0IG1heFdpZHRoID0gU3RyaW5nKGVuZCkubGVuZ3RoXG5cbiAgICBsZXQgbWFyaywgYXNpZGVcbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIGxldCB7IGJvbGQsIHJlZCwgZ3JheSB9ID0gcGljby5jcmVhdGVDb2xvcnModHJ1ZSlcbiAgICAgIG1hcmsgPSB0ZXh0ID0+IGJvbGQocmVkKHRleHQpKVxuICAgICAgYXNpZGUgPSB0ZXh0ID0+IGdyYXkodGV4dClcbiAgICB9IGVsc2Uge1xuICAgICAgbWFyayA9IGFzaWRlID0gc3RyID0+IHN0clxuICAgIH1cblxuICAgIHJldHVybiBsaW5lc1xuICAgICAgLnNsaWNlKHN0YXJ0LCBlbmQpXG4gICAgICAubWFwKChsaW5lLCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgbnVtYmVyID0gc3RhcnQgKyAxICsgaW5kZXhcbiAgICAgICAgbGV0IGd1dHRlciA9ICcgJyArICgnICcgKyBudW1iZXIpLnNsaWNlKC1tYXhXaWR0aCkgKyAnIHwgJ1xuICAgICAgICBpZiAobnVtYmVyID09PSB0aGlzLmxpbmUpIHtcbiAgICAgICAgICBsZXQgc3BhY2luZyA9XG4gICAgICAgICAgICBhc2lkZShndXR0ZXIucmVwbGFjZSgvXFxkL2csICcgJykpICtcbiAgICAgICAgICAgIGxpbmUuc2xpY2UoMCwgdGhpcy5jb2x1bW4gLSAxKS5yZXBsYWNlKC9bXlxcdF0vZywgJyAnKVxuICAgICAgICAgIHJldHVybiBtYXJrKCc+JykgKyBhc2lkZShndXR0ZXIpICsgbGluZSArICdcXG4gJyArIHNwYWNpbmcgKyBtYXJrKCdeJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyAnICsgYXNpZGUoZ3V0dGVyKSArIGxpbmVcbiAgICAgIH0pXG4gICAgICAuam9pbignXFxuJylcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGxldCBjb2RlID0gdGhpcy5zaG93U291cmNlQ29kZSgpXG4gICAgaWYgKGNvZGUpIHtcbiAgICAgIGNvZGUgPSAnXFxuXFxuJyArIGNvZGUgKyAnXFxuJ1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5uYW1lICsgJzogJyArIHRoaXMubWVzc2FnZSArIGNvZGVcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENzc1N5bnRheEVycm9yXG5Dc3NTeW50YXhFcnJvci5kZWZhdWx0ID0gQ3NzU3ludGF4RXJyb3JcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/css-syntax-error.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/declaration.js":
/*!*************************************************!*\
  !*** ./node_modules/postcss/lib/declaration.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Node = __webpack_require__(/*! ./node */ \"./node_modules/postcss/lib/node.js\")\n\nclass Declaration extends Node {\n  constructor(defaults) {\n    if (\n      defaults &&\n      typeof defaults.value !== 'undefined' &&\n      typeof defaults.value !== 'string'\n    ) {\n      defaults = { ...defaults, value: String(defaults.value) }\n    }\n    super(defaults)\n    this.type = 'decl'\n  }\n\n  get variable() {\n    return this.prop.startsWith('--') || this.prop[0] === '$'\n  }\n}\n\nmodule.exports = Declaration\nDeclaration.default = Declaration\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvZGVjbGFyYXRpb24uanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosV0FBVyxtQkFBTyxDQUFDLGtEQUFROztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL2RlY2xhcmF0aW9uLmpzP2UxMjEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmxldCBOb2RlID0gcmVxdWlyZSgnLi9ub2RlJylcblxuY2xhc3MgRGVjbGFyYXRpb24gZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdHMpIHtcbiAgICBpZiAoXG4gICAgICBkZWZhdWx0cyAmJlxuICAgICAgdHlwZW9mIGRlZmF1bHRzLnZhbHVlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdHlwZW9mIGRlZmF1bHRzLnZhbHVlICE9PSAnc3RyaW5nJ1xuICAgICkge1xuICAgICAgZGVmYXVsdHMgPSB7IC4uLmRlZmF1bHRzLCB2YWx1ZTogU3RyaW5nKGRlZmF1bHRzLnZhbHVlKSB9XG4gICAgfVxuICAgIHN1cGVyKGRlZmF1bHRzKVxuICAgIHRoaXMudHlwZSA9ICdkZWNsJ1xuICB9XG5cbiAgZ2V0IHZhcmlhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnByb3Auc3RhcnRzV2l0aCgnLS0nKSB8fCB0aGlzLnByb3BbMF0gPT09ICckJ1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGVjbGFyYXRpb25cbkRlY2xhcmF0aW9uLmRlZmF1bHQgPSBEZWNsYXJhdGlvblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/declaration.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/document.js":
/*!**********************************************!*\
  !*** ./node_modules/postcss/lib/document.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Container = __webpack_require__(/*! ./container */ \"./node_modules/postcss/lib/container.js\")\n\nlet LazyResult, Processor\n\nclass Document extends Container {\n  constructor(defaults) {\n    // type needs to be passed to super, otherwise child roots won't be normalized correctly\n    super({ type: 'document', ...defaults })\n\n    if (!this.nodes) {\n      this.nodes = []\n    }\n  }\n\n  toResult(opts = {}) {\n    let lazy = new LazyResult(new Processor(), this, opts)\n\n    return lazy.stringify()\n  }\n}\n\nDocument.registerLazyResult = dependant => {\n  LazyResult = dependant\n}\n\nDocument.registerProcessor = dependant => {\n  Processor = dependant\n}\n\nmodule.exports = Document\nDocument.default = Document\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvZG9jdW1lbnQuanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZ0JBQWdCLG1CQUFPLENBQUMsNERBQWE7O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0JBQStCOztBQUUzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzL2xpYi9kb2N1bWVudC5qcz9iYzUxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5sZXQgQ29udGFpbmVyID0gcmVxdWlyZSgnLi9jb250YWluZXInKVxuXG5sZXQgTGF6eVJlc3VsdCwgUHJvY2Vzc29yXG5cbmNsYXNzIERvY3VtZW50IGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdHMpIHtcbiAgICAvLyB0eXBlIG5lZWRzIHRvIGJlIHBhc3NlZCB0byBzdXBlciwgb3RoZXJ3aXNlIGNoaWxkIHJvb3RzIHdvbid0IGJlIG5vcm1hbGl6ZWQgY29ycmVjdGx5XG4gICAgc3VwZXIoeyB0eXBlOiAnZG9jdW1lbnQnLCAuLi5kZWZhdWx0cyB9KVxuXG4gICAgaWYgKCF0aGlzLm5vZGVzKSB7XG4gICAgICB0aGlzLm5vZGVzID0gW11cbiAgICB9XG4gIH1cblxuICB0b1Jlc3VsdChvcHRzID0ge30pIHtcbiAgICBsZXQgbGF6eSA9IG5ldyBMYXp5UmVzdWx0KG5ldyBQcm9jZXNzb3IoKSwgdGhpcywgb3B0cylcblxuICAgIHJldHVybiBsYXp5LnN0cmluZ2lmeSgpXG4gIH1cbn1cblxuRG9jdW1lbnQucmVnaXN0ZXJMYXp5UmVzdWx0ID0gZGVwZW5kYW50ID0+IHtcbiAgTGF6eVJlc3VsdCA9IGRlcGVuZGFudFxufVxuXG5Eb2N1bWVudC5yZWdpc3RlclByb2Nlc3NvciA9IGRlcGVuZGFudCA9PiB7XG4gIFByb2Nlc3NvciA9IGRlcGVuZGFudFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERvY3VtZW50XG5Eb2N1bWVudC5kZWZhdWx0ID0gRG9jdW1lbnRcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/document.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/fromJSON.js":
/*!**********************************************!*\
  !*** ./node_modules/postcss/lib/fromJSON.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Declaration = __webpack_require__(/*! ./declaration */ \"./node_modules/postcss/lib/declaration.js\")\nlet PreviousMap = __webpack_require__(/*! ./previous-map */ \"./node_modules/postcss/lib/previous-map.js\")\nlet Comment = __webpack_require__(/*! ./comment */ \"./node_modules/postcss/lib/comment.js\")\nlet AtRule = __webpack_require__(/*! ./at-rule */ \"./node_modules/postcss/lib/at-rule.js\")\nlet Input = __webpack_require__(/*! ./input */ \"./node_modules/postcss/lib/input.js\")\nlet Root = __webpack_require__(/*! ./root */ \"./node_modules/postcss/lib/root.js\")\nlet Rule = __webpack_require__(/*! ./rule */ \"./node_modules/postcss/lib/rule.js\")\n\nfunction fromJSON(json, inputs) {\n  if (Array.isArray(json)) return json.map(n => fromJSON(n))\n\n  let { inputs: ownInputs, ...defaults } = json\n  if (ownInputs) {\n    inputs = []\n    for (let input of ownInputs) {\n      let inputHydrated = { ...input, __proto__: Input.prototype }\n      if (inputHydrated.map) {\n        inputHydrated.map = {\n          ...inputHydrated.map,\n          __proto__: PreviousMap.prototype\n        }\n      }\n      inputs.push(inputHydrated)\n    }\n  }\n  if (defaults.nodes) {\n    defaults.nodes = json.nodes.map(n => fromJSON(n, inputs))\n  }\n  if (defaults.source) {\n    let { inputId, ...source } = defaults.source\n    defaults.source = source\n    if (inputId != null) {\n      defaults.source.input = inputs[inputId]\n    }\n  }\n  if (defaults.type === 'root') {\n    return new Root(defaults)\n  } else if (defaults.type === 'decl') {\n    return new Declaration(defaults)\n  } else if (defaults.type === 'rule') {\n    return new Rule(defaults)\n  } else if (defaults.type === 'comment') {\n    return new Comment(defaults)\n  } else if (defaults.type === 'atrule') {\n    return new AtRule(defaults)\n  } else {\n    throw new Error('Unknown node type: ' + json.type)\n  }\n}\n\nmodule.exports = fromJSON\nfromJSON.default = fromJSON\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvZnJvbUpTT04uanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosa0JBQWtCLG1CQUFPLENBQUMsZ0VBQWU7QUFDekMsa0JBQWtCLG1CQUFPLENBQUMsa0VBQWdCO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQyx3REFBVztBQUNqQyxhQUFhLG1CQUFPLENBQUMsd0RBQVc7QUFDaEMsWUFBWSxtQkFBTyxDQUFDLG9EQUFTO0FBQzdCLFdBQVcsbUJBQU8sQ0FBQyxrREFBUTtBQUMzQixXQUFXLG1CQUFPLENBQUMsa0RBQVE7O0FBRTNCO0FBQ0E7O0FBRUEsUUFBUSxpQ0FBaUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxQkFBcUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvZnJvbUpTT04uanM/YTM3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubGV0IERlY2xhcmF0aW9uID0gcmVxdWlyZSgnLi9kZWNsYXJhdGlvbicpXG5sZXQgUHJldmlvdXNNYXAgPSByZXF1aXJlKCcuL3ByZXZpb3VzLW1hcCcpXG5sZXQgQ29tbWVudCA9IHJlcXVpcmUoJy4vY29tbWVudCcpXG5sZXQgQXRSdWxlID0gcmVxdWlyZSgnLi9hdC1ydWxlJylcbmxldCBJbnB1dCA9IHJlcXVpcmUoJy4vaW5wdXQnKVxubGV0IFJvb3QgPSByZXF1aXJlKCcuL3Jvb3QnKVxubGV0IFJ1bGUgPSByZXF1aXJlKCcuL3J1bGUnKVxuXG5mdW5jdGlvbiBmcm9tSlNPTihqc29uLCBpbnB1dHMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoanNvbikpIHJldHVybiBqc29uLm1hcChuID0+IGZyb21KU09OKG4pKVxuXG4gIGxldCB7IGlucHV0czogb3duSW5wdXRzLCAuLi5kZWZhdWx0cyB9ID0ganNvblxuICBpZiAob3duSW5wdXRzKSB7XG4gICAgaW5wdXRzID0gW11cbiAgICBmb3IgKGxldCBpbnB1dCBvZiBvd25JbnB1dHMpIHtcbiAgICAgIGxldCBpbnB1dEh5ZHJhdGVkID0geyAuLi5pbnB1dCwgX19wcm90b19fOiBJbnB1dC5wcm90b3R5cGUgfVxuICAgICAgaWYgKGlucHV0SHlkcmF0ZWQubWFwKSB7XG4gICAgICAgIGlucHV0SHlkcmF0ZWQubWFwID0ge1xuICAgICAgICAgIC4uLmlucHV0SHlkcmF0ZWQubWFwLFxuICAgICAgICAgIF9fcHJvdG9fXzogUHJldmlvdXNNYXAucHJvdG90eXBlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlucHV0cy5wdXNoKGlucHV0SHlkcmF0ZWQpXG4gICAgfVxuICB9XG4gIGlmIChkZWZhdWx0cy5ub2Rlcykge1xuICAgIGRlZmF1bHRzLm5vZGVzID0ganNvbi5ub2Rlcy5tYXAobiA9PiBmcm9tSlNPTihuLCBpbnB1dHMpKVxuICB9XG4gIGlmIChkZWZhdWx0cy5zb3VyY2UpIHtcbiAgICBsZXQgeyBpbnB1dElkLCAuLi5zb3VyY2UgfSA9IGRlZmF1bHRzLnNvdXJjZVxuICAgIGRlZmF1bHRzLnNvdXJjZSA9IHNvdXJjZVxuICAgIGlmIChpbnB1dElkICE9IG51bGwpIHtcbiAgICAgIGRlZmF1bHRzLnNvdXJjZS5pbnB1dCA9IGlucHV0c1tpbnB1dElkXVxuICAgIH1cbiAgfVxuICBpZiAoZGVmYXVsdHMudHlwZSA9PT0gJ3Jvb3QnKSB7XG4gICAgcmV0dXJuIG5ldyBSb290KGRlZmF1bHRzKVxuICB9IGVsc2UgaWYgKGRlZmF1bHRzLnR5cGUgPT09ICdkZWNsJykge1xuICAgIHJldHVybiBuZXcgRGVjbGFyYXRpb24oZGVmYXVsdHMpXG4gIH0gZWxzZSBpZiAoZGVmYXVsdHMudHlwZSA9PT0gJ3J1bGUnKSB7XG4gICAgcmV0dXJuIG5ldyBSdWxlKGRlZmF1bHRzKVxuICB9IGVsc2UgaWYgKGRlZmF1bHRzLnR5cGUgPT09ICdjb21tZW50Jykge1xuICAgIHJldHVybiBuZXcgQ29tbWVudChkZWZhdWx0cylcbiAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSAnYXRydWxlJykge1xuICAgIHJldHVybiBuZXcgQXRSdWxlKGRlZmF1bHRzKVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBub2RlIHR5cGU6ICcgKyBqc29uLnR5cGUpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmcm9tSlNPTlxuZnJvbUpTT04uZGVmYXVsdCA9IGZyb21KU09OXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/fromJSON.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/input.js":
/*!*******************************************!*\
  !*** ./node_modules/postcss/lib/input.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet { SourceMapConsumer, SourceMapGenerator } = __webpack_require__(/*! source-map-js */ \"?6f78\")\nlet { fileURLToPath, pathToFileURL } = __webpack_require__(/*! url */ \"?9214\")\nlet { resolve, isAbsolute } = __webpack_require__(/*! path */ \"?25fb\")\nlet { nanoid } = __webpack_require__(/*! nanoid/non-secure */ \"./node_modules/nanoid/non-secure/index.cjs\")\n\nlet terminalHighlight = __webpack_require__(/*! ./terminal-highlight */ \"?fe98\")\nlet CssSyntaxError = __webpack_require__(/*! ./css-syntax-error */ \"./node_modules/postcss/lib/css-syntax-error.js\")\nlet PreviousMap = __webpack_require__(/*! ./previous-map */ \"./node_modules/postcss/lib/previous-map.js\")\n\nlet fromOffsetCache = Symbol('fromOffsetCache')\n\nlet sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator)\nlet pathAvailable = Boolean(resolve && isAbsolute)\n\nclass Input {\n  constructor(css, opts = {}) {\n    if (\n      css === null ||\n      typeof css === 'undefined' ||\n      (typeof css === 'object' && !css.toString)\n    ) {\n      throw new Error(`PostCSS received ${css} instead of CSS string`)\n    }\n\n    this.css = css.toString()\n\n    if (this.css[0] === '\\uFEFF' || this.css[0] === '\\uFFFE') {\n      this.hasBOM = true\n      this.css = this.css.slice(1)\n    } else {\n      this.hasBOM = false\n    }\n\n    if (opts.from) {\n      if (\n        !pathAvailable ||\n        /^\\w+:\\/\\//.test(opts.from) ||\n        isAbsolute(opts.from)\n      ) {\n        this.file = opts.from\n      } else {\n        this.file = resolve(opts.from)\n      }\n    }\n\n    if (pathAvailable && sourceMapAvailable) {\n      let map = new PreviousMap(this.css, opts)\n      if (map.text) {\n        this.map = map\n        let file = map.consumer().file\n        if (!this.file && file) this.file = this.mapResolve(file)\n      }\n    }\n\n    if (!this.file) {\n      this.id = '<input css ' + nanoid(6) + '>'\n    }\n    if (this.map) this.map.file = this.from\n  }\n\n  fromOffset(offset) {\n    let lastLine, lineToIndex\n    if (!this[fromOffsetCache]) {\n      let lines = this.css.split('\\n')\n      lineToIndex = new Array(lines.length)\n      let prevIndex = 0\n\n      for (let i = 0, l = lines.length; i < l; i++) {\n        lineToIndex[i] = prevIndex\n        prevIndex += lines[i].length + 1\n      }\n\n      this[fromOffsetCache] = lineToIndex\n    } else {\n      lineToIndex = this[fromOffsetCache]\n    }\n    lastLine = lineToIndex[lineToIndex.length - 1]\n\n    let min = 0\n    if (offset >= lastLine) {\n      min = lineToIndex.length - 1\n    } else {\n      let max = lineToIndex.length - 2\n      let mid\n      while (min < max) {\n        mid = min + ((max - min) >> 1)\n        if (offset < lineToIndex[mid]) {\n          max = mid - 1\n        } else if (offset >= lineToIndex[mid + 1]) {\n          min = mid + 1\n        } else {\n          min = mid\n          break\n        }\n      }\n    }\n    return {\n      line: min + 1,\n      col: offset - lineToIndex[min] + 1\n    }\n  }\n\n  error(message, line, column, opts = {}) {\n    let result, endLine, endColumn\n\n    if (line && typeof line === 'object') {\n      let start = line\n      let end = column\n      if (typeof line.offset === 'number') {\n        let pos = this.fromOffset(start.offset)\n        line = pos.line\n        column = pos.col\n      } else {\n        line = start.line\n        column = start.column\n      }\n      if (typeof end.offset === 'number') {\n        let pos = this.fromOffset(end.offset)\n        endLine = pos.line\n        endColumn = pos.col\n      } else {\n        endLine = end.line\n        endColumn = end.column\n      }\n    } else if (!column) {\n      let pos = this.fromOffset(line)\n      line = pos.line\n      column = pos.col\n    }\n\n    let origin = this.origin(line, column, endLine, endColumn)\n    if (origin) {\n      result = new CssSyntaxError(\n        message,\n        origin.endLine === undefined\n          ? origin.line\n          : { line: origin.line, column: origin.column },\n        origin.endLine === undefined\n          ? origin.column\n          : { line: origin.endLine, column: origin.endColumn },\n        origin.source,\n        origin.file,\n        opts.plugin\n      )\n    } else {\n      result = new CssSyntaxError(\n        message,\n        endLine === undefined ? line : { line, column },\n        endLine === undefined ? column : { line: endLine, column: endColumn },\n        this.css,\n        this.file,\n        opts.plugin\n      )\n    }\n\n    result.input = { line, column, endLine, endColumn, source: this.css }\n    if (this.file) {\n      if (pathToFileURL) {\n        result.input.url = pathToFileURL(this.file).toString()\n      }\n      result.input.file = this.file\n    }\n\n    return result\n  }\n\n  origin(line, column, endLine, endColumn) {\n    if (!this.map) return false\n    let consumer = this.map.consumer()\n\n    let from = consumer.originalPositionFor({ line, column })\n    if (!from.source) return false\n\n    let to\n    if (typeof endLine === 'number') {\n      to = consumer.originalPositionFor({ line: endLine, column: endColumn })\n    }\n\n    let fromUrl\n\n    if (isAbsolute(from.source)) {\n      fromUrl = pathToFileURL(from.source)\n    } else {\n      fromUrl = new URL(\n        from.source,\n        this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile)\n      )\n    }\n\n    let result = {\n      url: fromUrl.toString(),\n      line: from.line,\n      column: from.column,\n      endLine: to && to.line,\n      endColumn: to && to.column\n    }\n\n    if (fromUrl.protocol === 'file:') {\n      if (fileURLToPath) {\n        result.file = fileURLToPath(fromUrl)\n      } else {\n        /* c8 ignore next 2 */\n        throw new Error(`file: protocol is not available in this PostCSS build`)\n      }\n    }\n\n    let source = consumer.sourceContentFor(from.source)\n    if (source) result.source = source\n\n    return result\n  }\n\n  mapResolve(file) {\n    if (/^\\w+:\\/\\//.test(file)) {\n      return file\n    }\n    return resolve(this.map.consumer().sourceRoot || this.map.root || '.', file)\n  }\n\n  get from() {\n    return this.file || this.id\n  }\n\n  toJSON() {\n    let json = {}\n    for (let name of ['hasBOM', 'css', 'file', 'id']) {\n      if (this[name] != null) {\n        json[name] = this[name]\n      }\n    }\n    if (this.map) {\n      json.map = { ...this.map }\n      if (json.map.consumerCache) {\n        json.map.consumerCache = undefined\n      }\n    }\n    return json\n  }\n}\n\nmodule.exports = Input\nInput.default = Input\n\nif (terminalHighlight && terminalHighlight.registerInput) {\n  terminalHighlight.registerInput(Input)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvaW5wdXQuanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosTUFBTSx3Q0FBd0MsRUFBRSxtQkFBTyxDQUFDLDRCQUFlO0FBQ3ZFLE1BQU0sK0JBQStCLEVBQUUsbUJBQU8sQ0FBQyxrQkFBSztBQUNwRCxNQUFNLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsbUJBQU07QUFDNUMsTUFBTSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxxRUFBbUI7O0FBRTVDLHdCQUF3QixtQkFBTyxDQUFDLG1DQUFzQjtBQUN0RCxxQkFBcUIsbUJBQU8sQ0FBQywwRUFBb0I7QUFDakQsa0JBQWtCLG1CQUFPLENBQUMsa0VBQWdCOztBQUUxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSztBQUMvQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBDQUEwQztBQUN4RDtBQUNBO0FBQ0EsY0FBYyxnREFBZ0Q7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHlDQUF5QyxjQUFjO0FBQ3ZELDJDQUEyQyxrQ0FBa0M7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsa0NBQWtDO0FBQzVFOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzL2xpYi9pbnB1dC5qcz8xODdkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5sZXQgeyBTb3VyY2VNYXBDb25zdW1lciwgU291cmNlTWFwR2VuZXJhdG9yIH0gPSByZXF1aXJlKCdzb3VyY2UtbWFwLWpzJylcbmxldCB7IGZpbGVVUkxUb1BhdGgsIHBhdGhUb0ZpbGVVUkwgfSA9IHJlcXVpcmUoJ3VybCcpXG5sZXQgeyByZXNvbHZlLCBpc0Fic29sdXRlIH0gPSByZXF1aXJlKCdwYXRoJylcbmxldCB7IG5hbm9pZCB9ID0gcmVxdWlyZSgnbmFub2lkL25vbi1zZWN1cmUnKVxuXG5sZXQgdGVybWluYWxIaWdobGlnaHQgPSByZXF1aXJlKCcuL3Rlcm1pbmFsLWhpZ2hsaWdodCcpXG5sZXQgQ3NzU3ludGF4RXJyb3IgPSByZXF1aXJlKCcuL2Nzcy1zeW50YXgtZXJyb3InKVxubGV0IFByZXZpb3VzTWFwID0gcmVxdWlyZSgnLi9wcmV2aW91cy1tYXAnKVxuXG5sZXQgZnJvbU9mZnNldENhY2hlID0gU3ltYm9sKCdmcm9tT2Zmc2V0Q2FjaGUnKVxuXG5sZXQgc291cmNlTWFwQXZhaWxhYmxlID0gQm9vbGVhbihTb3VyY2VNYXBDb25zdW1lciAmJiBTb3VyY2VNYXBHZW5lcmF0b3IpXG5sZXQgcGF0aEF2YWlsYWJsZSA9IEJvb2xlYW4ocmVzb2x2ZSAmJiBpc0Fic29sdXRlKVxuXG5jbGFzcyBJbnB1dCB7XG4gIGNvbnN0cnVjdG9yKGNzcywgb3B0cyA9IHt9KSB7XG4gICAgaWYgKFxuICAgICAgY3NzID09PSBudWxsIHx8XG4gICAgICB0eXBlb2YgY3NzID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgKHR5cGVvZiBjc3MgPT09ICdvYmplY3QnICYmICFjc3MudG9TdHJpbmcpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc3RDU1MgcmVjZWl2ZWQgJHtjc3N9IGluc3RlYWQgb2YgQ1NTIHN0cmluZ2ApXG4gICAgfVxuXG4gICAgdGhpcy5jc3MgPSBjc3MudG9TdHJpbmcoKVxuXG4gICAgaWYgKHRoaXMuY3NzWzBdID09PSAnXFx1RkVGRicgfHwgdGhpcy5jc3NbMF0gPT09ICdcXHVGRkZFJykge1xuICAgICAgdGhpcy5oYXNCT00gPSB0cnVlXG4gICAgICB0aGlzLmNzcyA9IHRoaXMuY3NzLnNsaWNlKDEpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFzQk9NID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAob3B0cy5mcm9tKSB7XG4gICAgICBpZiAoXG4gICAgICAgICFwYXRoQXZhaWxhYmxlIHx8XG4gICAgICAgIC9eXFx3KzpcXC9cXC8vLnRlc3Qob3B0cy5mcm9tKSB8fFxuICAgICAgICBpc0Fic29sdXRlKG9wdHMuZnJvbSlcbiAgICAgICkge1xuICAgICAgICB0aGlzLmZpbGUgPSBvcHRzLmZyb21cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmlsZSA9IHJlc29sdmUob3B0cy5mcm9tKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXRoQXZhaWxhYmxlICYmIHNvdXJjZU1hcEF2YWlsYWJsZSkge1xuICAgICAgbGV0IG1hcCA9IG5ldyBQcmV2aW91c01hcCh0aGlzLmNzcywgb3B0cylcbiAgICAgIGlmIChtYXAudGV4dCkge1xuICAgICAgICB0aGlzLm1hcCA9IG1hcFxuICAgICAgICBsZXQgZmlsZSA9IG1hcC5jb25zdW1lcigpLmZpbGVcbiAgICAgICAgaWYgKCF0aGlzLmZpbGUgJiYgZmlsZSkgdGhpcy5maWxlID0gdGhpcy5tYXBSZXNvbHZlKGZpbGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmZpbGUpIHtcbiAgICAgIHRoaXMuaWQgPSAnPGlucHV0IGNzcyAnICsgbmFub2lkKDYpICsgJz4nXG4gICAgfVxuICAgIGlmICh0aGlzLm1hcCkgdGhpcy5tYXAuZmlsZSA9IHRoaXMuZnJvbVxuICB9XG5cbiAgZnJvbU9mZnNldChvZmZzZXQpIHtcbiAgICBsZXQgbGFzdExpbmUsIGxpbmVUb0luZGV4XG4gICAgaWYgKCF0aGlzW2Zyb21PZmZzZXRDYWNoZV0pIHtcbiAgICAgIGxldCBsaW5lcyA9IHRoaXMuY3NzLnNwbGl0KCdcXG4nKVxuICAgICAgbGluZVRvSW5kZXggPSBuZXcgQXJyYXkobGluZXMubGVuZ3RoKVxuICAgICAgbGV0IHByZXZJbmRleCA9IDBcblxuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbGluZVRvSW5kZXhbaV0gPSBwcmV2SW5kZXhcbiAgICAgICAgcHJldkluZGV4ICs9IGxpbmVzW2ldLmxlbmd0aCArIDFcbiAgICAgIH1cblxuICAgICAgdGhpc1tmcm9tT2Zmc2V0Q2FjaGVdID0gbGluZVRvSW5kZXhcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZVRvSW5kZXggPSB0aGlzW2Zyb21PZmZzZXRDYWNoZV1cbiAgICB9XG4gICAgbGFzdExpbmUgPSBsaW5lVG9JbmRleFtsaW5lVG9JbmRleC5sZW5ndGggLSAxXVxuXG4gICAgbGV0IG1pbiA9IDBcbiAgICBpZiAob2Zmc2V0ID49IGxhc3RMaW5lKSB7XG4gICAgICBtaW4gPSBsaW5lVG9JbmRleC5sZW5ndGggLSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBtYXggPSBsaW5lVG9JbmRleC5sZW5ndGggLSAyXG4gICAgICBsZXQgbWlkXG4gICAgICB3aGlsZSAobWluIDwgbWF4KSB7XG4gICAgICAgIG1pZCA9IG1pbiArICgobWF4IC0gbWluKSA+PiAxKVxuICAgICAgICBpZiAob2Zmc2V0IDwgbGluZVRvSW5kZXhbbWlkXSkge1xuICAgICAgICAgIG1heCA9IG1pZCAtIDFcbiAgICAgICAgfSBlbHNlIGlmIChvZmZzZXQgPj0gbGluZVRvSW5kZXhbbWlkICsgMV0pIHtcbiAgICAgICAgICBtaW4gPSBtaWQgKyAxXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWluID0gbWlkXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbGluZTogbWluICsgMSxcbiAgICAgIGNvbDogb2Zmc2V0IC0gbGluZVRvSW5kZXhbbWluXSArIDFcbiAgICB9XG4gIH1cblxuICBlcnJvcihtZXNzYWdlLCBsaW5lLCBjb2x1bW4sIG9wdHMgPSB7fSkge1xuICAgIGxldCByZXN1bHQsIGVuZExpbmUsIGVuZENvbHVtblxuXG4gICAgaWYgKGxpbmUgJiYgdHlwZW9mIGxpbmUgPT09ICdvYmplY3QnKSB7XG4gICAgICBsZXQgc3RhcnQgPSBsaW5lXG4gICAgICBsZXQgZW5kID0gY29sdW1uXG4gICAgICBpZiAodHlwZW9mIGxpbmUub2Zmc2V0ID09PSAnbnVtYmVyJykge1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5mcm9tT2Zmc2V0KHN0YXJ0Lm9mZnNldClcbiAgICAgICAgbGluZSA9IHBvcy5saW5lXG4gICAgICAgIGNvbHVtbiA9IHBvcy5jb2xcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmUgPSBzdGFydC5saW5lXG4gICAgICAgIGNvbHVtbiA9IHN0YXJ0LmNvbHVtblxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlbmQub2Zmc2V0ID09PSAnbnVtYmVyJykge1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5mcm9tT2Zmc2V0KGVuZC5vZmZzZXQpXG4gICAgICAgIGVuZExpbmUgPSBwb3MubGluZVxuICAgICAgICBlbmRDb2x1bW4gPSBwb3MuY29sXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmRMaW5lID0gZW5kLmxpbmVcbiAgICAgICAgZW5kQ29sdW1uID0gZW5kLmNvbHVtblxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWNvbHVtbikge1xuICAgICAgbGV0IHBvcyA9IHRoaXMuZnJvbU9mZnNldChsaW5lKVxuICAgICAgbGluZSA9IHBvcy5saW5lXG4gICAgICBjb2x1bW4gPSBwb3MuY29sXG4gICAgfVxuXG4gICAgbGV0IG9yaWdpbiA9IHRoaXMub3JpZ2luKGxpbmUsIGNvbHVtbiwgZW5kTGluZSwgZW5kQ29sdW1uKVxuICAgIGlmIChvcmlnaW4pIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBDc3NTeW50YXhFcnJvcihcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgb3JpZ2luLmVuZExpbmUgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gb3JpZ2luLmxpbmVcbiAgICAgICAgICA6IHsgbGluZTogb3JpZ2luLmxpbmUsIGNvbHVtbjogb3JpZ2luLmNvbHVtbiB9LFxuICAgICAgICBvcmlnaW4uZW5kTGluZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyBvcmlnaW4uY29sdW1uXG4gICAgICAgICAgOiB7IGxpbmU6IG9yaWdpbi5lbmRMaW5lLCBjb2x1bW46IG9yaWdpbi5lbmRDb2x1bW4gfSxcbiAgICAgICAgb3JpZ2luLnNvdXJjZSxcbiAgICAgICAgb3JpZ2luLmZpbGUsXG4gICAgICAgIG9wdHMucGx1Z2luXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBDc3NTeW50YXhFcnJvcihcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgZW5kTGluZSA9PT0gdW5kZWZpbmVkID8gbGluZSA6IHsgbGluZSwgY29sdW1uIH0sXG4gICAgICAgIGVuZExpbmUgPT09IHVuZGVmaW5lZCA/IGNvbHVtbiA6IHsgbGluZTogZW5kTGluZSwgY29sdW1uOiBlbmRDb2x1bW4gfSxcbiAgICAgICAgdGhpcy5jc3MsXG4gICAgICAgIHRoaXMuZmlsZSxcbiAgICAgICAgb3B0cy5wbHVnaW5cbiAgICAgIClcbiAgICB9XG5cbiAgICByZXN1bHQuaW5wdXQgPSB7IGxpbmUsIGNvbHVtbiwgZW5kTGluZSwgZW5kQ29sdW1uLCBzb3VyY2U6IHRoaXMuY3NzIH1cbiAgICBpZiAodGhpcy5maWxlKSB7XG4gICAgICBpZiAocGF0aFRvRmlsZVVSTCkge1xuICAgICAgICByZXN1bHQuaW5wdXQudXJsID0gcGF0aFRvRmlsZVVSTCh0aGlzLmZpbGUpLnRvU3RyaW5nKClcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5pbnB1dC5maWxlID0gdGhpcy5maWxlXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgb3JpZ2luKGxpbmUsIGNvbHVtbiwgZW5kTGluZSwgZW5kQ29sdW1uKSB7XG4gICAgaWYgKCF0aGlzLm1hcCkgcmV0dXJuIGZhbHNlXG4gICAgbGV0IGNvbnN1bWVyID0gdGhpcy5tYXAuY29uc3VtZXIoKVxuXG4gICAgbGV0IGZyb20gPSBjb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHsgbGluZSwgY29sdW1uIH0pXG4gICAgaWYgKCFmcm9tLnNvdXJjZSkgcmV0dXJuIGZhbHNlXG5cbiAgICBsZXQgdG9cbiAgICBpZiAodHlwZW9mIGVuZExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICB0byA9IGNvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3IoeyBsaW5lOiBlbmRMaW5lLCBjb2x1bW46IGVuZENvbHVtbiB9KVxuICAgIH1cblxuICAgIGxldCBmcm9tVXJsXG5cbiAgICBpZiAoaXNBYnNvbHV0ZShmcm9tLnNvdXJjZSkpIHtcbiAgICAgIGZyb21VcmwgPSBwYXRoVG9GaWxlVVJMKGZyb20uc291cmNlKVxuICAgIH0gZWxzZSB7XG4gICAgICBmcm9tVXJsID0gbmV3IFVSTChcbiAgICAgICAgZnJvbS5zb3VyY2UsXG4gICAgICAgIHRoaXMubWFwLmNvbnN1bWVyKCkuc291cmNlUm9vdCB8fCBwYXRoVG9GaWxlVVJMKHRoaXMubWFwLm1hcEZpbGUpXG4gICAgICApXG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgIHVybDogZnJvbVVybC50b1N0cmluZygpLFxuICAgICAgbGluZTogZnJvbS5saW5lLFxuICAgICAgY29sdW1uOiBmcm9tLmNvbHVtbixcbiAgICAgIGVuZExpbmU6IHRvICYmIHRvLmxpbmUsXG4gICAgICBlbmRDb2x1bW46IHRvICYmIHRvLmNvbHVtblxuICAgIH1cblxuICAgIGlmIChmcm9tVXJsLnByb3RvY29sID09PSAnZmlsZTonKSB7XG4gICAgICBpZiAoZmlsZVVSTFRvUGF0aCkge1xuICAgICAgICByZXN1bHQuZmlsZSA9IGZpbGVVUkxUb1BhdGgoZnJvbVVybClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDIgKi9cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmaWxlOiBwcm90b2NvbCBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgUG9zdENTUyBidWlsZGApXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHNvdXJjZSA9IGNvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3IoZnJvbS5zb3VyY2UpXG4gICAgaWYgKHNvdXJjZSkgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgbWFwUmVzb2x2ZShmaWxlKSB7XG4gICAgaWYgKC9eXFx3KzpcXC9cXC8vLnRlc3QoZmlsZSkpIHtcbiAgICAgIHJldHVybiBmaWxlXG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlKHRoaXMubWFwLmNvbnN1bWVyKCkuc291cmNlUm9vdCB8fCB0aGlzLm1hcC5yb290IHx8ICcuJywgZmlsZSlcbiAgfVxuXG4gIGdldCBmcm9tKCkge1xuICAgIHJldHVybiB0aGlzLmZpbGUgfHwgdGhpcy5pZFxuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIGxldCBqc29uID0ge31cbiAgICBmb3IgKGxldCBuYW1lIG9mIFsnaGFzQk9NJywgJ2NzcycsICdmaWxlJywgJ2lkJ10pIHtcbiAgICAgIGlmICh0aGlzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAganNvbltuYW1lXSA9IHRoaXNbbmFtZV1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMubWFwKSB7XG4gICAgICBqc29uLm1hcCA9IHsgLi4udGhpcy5tYXAgfVxuICAgICAgaWYgKGpzb24ubWFwLmNvbnN1bWVyQ2FjaGUpIHtcbiAgICAgICAganNvbi5tYXAuY29uc3VtZXJDYWNoZSA9IHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ganNvblxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSW5wdXRcbklucHV0LmRlZmF1bHQgPSBJbnB1dFxuXG5pZiAodGVybWluYWxIaWdobGlnaHQgJiYgdGVybWluYWxIaWdobGlnaHQucmVnaXN0ZXJJbnB1dCkge1xuICB0ZXJtaW5hbEhpZ2hsaWdodC5yZWdpc3RlcklucHV0KElucHV0KVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/input.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/lazy-result.js":
/*!*************************************************!*\
  !*** ./node_modules/postcss/lib/lazy-result.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet { isClean, my } = __webpack_require__(/*! ./symbols */ \"./node_modules/postcss/lib/symbols.js\")\nlet MapGenerator = __webpack_require__(/*! ./map-generator */ \"./node_modules/postcss/lib/map-generator.js\")\nlet stringify = __webpack_require__(/*! ./stringify */ \"./node_modules/postcss/lib/stringify.js\")\nlet Container = __webpack_require__(/*! ./container */ \"./node_modules/postcss/lib/container.js\")\nlet Document = __webpack_require__(/*! ./document */ \"./node_modules/postcss/lib/document.js\")\nlet warnOnce = __webpack_require__(/*! ./warn-once */ \"./node_modules/postcss/lib/warn-once.js\")\nlet Result = __webpack_require__(/*! ./result */ \"./node_modules/postcss/lib/result.js\")\nlet parse = __webpack_require__(/*! ./parse */ \"./node_modules/postcss/lib/parse.js\")\nlet Root = __webpack_require__(/*! ./root */ \"./node_modules/postcss/lib/root.js\")\n\nconst TYPE_TO_CLASS_NAME = {\n  document: 'Document',\n  root: 'Root',\n  atrule: 'AtRule',\n  rule: 'Rule',\n  decl: 'Declaration',\n  comment: 'Comment'\n}\n\nconst PLUGIN_PROPS = {\n  postcssPlugin: true,\n  prepare: true,\n  Once: true,\n  Document: true,\n  Root: true,\n  Declaration: true,\n  Rule: true,\n  AtRule: true,\n  Comment: true,\n  DeclarationExit: true,\n  RuleExit: true,\n  AtRuleExit: true,\n  CommentExit: true,\n  RootExit: true,\n  DocumentExit: true,\n  OnceExit: true\n}\n\nconst NOT_VISITORS = {\n  postcssPlugin: true,\n  prepare: true,\n  Once: true\n}\n\nconst CHILDREN = 0\n\nfunction isPromise(obj) {\n  return typeof obj === 'object' && typeof obj.then === 'function'\n}\n\nfunction getEvents(node) {\n  let key = false\n  let type = TYPE_TO_CLASS_NAME[node.type]\n  if (node.type === 'decl') {\n    key = node.prop.toLowerCase()\n  } else if (node.type === 'atrule') {\n    key = node.name.toLowerCase()\n  }\n\n  if (key && node.append) {\n    return [\n      type,\n      type + '-' + key,\n      CHILDREN,\n      type + 'Exit',\n      type + 'Exit-' + key\n    ]\n  } else if (key) {\n    return [type, type + '-' + key, type + 'Exit', type + 'Exit-' + key]\n  } else if (node.append) {\n    return [type, CHILDREN, type + 'Exit']\n  } else {\n    return [type, type + 'Exit']\n  }\n}\n\nfunction toStack(node) {\n  let events\n  if (node.type === 'document') {\n    events = ['Document', CHILDREN, 'DocumentExit']\n  } else if (node.type === 'root') {\n    events = ['Root', CHILDREN, 'RootExit']\n  } else {\n    events = getEvents(node)\n  }\n\n  return {\n    node,\n    events,\n    eventIndex: 0,\n    visitors: [],\n    visitorIndex: 0,\n    iterator: 0\n  }\n}\n\nfunction cleanMarks(node) {\n  node[isClean] = false\n  if (node.nodes) node.nodes.forEach(i => cleanMarks(i))\n  return node\n}\n\nlet postcss = {}\n\nclass LazyResult {\n  constructor(processor, css, opts) {\n    this.stringified = false\n    this.processed = false\n\n    let root\n    if (\n      typeof css === 'object' &&\n      css !== null &&\n      (css.type === 'root' || css.type === 'document')\n    ) {\n      root = cleanMarks(css)\n    } else if (css instanceof LazyResult || css instanceof Result) {\n      root = cleanMarks(css.root)\n      if (css.map) {\n        if (typeof opts.map === 'undefined') opts.map = {}\n        if (!opts.map.inline) opts.map.inline = false\n        opts.map.prev = css.map\n      }\n    } else {\n      let parser = parse\n      if (opts.syntax) parser = opts.syntax.parse\n      if (opts.parser) parser = opts.parser\n      if (parser.parse) parser = parser.parse\n\n      try {\n        root = parser(css, opts)\n      } catch (error) {\n        this.processed = true\n        this.error = error\n      }\n\n      if (root && !root[my]) {\n        /* c8 ignore next 2 */\n        Container.rebuild(root)\n      }\n    }\n\n    this.result = new Result(processor, root, opts)\n    this.helpers = { ...postcss, result: this.result, postcss }\n    this.plugins = this.processor.plugins.map(plugin => {\n      if (typeof plugin === 'object' && plugin.prepare) {\n        return { ...plugin, ...plugin.prepare(this.result) }\n      } else {\n        return plugin\n      }\n    })\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'LazyResult'\n  }\n\n  get processor() {\n    return this.result.processor\n  }\n\n  get opts() {\n    return this.result.opts\n  }\n\n  get css() {\n    return this.stringify().css\n  }\n\n  get content() {\n    return this.stringify().content\n  }\n\n  get map() {\n    return this.stringify().map\n  }\n\n  get root() {\n    return this.sync().root\n  }\n\n  get messages() {\n    return this.sync().messages\n  }\n\n  warnings() {\n    return this.sync().warnings()\n  }\n\n  toString() {\n    return this.css\n  }\n\n  then(onFulfilled, onRejected) {\n    if (true) {\n      if (!('from' in this.opts)) {\n        warnOnce(\n          'Without `from` option PostCSS could generate wrong source map ' +\n            'and will not find Browserslist config. Set it to CSS file path ' +\n            'or to `undefined` to prevent this warning.'\n        )\n      }\n    }\n    return this.async().then(onFulfilled, onRejected)\n  }\n\n  catch(onRejected) {\n    return this.async().catch(onRejected)\n  }\n\n  finally(onFinally) {\n    return this.async().then(onFinally, onFinally)\n  }\n\n  async() {\n    if (this.error) return Promise.reject(this.error)\n    if (this.processed) return Promise.resolve(this.result)\n    if (!this.processing) {\n      this.processing = this.runAsync()\n    }\n    return this.processing\n  }\n\n  sync() {\n    if (this.error) throw this.error\n    if (this.processed) return this.result\n    this.processed = true\n\n    if (this.processing) {\n      throw this.getAsyncError()\n    }\n\n    for (let plugin of this.plugins) {\n      let promise = this.runOnRoot(plugin)\n      if (isPromise(promise)) {\n        throw this.getAsyncError()\n      }\n    }\n\n    this.prepareVisitors()\n    if (this.hasListener) {\n      let root = this.result.root\n      while (!root[isClean]) {\n        root[isClean] = true\n        this.walkSync(root)\n      }\n      if (this.listeners.OnceExit) {\n        if (root.type === 'document') {\n          for (let subRoot of root.nodes) {\n            this.visitSync(this.listeners.OnceExit, subRoot)\n          }\n        } else {\n          this.visitSync(this.listeners.OnceExit, root)\n        }\n      }\n    }\n\n    return this.result\n  }\n\n  stringify() {\n    if (this.error) throw this.error\n    if (this.stringified) return this.result\n    this.stringified = true\n\n    this.sync()\n\n    let opts = this.result.opts\n    let str = stringify\n    if (opts.syntax) str = opts.syntax.stringify\n    if (opts.stringifier) str = opts.stringifier\n    if (str.stringify) str = str.stringify\n\n    let map = new MapGenerator(str, this.result.root, this.result.opts)\n    let data = map.generate()\n    this.result.css = data[0]\n    this.result.map = data[1]\n\n    return this.result\n  }\n\n  walkSync(node) {\n    node[isClean] = true\n    let events = getEvents(node)\n    for (let event of events) {\n      if (event === CHILDREN) {\n        if (node.nodes) {\n          node.each(child => {\n            if (!child[isClean]) this.walkSync(child)\n          })\n        }\n      } else {\n        let visitors = this.listeners[event]\n        if (visitors) {\n          if (this.visitSync(visitors, node.toProxy())) return\n        }\n      }\n    }\n  }\n\n  visitSync(visitors, node) {\n    for (let [plugin, visitor] of visitors) {\n      this.result.lastPlugin = plugin\n      let promise\n      try {\n        promise = visitor(node, this.helpers)\n      } catch (e) {\n        throw this.handleError(e, node.proxyOf)\n      }\n      if (node.type !== 'root' && node.type !== 'document' && !node.parent) {\n        return true\n      }\n      if (isPromise(promise)) {\n        throw this.getAsyncError()\n      }\n    }\n  }\n\n  runOnRoot(plugin) {\n    this.result.lastPlugin = plugin\n    try {\n      if (typeof plugin === 'object' && plugin.Once) {\n        if (this.result.root.type === 'document') {\n          let roots = this.result.root.nodes.map(root =>\n            plugin.Once(root, this.helpers)\n          )\n\n          if (isPromise(roots[0])) {\n            return Promise.all(roots)\n          }\n\n          return roots\n        }\n\n        return plugin.Once(this.result.root, this.helpers)\n      } else if (typeof plugin === 'function') {\n        return plugin(this.result.root, this.result)\n      }\n    } catch (error) {\n      throw this.handleError(error)\n    }\n  }\n\n  getAsyncError() {\n    throw new Error('Use process(css).then(cb) to work with async plugins')\n  }\n\n  handleError(error, node) {\n    let plugin = this.result.lastPlugin\n    try {\n      if (node) node.addToError(error)\n      this.error = error\n      if (error.name === 'CssSyntaxError' && !error.plugin) {\n        error.plugin = plugin.postcssPlugin\n        error.setMessage()\n      } else if (plugin.postcssVersion) {\n        if (true) {\n          let pluginName = plugin.postcssPlugin\n          let pluginVer = plugin.postcssVersion\n          let runtimeVer = this.result.processor.version\n          let a = pluginVer.split('.')\n          let b = runtimeVer.split('.')\n\n          if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {\n            // eslint-disable-next-line no-console\n            console.error(\n              'Unknown error from PostCSS plugin. Your current PostCSS ' +\n                'version is ' +\n                runtimeVer +\n                ', but ' +\n                pluginName +\n                ' uses ' +\n                pluginVer +\n                '. Perhaps this is the source of the error below.'\n            )\n          }\n        }\n      }\n    } catch (err) {\n      /* c8 ignore next 3 */\n      // eslint-disable-next-line no-console\n      if (console && console.error) console.error(err)\n    }\n    return error\n  }\n\n  async runAsync() {\n    this.plugin = 0\n    for (let i = 0; i < this.plugins.length; i++) {\n      let plugin = this.plugins[i]\n      let promise = this.runOnRoot(plugin)\n      if (isPromise(promise)) {\n        try {\n          await promise\n        } catch (error) {\n          throw this.handleError(error)\n        }\n      }\n    }\n\n    this.prepareVisitors()\n    if (this.hasListener) {\n      let root = this.result.root\n      while (!root[isClean]) {\n        root[isClean] = true\n        let stack = [toStack(root)]\n        while (stack.length > 0) {\n          let promise = this.visitTick(stack)\n          if (isPromise(promise)) {\n            try {\n              await promise\n            } catch (e) {\n              let node = stack[stack.length - 1].node\n              throw this.handleError(e, node)\n            }\n          }\n        }\n      }\n\n      if (this.listeners.OnceExit) {\n        for (let [plugin, visitor] of this.listeners.OnceExit) {\n          this.result.lastPlugin = plugin\n          try {\n            if (root.type === 'document') {\n              let roots = root.nodes.map(subRoot =>\n                visitor(subRoot, this.helpers)\n              )\n\n              await Promise.all(roots)\n            } else {\n              await visitor(root, this.helpers)\n            }\n          } catch (e) {\n            throw this.handleError(e)\n          }\n        }\n      }\n    }\n\n    this.processed = true\n    return this.stringify()\n  }\n\n  prepareVisitors() {\n    this.listeners = {}\n    let add = (plugin, type, cb) => {\n      if (!this.listeners[type]) this.listeners[type] = []\n      this.listeners[type].push([plugin, cb])\n    }\n    for (let plugin of this.plugins) {\n      if (typeof plugin === 'object') {\n        for (let event in plugin) {\n          if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {\n            throw new Error(\n              `Unknown event ${event} in ${plugin.postcssPlugin}. ` +\n                `Try to update PostCSS (${this.processor.version} now).`\n            )\n          }\n          if (!NOT_VISITORS[event]) {\n            if (typeof plugin[event] === 'object') {\n              for (let filter in plugin[event]) {\n                if (filter === '*') {\n                  add(plugin, event, plugin[event][filter])\n                } else {\n                  add(\n                    plugin,\n                    event + '-' + filter.toLowerCase(),\n                    plugin[event][filter]\n                  )\n                }\n              }\n            } else if (typeof plugin[event] === 'function') {\n              add(plugin, event, plugin[event])\n            }\n          }\n        }\n      }\n    }\n    this.hasListener = Object.keys(this.listeners).length > 0\n  }\n\n  visitTick(stack) {\n    let visit = stack[stack.length - 1]\n    let { node, visitors } = visit\n\n    if (node.type !== 'root' && node.type !== 'document' && !node.parent) {\n      stack.pop()\n      return\n    }\n\n    if (visitors.length > 0 && visit.visitorIndex < visitors.length) {\n      let [plugin, visitor] = visitors[visit.visitorIndex]\n      visit.visitorIndex += 1\n      if (visit.visitorIndex === visitors.length) {\n        visit.visitors = []\n        visit.visitorIndex = 0\n      }\n      this.result.lastPlugin = plugin\n      try {\n        return visitor(node.toProxy(), this.helpers)\n      } catch (e) {\n        throw this.handleError(e, node)\n      }\n    }\n\n    if (visit.iterator !== 0) {\n      let iterator = visit.iterator\n      let child\n      while ((child = node.nodes[node.indexes[iterator]])) {\n        node.indexes[iterator] += 1\n        if (!child[isClean]) {\n          child[isClean] = true\n          stack.push(toStack(child))\n          return\n        }\n      }\n      visit.iterator = 0\n      delete node.indexes[iterator]\n    }\n\n    let events = visit.events\n    while (visit.eventIndex < events.length) {\n      let event = events[visit.eventIndex]\n      visit.eventIndex += 1\n      if (event === CHILDREN) {\n        if (node.nodes && node.nodes.length) {\n          node[isClean] = true\n          visit.iterator = node.getIterator()\n        }\n        return\n      } else if (this.listeners[event]) {\n        visit.visitors = this.listeners[event]\n        return\n      }\n    }\n    stack.pop()\n  }\n}\n\nLazyResult.registerPostcss = dependant => {\n  postcss = dependant\n}\n\nmodule.exports = LazyResult\nLazyResult.default = LazyResult\n\nRoot.registerLazyResult(LazyResult)\nDocument.registerLazyResult(LazyResult)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvbGF6eS1yZXN1bHQuanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosTUFBTSxjQUFjLEVBQUUsbUJBQU8sQ0FBQyx3REFBVztBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyxvRUFBaUI7QUFDNUMsZ0JBQWdCLG1CQUFPLENBQUMsNERBQWE7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMsNERBQWE7QUFDckMsZUFBZSxtQkFBTyxDQUFDLDBEQUFZO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQyw0REFBYTtBQUNwQyxhQUFhLG1CQUFPLENBQUMsc0RBQVU7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLG9EQUFTO0FBQzdCLFdBQVcsbUJBQU8sQ0FBQyxrREFBUTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLFlBQVksSUFBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTyxLQUFLLHFCQUFxQjtBQUNoRSwwQ0FBMEMsd0JBQXdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsaUJBQWlCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL2xhenktcmVzdWx0LmpzP2U0YzEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmxldCB7IGlzQ2xlYW4sIG15IH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxubGV0IE1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vbWFwLWdlbmVyYXRvcicpXG5sZXQgc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnknKVxubGV0IENvbnRhaW5lciA9IHJlcXVpcmUoJy4vY29udGFpbmVyJylcbmxldCBEb2N1bWVudCA9IHJlcXVpcmUoJy4vZG9jdW1lbnQnKVxubGV0IHdhcm5PbmNlID0gcmVxdWlyZSgnLi93YXJuLW9uY2UnKVxubGV0IFJlc3VsdCA9IHJlcXVpcmUoJy4vcmVzdWx0JylcbmxldCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxubGV0IFJvb3QgPSByZXF1aXJlKCcuL3Jvb3QnKVxuXG5jb25zdCBUWVBFX1RPX0NMQVNTX05BTUUgPSB7XG4gIGRvY3VtZW50OiAnRG9jdW1lbnQnLFxuICByb290OiAnUm9vdCcsXG4gIGF0cnVsZTogJ0F0UnVsZScsXG4gIHJ1bGU6ICdSdWxlJyxcbiAgZGVjbDogJ0RlY2xhcmF0aW9uJyxcbiAgY29tbWVudDogJ0NvbW1lbnQnXG59XG5cbmNvbnN0IFBMVUdJTl9QUk9QUyA9IHtcbiAgcG9zdGNzc1BsdWdpbjogdHJ1ZSxcbiAgcHJlcGFyZTogdHJ1ZSxcbiAgT25jZTogdHJ1ZSxcbiAgRG9jdW1lbnQ6IHRydWUsXG4gIFJvb3Q6IHRydWUsXG4gIERlY2xhcmF0aW9uOiB0cnVlLFxuICBSdWxlOiB0cnVlLFxuICBBdFJ1bGU6IHRydWUsXG4gIENvbW1lbnQ6IHRydWUsXG4gIERlY2xhcmF0aW9uRXhpdDogdHJ1ZSxcbiAgUnVsZUV4aXQ6IHRydWUsXG4gIEF0UnVsZUV4aXQ6IHRydWUsXG4gIENvbW1lbnRFeGl0OiB0cnVlLFxuICBSb290RXhpdDogdHJ1ZSxcbiAgRG9jdW1lbnRFeGl0OiB0cnVlLFxuICBPbmNlRXhpdDogdHJ1ZVxufVxuXG5jb25zdCBOT1RfVklTSVRPUlMgPSB7XG4gIHBvc3Rjc3NQbHVnaW46IHRydWUsXG4gIHByZXBhcmU6IHRydWUsXG4gIE9uY2U6IHRydWVcbn1cblxuY29uc3QgQ0hJTERSRU4gPSAwXG5cbmZ1bmN0aW9uIGlzUHJvbWlzZShvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG5mdW5jdGlvbiBnZXRFdmVudHMobm9kZSkge1xuICBsZXQga2V5ID0gZmFsc2VcbiAgbGV0IHR5cGUgPSBUWVBFX1RPX0NMQVNTX05BTUVbbm9kZS50eXBlXVxuICBpZiAobm9kZS50eXBlID09PSAnZGVjbCcpIHtcbiAgICBrZXkgPSBub2RlLnByb3AudG9Mb3dlckNhc2UoKVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ2F0cnVsZScpIHtcbiAgICBrZXkgPSBub2RlLm5hbWUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgaWYgKGtleSAmJiBub2RlLmFwcGVuZCkge1xuICAgIHJldHVybiBbXG4gICAgICB0eXBlLFxuICAgICAgdHlwZSArICctJyArIGtleSxcbiAgICAgIENISUxEUkVOLFxuICAgICAgdHlwZSArICdFeGl0JyxcbiAgICAgIHR5cGUgKyAnRXhpdC0nICsga2V5XG4gICAgXVxuICB9IGVsc2UgaWYgKGtleSkge1xuICAgIHJldHVybiBbdHlwZSwgdHlwZSArICctJyArIGtleSwgdHlwZSArICdFeGl0JywgdHlwZSArICdFeGl0LScgKyBrZXldXG4gIH0gZWxzZSBpZiAobm9kZS5hcHBlbmQpIHtcbiAgICByZXR1cm4gW3R5cGUsIENISUxEUkVOLCB0eXBlICsgJ0V4aXQnXVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBbdHlwZSwgdHlwZSArICdFeGl0J11cbiAgfVxufVxuXG5mdW5jdGlvbiB0b1N0YWNrKG5vZGUpIHtcbiAgbGV0IGV2ZW50c1xuICBpZiAobm9kZS50eXBlID09PSAnZG9jdW1lbnQnKSB7XG4gICAgZXZlbnRzID0gWydEb2N1bWVudCcsIENISUxEUkVOLCAnRG9jdW1lbnRFeGl0J11cbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdyb290Jykge1xuICAgIGV2ZW50cyA9IFsnUm9vdCcsIENISUxEUkVOLCAnUm9vdEV4aXQnXVxuICB9IGVsc2Uge1xuICAgIGV2ZW50cyA9IGdldEV2ZW50cyhub2RlKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBub2RlLFxuICAgIGV2ZW50cyxcbiAgICBldmVudEluZGV4OiAwLFxuICAgIHZpc2l0b3JzOiBbXSxcbiAgICB2aXNpdG9ySW5kZXg6IDAsXG4gICAgaXRlcmF0b3I6IDBcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhbk1hcmtzKG5vZGUpIHtcbiAgbm9kZVtpc0NsZWFuXSA9IGZhbHNlXG4gIGlmIChub2RlLm5vZGVzKSBub2RlLm5vZGVzLmZvckVhY2goaSA9PiBjbGVhbk1hcmtzKGkpKVxuICByZXR1cm4gbm9kZVxufVxuXG5sZXQgcG9zdGNzcyA9IHt9XG5cbmNsYXNzIExhenlSZXN1bHQge1xuICBjb25zdHJ1Y3Rvcihwcm9jZXNzb3IsIGNzcywgb3B0cykge1xuICAgIHRoaXMuc3RyaW5naWZpZWQgPSBmYWxzZVxuICAgIHRoaXMucHJvY2Vzc2VkID0gZmFsc2VcblxuICAgIGxldCByb290XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIGNzcyA9PT0gJ29iamVjdCcgJiZcbiAgICAgIGNzcyAhPT0gbnVsbCAmJlxuICAgICAgKGNzcy50eXBlID09PSAncm9vdCcgfHwgY3NzLnR5cGUgPT09ICdkb2N1bWVudCcpXG4gICAgKSB7XG4gICAgICByb290ID0gY2xlYW5NYXJrcyhjc3MpXG4gICAgfSBlbHNlIGlmIChjc3MgaW5zdGFuY2VvZiBMYXp5UmVzdWx0IHx8IGNzcyBpbnN0YW5jZW9mIFJlc3VsdCkge1xuICAgICAgcm9vdCA9IGNsZWFuTWFya3MoY3NzLnJvb3QpXG4gICAgICBpZiAoY3NzLm1hcCkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdHMubWFwID09PSAndW5kZWZpbmVkJykgb3B0cy5tYXAgPSB7fVxuICAgICAgICBpZiAoIW9wdHMubWFwLmlubGluZSkgb3B0cy5tYXAuaW5saW5lID0gZmFsc2VcbiAgICAgICAgb3B0cy5tYXAucHJldiA9IGNzcy5tYXBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBhcnNlciA9IHBhcnNlXG4gICAgICBpZiAob3B0cy5zeW50YXgpIHBhcnNlciA9IG9wdHMuc3ludGF4LnBhcnNlXG4gICAgICBpZiAob3B0cy5wYXJzZXIpIHBhcnNlciA9IG9wdHMucGFyc2VyXG4gICAgICBpZiAocGFyc2VyLnBhcnNlKSBwYXJzZXIgPSBwYXJzZXIucGFyc2VcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcm9vdCA9IHBhcnNlcihjc3MsIG9wdHMpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLnByb2Nlc3NlZCA9IHRydWVcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yXG4gICAgICB9XG5cbiAgICAgIGlmIChyb290ICYmICFyb290W215XSkge1xuICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAyICovXG4gICAgICAgIENvbnRhaW5lci5yZWJ1aWxkKHJvb3QpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yZXN1bHQgPSBuZXcgUmVzdWx0KHByb2Nlc3Nvciwgcm9vdCwgb3B0cylcbiAgICB0aGlzLmhlbHBlcnMgPSB7IC4uLnBvc3Rjc3MsIHJlc3VsdDogdGhpcy5yZXN1bHQsIHBvc3Rjc3MgfVxuICAgIHRoaXMucGx1Z2lucyA9IHRoaXMucHJvY2Vzc29yLnBsdWdpbnMubWFwKHBsdWdpbiA9PiB7XG4gICAgICBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ29iamVjdCcgJiYgcGx1Z2luLnByZXBhcmUpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4ucGx1Z2luLCAuLi5wbHVnaW4ucHJlcGFyZSh0aGlzLnJlc3VsdCkgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBsdWdpblxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuICdMYXp5UmVzdWx0J1xuICB9XG5cbiAgZ2V0IHByb2Nlc3NvcigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQucHJvY2Vzc29yXG4gIH1cblxuICBnZXQgb3B0cygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQub3B0c1xuICB9XG5cbiAgZ2V0IGNzcygpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnkoKS5jc3NcbiAgfVxuXG4gIGdldCBjb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLnN0cmluZ2lmeSgpLmNvbnRlbnRcbiAgfVxuXG4gIGdldCBtYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KCkubWFwXG4gIH1cblxuICBnZXQgcm9vdCgpIHtcbiAgICByZXR1cm4gdGhpcy5zeW5jKCkucm9vdFxuICB9XG5cbiAgZ2V0IG1lc3NhZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLnN5bmMoKS5tZXNzYWdlc1xuICB9XG5cbiAgd2FybmluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3luYygpLndhcm5pbmdzKClcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmNzc1xuICB9XG5cbiAgdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoISgnZnJvbScgaW4gdGhpcy5vcHRzKSkge1xuICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAnV2l0aG91dCBgZnJvbWAgb3B0aW9uIFBvc3RDU1MgY291bGQgZ2VuZXJhdGUgd3Jvbmcgc291cmNlIG1hcCAnICtcbiAgICAgICAgICAgICdhbmQgd2lsbCBub3QgZmluZCBCcm93c2Vyc2xpc3QgY29uZmlnLiBTZXQgaXQgdG8gQ1NTIGZpbGUgcGF0aCAnICtcbiAgICAgICAgICAgICdvciB0byBgdW5kZWZpbmVkYCB0byBwcmV2ZW50IHRoaXMgd2FybmluZy4nXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICB9XG5cbiAgY2F0Y2gob25SZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLmFzeW5jKCkuY2F0Y2gob25SZWplY3RlZClcbiAgfVxuXG4gIGZpbmFsbHkob25GaW5hbGx5KSB7XG4gICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRmluYWxseSwgb25GaW5hbGx5KVxuICB9XG5cbiAgYXN5bmMoKSB7XG4gICAgaWYgKHRoaXMuZXJyb3IpIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmVycm9yKVxuICAgIGlmICh0aGlzLnByb2Nlc3NlZCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnJlc3VsdClcbiAgICBpZiAoIXRoaXMucHJvY2Vzc2luZykge1xuICAgICAgdGhpcy5wcm9jZXNzaW5nID0gdGhpcy5ydW5Bc3luYygpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByb2Nlc3NpbmdcbiAgfVxuXG4gIHN5bmMoKSB7XG4gICAgaWYgKHRoaXMuZXJyb3IpIHRocm93IHRoaXMuZXJyb3JcbiAgICBpZiAodGhpcy5wcm9jZXNzZWQpIHJldHVybiB0aGlzLnJlc3VsdFxuICAgIHRoaXMucHJvY2Vzc2VkID0gdHJ1ZVxuXG4gICAgaWYgKHRoaXMucHJvY2Vzc2luZykge1xuICAgICAgdGhyb3cgdGhpcy5nZXRBc3luY0Vycm9yKClcbiAgICB9XG5cbiAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKSB7XG4gICAgICBsZXQgcHJvbWlzZSA9IHRoaXMucnVuT25Sb290KHBsdWdpbilcbiAgICAgIGlmIChpc1Byb21pc2UocHJvbWlzZSkpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5nZXRBc3luY0Vycm9yKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnByZXBhcmVWaXNpdG9ycygpXG4gICAgaWYgKHRoaXMuaGFzTGlzdGVuZXIpIHtcbiAgICAgIGxldCByb290ID0gdGhpcy5yZXN1bHQucm9vdFxuICAgICAgd2hpbGUgKCFyb290W2lzQ2xlYW5dKSB7XG4gICAgICAgIHJvb3RbaXNDbGVhbl0gPSB0cnVlXG4gICAgICAgIHRoaXMud2Fsa1N5bmMocm9vdClcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxpc3RlbmVycy5PbmNlRXhpdCkge1xuICAgICAgICBpZiAocm9vdC50eXBlID09PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgICAgZm9yIChsZXQgc3ViUm9vdCBvZiByb290Lm5vZGVzKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0U3luYyh0aGlzLmxpc3RlbmVycy5PbmNlRXhpdCwgc3ViUm9vdClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy52aXNpdFN5bmModGhpcy5saXN0ZW5lcnMuT25jZUV4aXQsIHJvb3QpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZXN1bHRcbiAgfVxuXG4gIHN0cmluZ2lmeSgpIHtcbiAgICBpZiAodGhpcy5lcnJvcikgdGhyb3cgdGhpcy5lcnJvclxuICAgIGlmICh0aGlzLnN0cmluZ2lmaWVkKSByZXR1cm4gdGhpcy5yZXN1bHRcbiAgICB0aGlzLnN0cmluZ2lmaWVkID0gdHJ1ZVxuXG4gICAgdGhpcy5zeW5jKClcblxuICAgIGxldCBvcHRzID0gdGhpcy5yZXN1bHQub3B0c1xuICAgIGxldCBzdHIgPSBzdHJpbmdpZnlcbiAgICBpZiAob3B0cy5zeW50YXgpIHN0ciA9IG9wdHMuc3ludGF4LnN0cmluZ2lmeVxuICAgIGlmIChvcHRzLnN0cmluZ2lmaWVyKSBzdHIgPSBvcHRzLnN0cmluZ2lmaWVyXG4gICAgaWYgKHN0ci5zdHJpbmdpZnkpIHN0ciA9IHN0ci5zdHJpbmdpZnlcblxuICAgIGxldCBtYXAgPSBuZXcgTWFwR2VuZXJhdG9yKHN0ciwgdGhpcy5yZXN1bHQucm9vdCwgdGhpcy5yZXN1bHQub3B0cylcbiAgICBsZXQgZGF0YSA9IG1hcC5nZW5lcmF0ZSgpXG4gICAgdGhpcy5yZXN1bHQuY3NzID0gZGF0YVswXVxuICAgIHRoaXMucmVzdWx0Lm1hcCA9IGRhdGFbMV1cblxuICAgIHJldHVybiB0aGlzLnJlc3VsdFxuICB9XG5cbiAgd2Fsa1N5bmMobm9kZSkge1xuICAgIG5vZGVbaXNDbGVhbl0gPSB0cnVlXG4gICAgbGV0IGV2ZW50cyA9IGdldEV2ZW50cyhub2RlKVxuICAgIGZvciAobGV0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgaWYgKGV2ZW50ID09PSBDSElMRFJFTikge1xuICAgICAgICBpZiAobm9kZS5ub2Rlcykge1xuICAgICAgICAgIG5vZGUuZWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICBpZiAoIWNoaWxkW2lzQ2xlYW5dKSB0aGlzLndhbGtTeW5jKGNoaWxkKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB2aXNpdG9ycyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50XVxuICAgICAgICBpZiAodmlzaXRvcnMpIHtcbiAgICAgICAgICBpZiAodGhpcy52aXNpdFN5bmModmlzaXRvcnMsIG5vZGUudG9Qcm94eSgpKSkgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2aXNpdFN5bmModmlzaXRvcnMsIG5vZGUpIHtcbiAgICBmb3IgKGxldCBbcGx1Z2luLCB2aXNpdG9yXSBvZiB2aXNpdG9ycykge1xuICAgICAgdGhpcy5yZXN1bHQubGFzdFBsdWdpbiA9IHBsdWdpblxuICAgICAgbGV0IHByb21pc2VcbiAgICAgIHRyeSB7XG4gICAgICAgIHByb21pc2UgPSB2aXNpdG9yKG5vZGUsIHRoaXMuaGVscGVycylcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5oYW5kbGVFcnJvcihlLCBub2RlLnByb3h5T2YpXG4gICAgICB9XG4gICAgICBpZiAobm9kZS50eXBlICE9PSAncm9vdCcgJiYgbm9kZS50eXBlICE9PSAnZG9jdW1lbnQnICYmICFub2RlLnBhcmVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKGlzUHJvbWlzZShwcm9taXNlKSkge1xuICAgICAgICB0aHJvdyB0aGlzLmdldEFzeW5jRXJyb3IoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJ1bk9uUm9vdChwbHVnaW4pIHtcbiAgICB0aGlzLnJlc3VsdC5sYXN0UGx1Z2luID0gcGx1Z2luXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgcGx1Z2luID09PSAnb2JqZWN0JyAmJiBwbHVnaW4uT25jZSkge1xuICAgICAgICBpZiAodGhpcy5yZXN1bHQucm9vdC50eXBlID09PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgICAgbGV0IHJvb3RzID0gdGhpcy5yZXN1bHQucm9vdC5ub2Rlcy5tYXAocm9vdCA9PlxuICAgICAgICAgICAgcGx1Z2luLk9uY2Uocm9vdCwgdGhpcy5oZWxwZXJzKVxuICAgICAgICAgIClcblxuICAgICAgICAgIGlmIChpc1Byb21pc2Uocm9vdHNbMF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocm9vdHMpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJvb3RzXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGx1Z2luLk9uY2UodGhpcy5yZXN1bHQucm9vdCwgdGhpcy5oZWxwZXJzKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBwbHVnaW4odGhpcy5yZXN1bHQucm9vdCwgdGhpcy5yZXN1bHQpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgZ2V0QXN5bmNFcnJvcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZSBwcm9jZXNzKGNzcykudGhlbihjYikgdG8gd29yayB3aXRoIGFzeW5jIHBsdWdpbnMnKVxuICB9XG5cbiAgaGFuZGxlRXJyb3IoZXJyb3IsIG5vZGUpIHtcbiAgICBsZXQgcGx1Z2luID0gdGhpcy5yZXN1bHQubGFzdFBsdWdpblxuICAgIHRyeSB7XG4gICAgICBpZiAobm9kZSkgbm9kZS5hZGRUb0Vycm9yKGVycm9yKVxuICAgICAgdGhpcy5lcnJvciA9IGVycm9yXG4gICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Nzc1N5bnRheEVycm9yJyAmJiAhZXJyb3IucGx1Z2luKSB7XG4gICAgICAgIGVycm9yLnBsdWdpbiA9IHBsdWdpbi5wb3N0Y3NzUGx1Z2luXG4gICAgICAgIGVycm9yLnNldE1lc3NhZ2UoKVxuICAgICAgfSBlbHNlIGlmIChwbHVnaW4ucG9zdGNzc1ZlcnNpb24pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBsZXQgcGx1Z2luTmFtZSA9IHBsdWdpbi5wb3N0Y3NzUGx1Z2luXG4gICAgICAgICAgbGV0IHBsdWdpblZlciA9IHBsdWdpbi5wb3N0Y3NzVmVyc2lvblxuICAgICAgICAgIGxldCBydW50aW1lVmVyID0gdGhpcy5yZXN1bHQucHJvY2Vzc29yLnZlcnNpb25cbiAgICAgICAgICBsZXQgYSA9IHBsdWdpblZlci5zcGxpdCgnLicpXG4gICAgICAgICAgbGV0IGIgPSBydW50aW1lVmVyLnNwbGl0KCcuJylcblxuICAgICAgICAgIGlmIChhWzBdICE9PSBiWzBdIHx8IHBhcnNlSW50KGFbMV0pID4gcGFyc2VJbnQoYlsxXSkpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnVW5rbm93biBlcnJvciBmcm9tIFBvc3RDU1MgcGx1Z2luLiBZb3VyIGN1cnJlbnQgUG9zdENTUyAnICtcbiAgICAgICAgICAgICAgICAndmVyc2lvbiBpcyAnICtcbiAgICAgICAgICAgICAgICBydW50aW1lVmVyICtcbiAgICAgICAgICAgICAgICAnLCBidXQgJyArXG4gICAgICAgICAgICAgICAgcGx1Z2luTmFtZSArXG4gICAgICAgICAgICAgICAgJyB1c2VzICcgK1xuICAgICAgICAgICAgICAgIHBsdWdpblZlciArXG4gICAgICAgICAgICAgICAgJy4gUGVyaGFwcyB0aGlzIGlzIHRoZSBzb3VyY2Ugb2YgdGhlIGVycm9yIGJlbG93LidcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSBjb25zb2xlLmVycm9yKGVycilcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yXG4gIH1cblxuICBhc3luYyBydW5Bc3luYygpIHtcbiAgICB0aGlzLnBsdWdpbiA9IDBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHBsdWdpbiA9IHRoaXMucGx1Z2luc1tpXVxuICAgICAgbGV0IHByb21pc2UgPSB0aGlzLnJ1bk9uUm9vdChwbHVnaW4pXG4gICAgICBpZiAoaXNQcm9taXNlKHByb21pc2UpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgcHJvbWlzZVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnByZXBhcmVWaXNpdG9ycygpXG4gICAgaWYgKHRoaXMuaGFzTGlzdGVuZXIpIHtcbiAgICAgIGxldCByb290ID0gdGhpcy5yZXN1bHQucm9vdFxuICAgICAgd2hpbGUgKCFyb290W2lzQ2xlYW5dKSB7XG4gICAgICAgIHJvb3RbaXNDbGVhbl0gPSB0cnVlXG4gICAgICAgIGxldCBzdGFjayA9IFt0b1N0YWNrKHJvb3QpXVxuICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxldCBwcm9taXNlID0gdGhpcy52aXNpdFRpY2soc3RhY2spXG4gICAgICAgICAgaWYgKGlzUHJvbWlzZShwcm9taXNlKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgcHJvbWlzZVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBsZXQgbm9kZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLm5vZGVcbiAgICAgICAgICAgICAgdGhyb3cgdGhpcy5oYW5kbGVFcnJvcihlLCBub2RlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5saXN0ZW5lcnMuT25jZUV4aXQpIHtcbiAgICAgICAgZm9yIChsZXQgW3BsdWdpbiwgdmlzaXRvcl0gb2YgdGhpcy5saXN0ZW5lcnMuT25jZUV4aXQpIHtcbiAgICAgICAgICB0aGlzLnJlc3VsdC5sYXN0UGx1Z2luID0gcGx1Z2luXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyb290LnR5cGUgPT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgICAgICAgbGV0IHJvb3RzID0gcm9vdC5ub2Rlcy5tYXAoc3ViUm9vdCA9PlxuICAgICAgICAgICAgICAgIHZpc2l0b3Ioc3ViUm9vdCwgdGhpcy5oZWxwZXJzKVxuICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocm9vdHMpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhd2FpdCB2aXNpdG9yKHJvb3QsIHRoaXMuaGVscGVycylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmhhbmRsZUVycm9yKGUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wcm9jZXNzZWQgPSB0cnVlXG4gICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KClcbiAgfVxuXG4gIHByZXBhcmVWaXNpdG9ycygpIHtcbiAgICB0aGlzLmxpc3RlbmVycyA9IHt9XG4gICAgbGV0IGFkZCA9IChwbHVnaW4sIHR5cGUsIGNiKSA9PiB7XG4gICAgICBpZiAoIXRoaXMubGlzdGVuZXJzW3R5cGVdKSB0aGlzLmxpc3RlbmVyc1t0eXBlXSA9IFtdXG4gICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKFtwbHVnaW4sIGNiXSlcbiAgICB9XG4gICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucykge1xuICAgICAgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAobGV0IGV2ZW50IGluIHBsdWdpbikge1xuICAgICAgICAgIGlmICghUExVR0lOX1BST1BTW2V2ZW50XSAmJiAvXltBLVpdLy50ZXN0KGV2ZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgVW5rbm93biBldmVudCAke2V2ZW50fSBpbiAke3BsdWdpbi5wb3N0Y3NzUGx1Z2lufS4gYCArXG4gICAgICAgICAgICAgICAgYFRyeSB0byB1cGRhdGUgUG9zdENTUyAoJHt0aGlzLnByb2Nlc3Nvci52ZXJzaW9ufSBub3cpLmBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFOT1RfVklTSVRPUlNbZXZlbnRdKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBsdWdpbltldmVudF0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IGZpbHRlciBpbiBwbHVnaW5bZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlciA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICBhZGQocGx1Z2luLCBldmVudCwgcGx1Z2luW2V2ZW50XVtmaWx0ZXJdKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBhZGQoXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbixcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQgKyAnLScgKyBmaWx0ZXIudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luW2V2ZW50XVtmaWx0ZXJdXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW5bZXZlbnRdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGFkZChwbHVnaW4sIGV2ZW50LCBwbHVnaW5bZXZlbnRdKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmhhc0xpc3RlbmVyID0gT2JqZWN0LmtleXModGhpcy5saXN0ZW5lcnMpLmxlbmd0aCA+IDBcbiAgfVxuXG4gIHZpc2l0VGljayhzdGFjaykge1xuICAgIGxldCB2aXNpdCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdXG4gICAgbGV0IHsgbm9kZSwgdmlzaXRvcnMgfSA9IHZpc2l0XG5cbiAgICBpZiAobm9kZS50eXBlICE9PSAncm9vdCcgJiYgbm9kZS50eXBlICE9PSAnZG9jdW1lbnQnICYmICFub2RlLnBhcmVudCkge1xuICAgICAgc3RhY2sucG9wKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh2aXNpdG9ycy5sZW5ndGggPiAwICYmIHZpc2l0LnZpc2l0b3JJbmRleCA8IHZpc2l0b3JzLmxlbmd0aCkge1xuICAgICAgbGV0IFtwbHVnaW4sIHZpc2l0b3JdID0gdmlzaXRvcnNbdmlzaXQudmlzaXRvckluZGV4XVxuICAgICAgdmlzaXQudmlzaXRvckluZGV4ICs9IDFcbiAgICAgIGlmICh2aXNpdC52aXNpdG9ySW5kZXggPT09IHZpc2l0b3JzLmxlbmd0aCkge1xuICAgICAgICB2aXNpdC52aXNpdG9ycyA9IFtdXG4gICAgICAgIHZpc2l0LnZpc2l0b3JJbmRleCA9IDBcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzdWx0Lmxhc3RQbHVnaW4gPSBwbHVnaW5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yKG5vZGUudG9Qcm94eSgpLCB0aGlzLmhlbHBlcnMpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZSwgbm9kZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmlzaXQuaXRlcmF0b3IgIT09IDApIHtcbiAgICAgIGxldCBpdGVyYXRvciA9IHZpc2l0Lml0ZXJhdG9yXG4gICAgICBsZXQgY2hpbGRcbiAgICAgIHdoaWxlICgoY2hpbGQgPSBub2RlLm5vZGVzW25vZGUuaW5kZXhlc1tpdGVyYXRvcl1dKSkge1xuICAgICAgICBub2RlLmluZGV4ZXNbaXRlcmF0b3JdICs9IDFcbiAgICAgICAgaWYgKCFjaGlsZFtpc0NsZWFuXSkge1xuICAgICAgICAgIGNoaWxkW2lzQ2xlYW5dID0gdHJ1ZVxuICAgICAgICAgIHN0YWNrLnB1c2godG9TdGFjayhjaGlsZCkpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZpc2l0Lml0ZXJhdG9yID0gMFxuICAgICAgZGVsZXRlIG5vZGUuaW5kZXhlc1tpdGVyYXRvcl1cbiAgICB9XG5cbiAgICBsZXQgZXZlbnRzID0gdmlzaXQuZXZlbnRzXG4gICAgd2hpbGUgKHZpc2l0LmV2ZW50SW5kZXggPCBldmVudHMubGVuZ3RoKSB7XG4gICAgICBsZXQgZXZlbnQgPSBldmVudHNbdmlzaXQuZXZlbnRJbmRleF1cbiAgICAgIHZpc2l0LmV2ZW50SW5kZXggKz0gMVxuICAgICAgaWYgKGV2ZW50ID09PSBDSElMRFJFTikge1xuICAgICAgICBpZiAobm9kZS5ub2RlcyAmJiBub2RlLm5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIG5vZGVbaXNDbGVhbl0gPSB0cnVlXG4gICAgICAgICAgdmlzaXQuaXRlcmF0b3IgPSBub2RlLmdldEl0ZXJhdG9yKClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5saXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgIHZpc2l0LnZpc2l0b3JzID0gdGhpcy5saXN0ZW5lcnNbZXZlbnRdXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICBzdGFjay5wb3AoKVxuICB9XG59XG5cbkxhenlSZXN1bHQucmVnaXN0ZXJQb3N0Y3NzID0gZGVwZW5kYW50ID0+IHtcbiAgcG9zdGNzcyA9IGRlcGVuZGFudFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExhenlSZXN1bHRcbkxhenlSZXN1bHQuZGVmYXVsdCA9IExhenlSZXN1bHRcblxuUm9vdC5yZWdpc3RlckxhenlSZXN1bHQoTGF6eVJlc3VsdClcbkRvY3VtZW50LnJlZ2lzdGVyTGF6eVJlc3VsdChMYXp5UmVzdWx0KVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/lazy-result.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/list.js":
/*!******************************************!*\
  !*** ./node_modules/postcss/lib/list.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\n\nlet list = {\n  split(string, separators, last) {\n    let array = []\n    let current = ''\n    let split = false\n\n    let func = 0\n    let inQuote = false\n    let prevQuote = ''\n    let escape = false\n\n    for (let letter of string) {\n      if (escape) {\n        escape = false\n      } else if (letter === '\\\\') {\n        escape = true\n      } else if (inQuote) {\n        if (letter === prevQuote) {\n          inQuote = false\n        }\n      } else if (letter === '\"' || letter === \"'\") {\n        inQuote = true\n        prevQuote = letter\n      } else if (letter === '(') {\n        func += 1\n      } else if (letter === ')') {\n        if (func > 0) func -= 1\n      } else if (func === 0) {\n        if (separators.includes(letter)) split = true\n      }\n\n      if (split) {\n        if (current !== '') array.push(current.trim())\n        current = ''\n        split = false\n      } else {\n        current += letter\n      }\n    }\n\n    if (last || current !== '') array.push(current.trim())\n    return array\n  },\n\n  space(string) {\n    let spaces = [' ', '\\n', '\\t']\n    return list.split(string, spaces)\n  },\n\n  comma(string) {\n    return list.split(string, [','], true)\n  }\n}\n\nmodule.exports = list\nlist.default = list\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvbGlzdC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvbGlzdC5qcz82ODUxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5sZXQgbGlzdCA9IHtcbiAgc3BsaXQoc3RyaW5nLCBzZXBhcmF0b3JzLCBsYXN0KSB7XG4gICAgbGV0IGFycmF5ID0gW11cbiAgICBsZXQgY3VycmVudCA9ICcnXG4gICAgbGV0IHNwbGl0ID0gZmFsc2VcblxuICAgIGxldCBmdW5jID0gMFxuICAgIGxldCBpblF1b3RlID0gZmFsc2VcbiAgICBsZXQgcHJldlF1b3RlID0gJydcbiAgICBsZXQgZXNjYXBlID0gZmFsc2VcblxuICAgIGZvciAobGV0IGxldHRlciBvZiBzdHJpbmcpIHtcbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgZXNjYXBlID0gZmFsc2VcbiAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSAnXFxcXCcpIHtcbiAgICAgICAgZXNjYXBlID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChpblF1b3RlKSB7XG4gICAgICAgIGlmIChsZXR0ZXIgPT09IHByZXZRdW90ZSkge1xuICAgICAgICAgIGluUXVvdGUgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGxldHRlciA9PT0gJ1wiJyB8fCBsZXR0ZXIgPT09IFwiJ1wiKSB7XG4gICAgICAgIGluUXVvdGUgPSB0cnVlXG4gICAgICAgIHByZXZRdW90ZSA9IGxldHRlclxuICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09ICcoJykge1xuICAgICAgICBmdW5jICs9IDFcbiAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSAnKScpIHtcbiAgICAgICAgaWYgKGZ1bmMgPiAwKSBmdW5jIC09IDFcbiAgICAgIH0gZWxzZSBpZiAoZnVuYyA9PT0gMCkge1xuICAgICAgICBpZiAoc2VwYXJhdG9ycy5pbmNsdWRlcyhsZXR0ZXIpKSBzcGxpdCA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKHNwbGl0KSB7XG4gICAgICAgIGlmIChjdXJyZW50ICE9PSAnJykgYXJyYXkucHVzaChjdXJyZW50LnRyaW0oKSlcbiAgICAgICAgY3VycmVudCA9ICcnXG4gICAgICAgIHNwbGl0ID0gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnQgKz0gbGV0dGVyXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxhc3QgfHwgY3VycmVudCAhPT0gJycpIGFycmF5LnB1c2goY3VycmVudC50cmltKCkpXG4gICAgcmV0dXJuIGFycmF5XG4gIH0sXG5cbiAgc3BhY2Uoc3RyaW5nKSB7XG4gICAgbGV0IHNwYWNlcyA9IFsnICcsICdcXG4nLCAnXFx0J11cbiAgICByZXR1cm4gbGlzdC5zcGxpdChzdHJpbmcsIHNwYWNlcylcbiAgfSxcblxuICBjb21tYShzdHJpbmcpIHtcbiAgICByZXR1cm4gbGlzdC5zcGxpdChzdHJpbmcsIFsnLCddLCB0cnVlKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdFxubGlzdC5kZWZhdWx0ID0gbGlzdFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/list.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/map-generator.js":
/*!***************************************************!*\
  !*** ./node_modules/postcss/lib/map-generator.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\nlet { SourceMapConsumer, SourceMapGenerator } = __webpack_require__(/*! source-map-js */ \"?6f78\")\nlet { dirname, resolve, relative, sep } = __webpack_require__(/*! path */ \"?25fb\")\nlet { pathToFileURL } = __webpack_require__(/*! url */ \"?9214\")\n\nlet Input = __webpack_require__(/*! ./input */ \"./node_modules/postcss/lib/input.js\")\n\nlet sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator)\nlet pathAvailable = Boolean(dirname && resolve && relative && sep)\n\nclass MapGenerator {\n  constructor(stringify, root, opts, cssString) {\n    this.stringify = stringify\n    this.mapOpts = opts.map || {}\n    this.root = root\n    this.opts = opts\n    this.css = cssString\n    this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute\n  }\n\n  isMap() {\n    if (typeof this.opts.map !== 'undefined') {\n      return !!this.opts.map\n    }\n    return this.previous().length > 0\n  }\n\n  previous() {\n    if (!this.previousMaps) {\n      this.previousMaps = []\n      if (this.root) {\n        this.root.walk(node => {\n          if (node.source && node.source.input.map) {\n            let map = node.source.input.map\n            if (!this.previousMaps.includes(map)) {\n              this.previousMaps.push(map)\n            }\n          }\n        })\n      } else {\n        let input = new Input(this.css, this.opts)\n        if (input.map) this.previousMaps.push(input.map)\n      }\n    }\n\n    return this.previousMaps\n  }\n\n  isInline() {\n    if (typeof this.mapOpts.inline !== 'undefined') {\n      return this.mapOpts.inline\n    }\n\n    let annotation = this.mapOpts.annotation\n    if (typeof annotation !== 'undefined' && annotation !== true) {\n      return false\n    }\n\n    if (this.previous().length) {\n      return this.previous().some(i => i.inline)\n    }\n    return true\n  }\n\n  isSourcesContent() {\n    if (typeof this.mapOpts.sourcesContent !== 'undefined') {\n      return this.mapOpts.sourcesContent\n    }\n    if (this.previous().length) {\n      return this.previous().some(i => i.withContent())\n    }\n    return true\n  }\n\n  clearAnnotation() {\n    if (this.mapOpts.annotation === false) return\n\n    if (this.root) {\n      let node\n      for (let i = this.root.nodes.length - 1; i >= 0; i--) {\n        node = this.root.nodes[i]\n        if (node.type !== 'comment') continue\n        if (node.text.indexOf('# sourceMappingURL=') === 0) {\n          this.root.removeChild(i)\n        }\n      }\n    } else if (this.css) {\n      this.css = this.css.replace(/(\\n)?\\/\\*#[\\S\\s]*?\\*\\/$/gm, '')\n    }\n  }\n\n  setSourcesContent() {\n    let already = {}\n    if (this.root) {\n      this.root.walk(node => {\n        if (node.source) {\n          let from = node.source.input.from\n          if (from && !already[from]) {\n            already[from] = true\n            let fromUrl = this.usesFileUrls\n              ? this.toFileUrl(from)\n              : this.toUrl(this.path(from))\n            this.map.setSourceContent(fromUrl, node.source.input.css)\n          }\n        }\n      })\n    } else if (this.css) {\n      let from = this.opts.from\n        ? this.toUrl(this.path(this.opts.from))\n        : '<no source>'\n      this.map.setSourceContent(from, this.css)\n    }\n  }\n\n  applyPrevMaps() {\n    for (let prev of this.previous()) {\n      let from = this.toUrl(this.path(prev.file))\n      let root = prev.root || dirname(prev.file)\n      let map\n\n      if (this.mapOpts.sourcesContent === false) {\n        map = new SourceMapConsumer(prev.text)\n        if (map.sourcesContent) {\n          map.sourcesContent = map.sourcesContent.map(() => null)\n        }\n      } else {\n        map = prev.consumer()\n      }\n\n      this.map.applySourceMap(map, from, this.toUrl(this.path(root)))\n    }\n  }\n\n  isAnnotation() {\n    if (this.isInline()) {\n      return true\n    }\n    if (typeof this.mapOpts.annotation !== 'undefined') {\n      return this.mapOpts.annotation\n    }\n    if (this.previous().length) {\n      return this.previous().some(i => i.annotation)\n    }\n    return true\n  }\n\n  toBase64(str) {\n    if (Buffer) {\n      return Buffer.from(str).toString('base64')\n    } else {\n      return window.btoa(unescape(encodeURIComponent(str)))\n    }\n  }\n\n  addAnnotation() {\n    let content\n\n    if (this.isInline()) {\n      content =\n        'data:application/json;base64,' + this.toBase64(this.map.toString())\n    } else if (typeof this.mapOpts.annotation === 'string') {\n      content = this.mapOpts.annotation\n    } else if (typeof this.mapOpts.annotation === 'function') {\n      content = this.mapOpts.annotation(this.opts.to, this.root)\n    } else {\n      content = this.outputFile() + '.map'\n    }\n    let eol = '\\n'\n    if (this.css.includes('\\r\\n')) eol = '\\r\\n'\n\n    this.css += eol + '/*# sourceMappingURL=' + content + ' */'\n  }\n\n  outputFile() {\n    if (this.opts.to) {\n      return this.path(this.opts.to)\n    } else if (this.opts.from) {\n      return this.path(this.opts.from)\n    } else {\n      return 'to.css'\n    }\n  }\n\n  generateMap() {\n    if (this.root) {\n      this.generateString()\n    } else if (this.previous().length === 1) {\n      let prev = this.previous()[0].consumer()\n      prev.file = this.outputFile()\n      this.map = SourceMapGenerator.fromSourceMap(prev)\n    } else {\n      this.map = new SourceMapGenerator({ file: this.outputFile() })\n      this.map.addMapping({\n        source: this.opts.from\n          ? this.toUrl(this.path(this.opts.from))\n          : '<no source>',\n        generated: { line: 1, column: 0 },\n        original: { line: 1, column: 0 }\n      })\n    }\n\n    if (this.isSourcesContent()) this.setSourcesContent()\n    if (this.root && this.previous().length > 0) this.applyPrevMaps()\n    if (this.isAnnotation()) this.addAnnotation()\n\n    if (this.isInline()) {\n      return [this.css]\n    } else {\n      return [this.css, this.map]\n    }\n  }\n\n  path(file) {\n    if (file.indexOf('<') === 0) return file\n    if (/^\\w+:\\/\\//.test(file)) return file\n    if (this.mapOpts.absolute) return file\n\n    let from = this.opts.to ? dirname(this.opts.to) : '.'\n\n    if (typeof this.mapOpts.annotation === 'string') {\n      from = dirname(resolve(from, this.mapOpts.annotation))\n    }\n\n    file = relative(from, file)\n    return file\n  }\n\n  toUrl(path) {\n    if (sep === '\\\\') {\n      path = path.replace(/\\\\/g, '/')\n    }\n    return encodeURI(path).replace(/[#?]/g, encodeURIComponent)\n  }\n\n  toFileUrl(path) {\n    if (pathToFileURL) {\n      return pathToFileURL(path).toString()\n    } else {\n      throw new Error(\n        '`map.absolute` option is not available in this PostCSS build'\n      )\n    }\n  }\n\n  sourcePath(node) {\n    if (this.mapOpts.from) {\n      return this.toUrl(this.mapOpts.from)\n    } else if (this.usesFileUrls) {\n      return this.toFileUrl(node.source.input.from)\n    } else {\n      return this.toUrl(this.path(node.source.input.from))\n    }\n  }\n\n  generateString() {\n    this.css = ''\n    this.map = new SourceMapGenerator({ file: this.outputFile() })\n\n    let line = 1\n    let column = 1\n\n    let noSource = '<no source>'\n    let mapping = {\n      source: '',\n      generated: { line: 0, column: 0 },\n      original: { line: 0, column: 0 }\n    }\n\n    let lines, last\n    this.stringify(this.root, (str, node, type) => {\n      this.css += str\n\n      if (node && type !== 'end') {\n        mapping.generated.line = line\n        mapping.generated.column = column - 1\n        if (node.source && node.source.start) {\n          mapping.source = this.sourcePath(node)\n          mapping.original.line = node.source.start.line\n          mapping.original.column = node.source.start.column - 1\n          this.map.addMapping(mapping)\n        } else {\n          mapping.source = noSource\n          mapping.original.line = 1\n          mapping.original.column = 0\n          this.map.addMapping(mapping)\n        }\n      }\n\n      lines = str.match(/\\n/g)\n      if (lines) {\n        line += lines.length\n        last = str.lastIndexOf('\\n')\n        column = str.length - last\n      } else {\n        column += str.length\n      }\n\n      if (node && type !== 'start') {\n        let p = node.parent || { raws: {} }\n        if (node.type !== 'decl' || node !== p.last || p.raws.semicolon) {\n          if (node.source && node.source.end) {\n            mapping.source = this.sourcePath(node)\n            mapping.original.line = node.source.end.line\n            mapping.original.column = node.source.end.column - 1\n            mapping.generated.line = line\n            mapping.generated.column = column - 2\n            this.map.addMapping(mapping)\n          } else {\n            mapping.source = noSource\n            mapping.original.line = 1\n            mapping.original.column = 0\n            mapping.generated.line = line\n            mapping.generated.column = column - 1\n            this.map.addMapping(mapping)\n          }\n        }\n      }\n    })\n  }\n\n  generate() {\n    this.clearAnnotation()\n    if (pathAvailable && sourceMapAvailable && this.isMap()) {\n      return this.generateMap()\n    } else {\n      let result = ''\n      this.stringify(this.root, i => {\n        result += i\n      })\n      return [result]\n    }\n  }\n}\n\nmodule.exports = MapGenerator\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvbWFwLWdlbmVyYXRvci5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVk7O0FBRVosTUFBTSx3Q0FBd0MsRUFBRSxtQkFBTyxDQUFDLDRCQUFlO0FBQ3ZFLE1BQU0sa0NBQWtDLEVBQUUsbUJBQU8sQ0FBQyxtQkFBTTtBQUN4RCxNQUFNLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsa0JBQUs7O0FBRXJDLFlBQVksbUJBQU8sQ0FBQyxvREFBUzs7QUFFN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsTUFBTTtBQUNkLGFBQWEsTUFBTTtBQUNuQixNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMENBQTBDLHlCQUF5QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekMsb0JBQW9CO0FBQ3BCLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLHlCQUF5Qjs7QUFFakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzL2xpYi9tYXAtZ2VuZXJhdG9yLmpzPzdhNzUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmxldCB7IFNvdXJjZU1hcENvbnN1bWVyLCBTb3VyY2VNYXBHZW5lcmF0b3IgfSA9IHJlcXVpcmUoJ3NvdXJjZS1tYXAtanMnKVxubGV0IHsgZGlybmFtZSwgcmVzb2x2ZSwgcmVsYXRpdmUsIHNlcCB9ID0gcmVxdWlyZSgncGF0aCcpXG5sZXQgeyBwYXRoVG9GaWxlVVJMIH0gPSByZXF1aXJlKCd1cmwnKVxuXG5sZXQgSW5wdXQgPSByZXF1aXJlKCcuL2lucHV0JylcblxubGV0IHNvdXJjZU1hcEF2YWlsYWJsZSA9IEJvb2xlYW4oU291cmNlTWFwQ29uc3VtZXIgJiYgU291cmNlTWFwR2VuZXJhdG9yKVxubGV0IHBhdGhBdmFpbGFibGUgPSBCb29sZWFuKGRpcm5hbWUgJiYgcmVzb2x2ZSAmJiByZWxhdGl2ZSAmJiBzZXApXG5cbmNsYXNzIE1hcEdlbmVyYXRvciB7XG4gIGNvbnN0cnVjdG9yKHN0cmluZ2lmeSwgcm9vdCwgb3B0cywgY3NzU3RyaW5nKSB7XG4gICAgdGhpcy5zdHJpbmdpZnkgPSBzdHJpbmdpZnlcbiAgICB0aGlzLm1hcE9wdHMgPSBvcHRzLm1hcCB8fCB7fVxuICAgIHRoaXMucm9vdCA9IHJvb3RcbiAgICB0aGlzLm9wdHMgPSBvcHRzXG4gICAgdGhpcy5jc3MgPSBjc3NTdHJpbmdcbiAgICB0aGlzLnVzZXNGaWxlVXJscyA9ICF0aGlzLm1hcE9wdHMuZnJvbSAmJiB0aGlzLm1hcE9wdHMuYWJzb2x1dGVcbiAgfVxuXG4gIGlzTWFwKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRzLm1hcCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiAhIXRoaXMub3B0cy5tYXBcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJldmlvdXMoKS5sZW5ndGggPiAwXG4gIH1cblxuICBwcmV2aW91cygpIHtcbiAgICBpZiAoIXRoaXMucHJldmlvdXNNYXBzKSB7XG4gICAgICB0aGlzLnByZXZpb3VzTWFwcyA9IFtdXG4gICAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICAgIHRoaXMucm9vdC53YWxrKG5vZGUgPT4ge1xuICAgICAgICAgIGlmIChub2RlLnNvdXJjZSAmJiBub2RlLnNvdXJjZS5pbnB1dC5tYXApIHtcbiAgICAgICAgICAgIGxldCBtYXAgPSBub2RlLnNvdXJjZS5pbnB1dC5tYXBcbiAgICAgICAgICAgIGlmICghdGhpcy5wcmV2aW91c01hcHMuaW5jbHVkZXMobWFwKSkge1xuICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzTWFwcy5wdXNoKG1hcClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgaW5wdXQgPSBuZXcgSW5wdXQodGhpcy5jc3MsIHRoaXMub3B0cylcbiAgICAgICAgaWYgKGlucHV0Lm1hcCkgdGhpcy5wcmV2aW91c01hcHMucHVzaChpbnB1dC5tYXApXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucHJldmlvdXNNYXBzXG4gIH1cblxuICBpc0lubGluZSgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5pbmxpbmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXBPcHRzLmlubGluZVxuICAgIH1cblxuICAgIGxldCBhbm5vdGF0aW9uID0gdGhpcy5tYXBPcHRzLmFubm90YXRpb25cbiAgICBpZiAodHlwZW9mIGFubm90YXRpb24gIT09ICd1bmRlZmluZWQnICYmIGFubm90YXRpb24gIT09IHRydWUpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmICh0aGlzLnByZXZpb3VzKCkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmV2aW91cygpLnNvbWUoaSA9PiBpLmlubGluZSlcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlzU291cmNlc0NvbnRlbnQoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuc291cmNlc0NvbnRlbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXBPcHRzLnNvdXJjZXNDb250ZW50XG4gICAgfVxuICAgIGlmICh0aGlzLnByZXZpb3VzKCkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmV2aW91cygpLnNvbWUoaSA9PiBpLndpdGhDb250ZW50KCkpXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjbGVhckFubm90YXRpb24oKSB7XG4gICAgaWYgKHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSBmYWxzZSkgcmV0dXJuXG5cbiAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICBsZXQgbm9kZVxuICAgICAgZm9yIChsZXQgaSA9IHRoaXMucm9vdC5ub2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBub2RlID0gdGhpcy5yb290Lm5vZGVzW2ldXG4gICAgICAgIGlmIChub2RlLnR5cGUgIT09ICdjb21tZW50JykgY29udGludWVcbiAgICAgICAgaWYgKG5vZGUudGV4dC5pbmRleE9mKCcjIHNvdXJjZU1hcHBpbmdVUkw9JykgPT09IDApIHtcbiAgICAgICAgICB0aGlzLnJvb3QucmVtb3ZlQ2hpbGQoaSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5jc3MpIHtcbiAgICAgIHRoaXMuY3NzID0gdGhpcy5jc3MucmVwbGFjZSgvKFxcbik/XFwvXFwqI1tcXFNcXHNdKj9cXCpcXC8kL2dtLCAnJylcbiAgICB9XG4gIH1cblxuICBzZXRTb3VyY2VzQ29udGVudCgpIHtcbiAgICBsZXQgYWxyZWFkeSA9IHt9XG4gICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgdGhpcy5yb290LndhbGsobm9kZSA9PiB7XG4gICAgICAgIGlmIChub2RlLnNvdXJjZSkge1xuICAgICAgICAgIGxldCBmcm9tID0gbm9kZS5zb3VyY2UuaW5wdXQuZnJvbVxuICAgICAgICAgIGlmIChmcm9tICYmICFhbHJlYWR5W2Zyb21dKSB7XG4gICAgICAgICAgICBhbHJlYWR5W2Zyb21dID0gdHJ1ZVxuICAgICAgICAgICAgbGV0IGZyb21VcmwgPSB0aGlzLnVzZXNGaWxlVXJsc1xuICAgICAgICAgICAgICA/IHRoaXMudG9GaWxlVXJsKGZyb20pXG4gICAgICAgICAgICAgIDogdGhpcy50b1VybCh0aGlzLnBhdGgoZnJvbSkpXG4gICAgICAgICAgICB0aGlzLm1hcC5zZXRTb3VyY2VDb250ZW50KGZyb21VcmwsIG5vZGUuc291cmNlLmlucHV0LmNzcylcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmICh0aGlzLmNzcykge1xuICAgICAgbGV0IGZyb20gPSB0aGlzLm9wdHMuZnJvbVxuICAgICAgICA/IHRoaXMudG9VcmwodGhpcy5wYXRoKHRoaXMub3B0cy5mcm9tKSlcbiAgICAgICAgOiAnPG5vIHNvdXJjZT4nXG4gICAgICB0aGlzLm1hcC5zZXRTb3VyY2VDb250ZW50KGZyb20sIHRoaXMuY3NzKVxuICAgIH1cbiAgfVxuXG4gIGFwcGx5UHJldk1hcHMoKSB7XG4gICAgZm9yIChsZXQgcHJldiBvZiB0aGlzLnByZXZpb3VzKCkpIHtcbiAgICAgIGxldCBmcm9tID0gdGhpcy50b1VybCh0aGlzLnBhdGgocHJldi5maWxlKSlcbiAgICAgIGxldCByb290ID0gcHJldi5yb290IHx8IGRpcm5hbWUocHJldi5maWxlKVxuICAgICAgbGV0IG1hcFxuXG4gICAgICBpZiAodGhpcy5tYXBPcHRzLnNvdXJjZXNDb250ZW50ID09PSBmYWxzZSkge1xuICAgICAgICBtYXAgPSBuZXcgU291cmNlTWFwQ29uc3VtZXIocHJldi50ZXh0KVxuICAgICAgICBpZiAobWFwLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICAgICAgbWFwLnNvdXJjZXNDb250ZW50ID0gbWFwLnNvdXJjZXNDb250ZW50Lm1hcCgoKSA9PiBudWxsKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXAgPSBwcmV2LmNvbnN1bWVyKClcbiAgICAgIH1cblxuICAgICAgdGhpcy5tYXAuYXBwbHlTb3VyY2VNYXAobWFwLCBmcm9tLCB0aGlzLnRvVXJsKHRoaXMucGF0aChyb290KSkpXG4gICAgfVxuICB9XG5cbiAgaXNBbm5vdGF0aW9uKCkge1xuICAgIGlmICh0aGlzLmlzSW5saW5lKCkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLmFubm90YXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXBPcHRzLmFubm90YXRpb25cbiAgICB9XG4gICAgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkuc29tZShpID0+IGkuYW5ub3RhdGlvbilcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHRvQmFzZTY0KHN0cikge1xuICAgIGlmIChCdWZmZXIpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHIpLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd2luZG93LmJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpKVxuICAgIH1cbiAgfVxuXG4gIGFkZEFubm90YXRpb24oKSB7XG4gICAgbGV0IGNvbnRlbnRcblxuICAgIGlmICh0aGlzLmlzSW5saW5lKCkpIHtcbiAgICAgIGNvbnRlbnQgPVxuICAgICAgICAnZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwnICsgdGhpcy50b0Jhc2U2NCh0aGlzLm1hcC50b1N0cmluZygpKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgY29udGVudCA9IHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLmFubm90YXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnRlbnQgPSB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbih0aGlzLm9wdHMudG8sIHRoaXMucm9vdClcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IHRoaXMub3V0cHV0RmlsZSgpICsgJy5tYXAnXG4gICAgfVxuICAgIGxldCBlb2wgPSAnXFxuJ1xuICAgIGlmICh0aGlzLmNzcy5pbmNsdWRlcygnXFxyXFxuJykpIGVvbCA9ICdcXHJcXG4nXG5cbiAgICB0aGlzLmNzcyArPSBlb2wgKyAnLyojIHNvdXJjZU1hcHBpbmdVUkw9JyArIGNvbnRlbnQgKyAnICovJ1xuICB9XG5cbiAgb3V0cHV0RmlsZSgpIHtcbiAgICBpZiAodGhpcy5vcHRzLnRvKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXRoKHRoaXMub3B0cy50bylcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0cy5mcm9tKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXRoKHRoaXMub3B0cy5mcm9tKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ3RvLmNzcydcbiAgICB9XG4gIH1cblxuICBnZW5lcmF0ZU1hcCgpIHtcbiAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICB0aGlzLmdlbmVyYXRlU3RyaW5nKClcbiAgICB9IGVsc2UgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxldCBwcmV2ID0gdGhpcy5wcmV2aW91cygpWzBdLmNvbnN1bWVyKClcbiAgICAgIHByZXYuZmlsZSA9IHRoaXMub3V0cHV0RmlsZSgpXG4gICAgICB0aGlzLm1hcCA9IFNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwKHByZXYpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7IGZpbGU6IHRoaXMub3V0cHV0RmlsZSgpIH0pXG4gICAgICB0aGlzLm1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgc291cmNlOiB0aGlzLm9wdHMuZnJvbVxuICAgICAgICAgID8gdGhpcy50b1VybCh0aGlzLnBhdGgodGhpcy5vcHRzLmZyb20pKVxuICAgICAgICAgIDogJzxubyBzb3VyY2U+JyxcbiAgICAgICAgZ2VuZXJhdGVkOiB7IGxpbmU6IDEsIGNvbHVtbjogMCB9LFxuICAgICAgICBvcmlnaW5hbDogeyBsaW5lOiAxLCBjb2x1bW46IDAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1NvdXJjZXNDb250ZW50KCkpIHRoaXMuc2V0U291cmNlc0NvbnRlbnQoKVxuICAgIGlmICh0aGlzLnJvb3QgJiYgdGhpcy5wcmV2aW91cygpLmxlbmd0aCA+IDApIHRoaXMuYXBwbHlQcmV2TWFwcygpXG4gICAgaWYgKHRoaXMuaXNBbm5vdGF0aW9uKCkpIHRoaXMuYWRkQW5ub3RhdGlvbigpXG5cbiAgICBpZiAodGhpcy5pc0lubGluZSgpKSB7XG4gICAgICByZXR1cm4gW3RoaXMuY3NzXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW3RoaXMuY3NzLCB0aGlzLm1hcF1cbiAgICB9XG4gIH1cblxuICBwYXRoKGZpbGUpIHtcbiAgICBpZiAoZmlsZS5pbmRleE9mKCc8JykgPT09IDApIHJldHVybiBmaWxlXG4gICAgaWYgKC9eXFx3KzpcXC9cXC8vLnRlc3QoZmlsZSkpIHJldHVybiBmaWxlXG4gICAgaWYgKHRoaXMubWFwT3B0cy5hYnNvbHV0ZSkgcmV0dXJuIGZpbGVcblxuICAgIGxldCBmcm9tID0gdGhpcy5vcHRzLnRvID8gZGlybmFtZSh0aGlzLm9wdHMudG8pIDogJy4nXG5cbiAgICBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgZnJvbSA9IGRpcm5hbWUocmVzb2x2ZShmcm9tLCB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbikpXG4gICAgfVxuXG4gICAgZmlsZSA9IHJlbGF0aXZlKGZyb20sIGZpbGUpXG4gICAgcmV0dXJuIGZpbGVcbiAgfVxuXG4gIHRvVXJsKHBhdGgpIHtcbiAgICBpZiAoc2VwID09PSAnXFxcXCcpIHtcbiAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKVxuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlVVJJKHBhdGgpLnJlcGxhY2UoL1sjP10vZywgZW5jb2RlVVJJQ29tcG9uZW50KVxuICB9XG5cbiAgdG9GaWxlVXJsKHBhdGgpIHtcbiAgICBpZiAocGF0aFRvRmlsZVVSTCkge1xuICAgICAgcmV0dXJuIHBhdGhUb0ZpbGVVUkwocGF0aCkudG9TdHJpbmcoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdgbWFwLmFic29sdXRlYCBvcHRpb24gaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIFBvc3RDU1MgYnVpbGQnXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgc291cmNlUGF0aChub2RlKSB7XG4gICAgaWYgKHRoaXMubWFwT3B0cy5mcm9tKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1VybCh0aGlzLm1hcE9wdHMuZnJvbSlcbiAgICB9IGVsc2UgaWYgKHRoaXMudXNlc0ZpbGVVcmxzKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0ZpbGVVcmwobm9kZS5zb3VyY2UuaW5wdXQuZnJvbSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudG9VcmwodGhpcy5wYXRoKG5vZGUuc291cmNlLmlucHV0LmZyb20pKVxuICAgIH1cbiAgfVxuXG4gIGdlbmVyYXRlU3RyaW5nKCkge1xuICAgIHRoaXMuY3NzID0gJydcbiAgICB0aGlzLm1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IoeyBmaWxlOiB0aGlzLm91dHB1dEZpbGUoKSB9KVxuXG4gICAgbGV0IGxpbmUgPSAxXG4gICAgbGV0IGNvbHVtbiA9IDFcblxuICAgIGxldCBub1NvdXJjZSA9ICc8bm8gc291cmNlPidcbiAgICBsZXQgbWFwcGluZyA9IHtcbiAgICAgIHNvdXJjZTogJycsXG4gICAgICBnZW5lcmF0ZWQ6IHsgbGluZTogMCwgY29sdW1uOiAwIH0sXG4gICAgICBvcmlnaW5hbDogeyBsaW5lOiAwLCBjb2x1bW46IDAgfVxuICAgIH1cblxuICAgIGxldCBsaW5lcywgbGFzdFxuICAgIHRoaXMuc3RyaW5naWZ5KHRoaXMucm9vdCwgKHN0ciwgbm9kZSwgdHlwZSkgPT4ge1xuICAgICAgdGhpcy5jc3MgKz0gc3RyXG5cbiAgICAgIGlmIChub2RlICYmIHR5cGUgIT09ICdlbmQnKSB7XG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmxpbmUgPSBsaW5lXG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmNvbHVtbiA9IGNvbHVtbiAtIDFcbiAgICAgICAgaWYgKG5vZGUuc291cmNlICYmIG5vZGUuc291cmNlLnN0YXJ0KSB7XG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB0aGlzLnNvdXJjZVBhdGgobm9kZSlcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSBub2RlLnNvdXJjZS5zdGFydC5saW5lXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5jb2x1bW4gPSBub2RlLnNvdXJjZS5zdGFydC5jb2x1bW4gLSAxXG4gICAgICAgICAgdGhpcy5tYXAuYWRkTWFwcGluZyhtYXBwaW5nKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gbm9Tb3VyY2VcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSAxXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5jb2x1bW4gPSAwXG4gICAgICAgICAgdGhpcy5tYXAuYWRkTWFwcGluZyhtYXBwaW5nKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpbmVzID0gc3RyLm1hdGNoKC9cXG4vZylcbiAgICAgIGlmIChsaW5lcykge1xuICAgICAgICBsaW5lICs9IGxpbmVzLmxlbmd0aFxuICAgICAgICBsYXN0ID0gc3RyLmxhc3RJbmRleE9mKCdcXG4nKVxuICAgICAgICBjb2x1bW4gPSBzdHIubGVuZ3RoIC0gbGFzdFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sdW1uICs9IHN0ci5sZW5ndGhcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUgJiYgdHlwZSAhPT0gJ3N0YXJ0Jykge1xuICAgICAgICBsZXQgcCA9IG5vZGUucGFyZW50IHx8IHsgcmF3czoge30gfVxuICAgICAgICBpZiAobm9kZS50eXBlICE9PSAnZGVjbCcgfHwgbm9kZSAhPT0gcC5sYXN0IHx8IHAucmF3cy5zZW1pY29sb24pIHtcbiAgICAgICAgICBpZiAobm9kZS5zb3VyY2UgJiYgbm9kZS5zb3VyY2UuZW5kKSB7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHRoaXMuc291cmNlUGF0aChub2RlKVxuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5saW5lID0gbm9kZS5zb3VyY2UuZW5kLmxpbmVcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwuY29sdW1uID0gbm9kZS5zb3VyY2UuZW5kLmNvbHVtbiAtIDFcbiAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmxpbmUgPSBsaW5lXG4gICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5jb2x1bW4gPSBjb2x1bW4gLSAyXG4gICAgICAgICAgICB0aGlzLm1hcC5hZGRNYXBwaW5nKG1hcHBpbmcpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gbm9Tb3VyY2VcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwubGluZSA9IDFcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwuY29sdW1uID0gMFxuICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQubGluZSA9IGxpbmVcbiAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmNvbHVtbiA9IGNvbHVtbiAtIDFcbiAgICAgICAgICAgIHRoaXMubWFwLmFkZE1hcHBpbmcobWFwcGluZylcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZ2VuZXJhdGUoKSB7XG4gICAgdGhpcy5jbGVhckFubm90YXRpb24oKVxuICAgIGlmIChwYXRoQXZhaWxhYmxlICYmIHNvdXJjZU1hcEF2YWlsYWJsZSAmJiB0aGlzLmlzTWFwKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlTWFwKClcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHJlc3VsdCA9ICcnXG4gICAgICB0aGlzLnN0cmluZ2lmeSh0aGlzLnJvb3QsIGkgPT4ge1xuICAgICAgICByZXN1bHQgKz0gaVxuICAgICAgfSlcbiAgICAgIHJldHVybiBbcmVzdWx0XVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcEdlbmVyYXRvclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/map-generator.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/no-work-result.js":
/*!****************************************************!*\
  !*** ./node_modules/postcss/lib/no-work-result.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet MapGenerator = __webpack_require__(/*! ./map-generator */ \"./node_modules/postcss/lib/map-generator.js\")\nlet stringify = __webpack_require__(/*! ./stringify */ \"./node_modules/postcss/lib/stringify.js\")\nlet warnOnce = __webpack_require__(/*! ./warn-once */ \"./node_modules/postcss/lib/warn-once.js\")\nlet parse = __webpack_require__(/*! ./parse */ \"./node_modules/postcss/lib/parse.js\")\nconst Result = __webpack_require__(/*! ./result */ \"./node_modules/postcss/lib/result.js\")\n\nclass NoWorkResult {\n  constructor(processor, css, opts) {\n    css = css.toString()\n    this.stringified = false\n\n    this._processor = processor\n    this._css = css\n    this._opts = opts\n    this._map = undefined\n    let root\n\n    let str = stringify\n    this.result = new Result(this._processor, root, this._opts)\n    this.result.css = css\n\n    let self = this\n    Object.defineProperty(this.result, 'root', {\n      get() {\n        return self.root\n      }\n    })\n\n    let map = new MapGenerator(str, root, this._opts, css)\n    if (map.isMap()) {\n      let [generatedCSS, generatedMap] = map.generate()\n      if (generatedCSS) {\n        this.result.css = generatedCSS\n      }\n      if (generatedMap) {\n        this.result.map = generatedMap\n      }\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'NoWorkResult'\n  }\n\n  get processor() {\n    return this.result.processor\n  }\n\n  get opts() {\n    return this.result.opts\n  }\n\n  get css() {\n    return this.result.css\n  }\n\n  get content() {\n    return this.result.css\n  }\n\n  get map() {\n    return this.result.map\n  }\n\n  get root() {\n    if (this._root) {\n      return this._root\n    }\n\n    let root\n    let parser = parse\n\n    try {\n      root = parser(this._css, this._opts)\n    } catch (error) {\n      this.error = error\n    }\n\n    if (this.error) {\n      throw this.error\n    } else {\n      this._root = root\n      return root\n    }\n  }\n\n  get messages() {\n    return []\n  }\n\n  warnings() {\n    return []\n  }\n\n  toString() {\n    return this._css\n  }\n\n  then(onFulfilled, onRejected) {\n    if (true) {\n      if (!('from' in this._opts)) {\n        warnOnce(\n          'Without `from` option PostCSS could generate wrong source map ' +\n            'and will not find Browserslist config. Set it to CSS file path ' +\n            'or to `undefined` to prevent this warning.'\n        )\n      }\n    }\n\n    return this.async().then(onFulfilled, onRejected)\n  }\n\n  catch(onRejected) {\n    return this.async().catch(onRejected)\n  }\n\n  finally(onFinally) {\n    return this.async().then(onFinally, onFinally)\n  }\n\n  async() {\n    if (this.error) return Promise.reject(this.error)\n    return Promise.resolve(this.result)\n  }\n\n  sync() {\n    if (this.error) throw this.error\n    return this.result\n  }\n}\n\nmodule.exports = NoWorkResult\nNoWorkResult.default = NoWorkResult\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvbm8td29yay1yZXN1bHQuanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosbUJBQW1CLG1CQUFPLENBQUMsb0VBQWlCO0FBQzVDLGdCQUFnQixtQkFBTyxDQUFDLDREQUFhO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyw0REFBYTtBQUNwQyxZQUFZLG1CQUFPLENBQUMsb0RBQVM7QUFDN0IsZUFBZSxtQkFBTyxDQUFDLHNEQUFVOztBQUVqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzL2xpYi9uby13b3JrLXJlc3VsdC5qcz9kODllIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5sZXQgTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9tYXAtZ2VuZXJhdG9yJylcbmxldCBzdHJpbmdpZnkgPSByZXF1aXJlKCcuL3N0cmluZ2lmeScpXG5sZXQgd2Fybk9uY2UgPSByZXF1aXJlKCcuL3dhcm4tb25jZScpXG5sZXQgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IFJlc3VsdCA9IHJlcXVpcmUoJy4vcmVzdWx0JylcblxuY2xhc3MgTm9Xb3JrUmVzdWx0IHtcbiAgY29uc3RydWN0b3IocHJvY2Vzc29yLCBjc3MsIG9wdHMpIHtcbiAgICBjc3MgPSBjc3MudG9TdHJpbmcoKVxuICAgIHRoaXMuc3RyaW5naWZpZWQgPSBmYWxzZVxuXG4gICAgdGhpcy5fcHJvY2Vzc29yID0gcHJvY2Vzc29yXG4gICAgdGhpcy5fY3NzID0gY3NzXG4gICAgdGhpcy5fb3B0cyA9IG9wdHNcbiAgICB0aGlzLl9tYXAgPSB1bmRlZmluZWRcbiAgICBsZXQgcm9vdFxuXG4gICAgbGV0IHN0ciA9IHN0cmluZ2lmeVxuICAgIHRoaXMucmVzdWx0ID0gbmV3IFJlc3VsdCh0aGlzLl9wcm9jZXNzb3IsIHJvb3QsIHRoaXMuX29wdHMpXG4gICAgdGhpcy5yZXN1bHQuY3NzID0gY3NzXG5cbiAgICBsZXQgc2VsZiA9IHRoaXNcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5yZXN1bHQsICdyb290Jywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gc2VsZi5yb290XG4gICAgICB9XG4gICAgfSlcblxuICAgIGxldCBtYXAgPSBuZXcgTWFwR2VuZXJhdG9yKHN0ciwgcm9vdCwgdGhpcy5fb3B0cywgY3NzKVxuICAgIGlmIChtYXAuaXNNYXAoKSkge1xuICAgICAgbGV0IFtnZW5lcmF0ZWRDU1MsIGdlbmVyYXRlZE1hcF0gPSBtYXAuZ2VuZXJhdGUoKVxuICAgICAgaWYgKGdlbmVyYXRlZENTUykge1xuICAgICAgICB0aGlzLnJlc3VsdC5jc3MgPSBnZW5lcmF0ZWRDU1NcbiAgICAgIH1cbiAgICAgIGlmIChnZW5lcmF0ZWRNYXApIHtcbiAgICAgICAgdGhpcy5yZXN1bHQubWFwID0gZ2VuZXJhdGVkTWFwXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiAnTm9Xb3JrUmVzdWx0J1xuICB9XG5cbiAgZ2V0IHByb2Nlc3NvcigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQucHJvY2Vzc29yXG4gIH1cblxuICBnZXQgb3B0cygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQub3B0c1xuICB9XG5cbiAgZ2V0IGNzcygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQuY3NzXG4gIH1cblxuICBnZXQgY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQuY3NzXG4gIH1cblxuICBnZXQgbWFwKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5tYXBcbiAgfVxuXG4gIGdldCByb290KCkge1xuICAgIGlmICh0aGlzLl9yb290KSB7XG4gICAgICByZXR1cm4gdGhpcy5fcm9vdFxuICAgIH1cblxuICAgIGxldCByb290XG4gICAgbGV0IHBhcnNlciA9IHBhcnNlXG5cbiAgICB0cnkge1xuICAgICAgcm9vdCA9IHBhcnNlcih0aGlzLl9jc3MsIHRoaXMuX29wdHMpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZXJyb3IgPSBlcnJvclxuICAgIH1cblxuICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLmVycm9yXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jvb3QgPSByb290XG4gICAgICByZXR1cm4gcm9vdFxuICAgIH1cbiAgfVxuXG4gIGdldCBtZXNzYWdlcygpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIHdhcm5pbmdzKCkge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nzc1xuICB9XG5cbiAgdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoISgnZnJvbScgaW4gdGhpcy5fb3B0cykpIHtcbiAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgJ1dpdGhvdXQgYGZyb21gIG9wdGlvbiBQb3N0Q1NTIGNvdWxkIGdlbmVyYXRlIHdyb25nIHNvdXJjZSBtYXAgJyArXG4gICAgICAgICAgICAnYW5kIHdpbGwgbm90IGZpbmQgQnJvd3NlcnNsaXN0IGNvbmZpZy4gU2V0IGl0IHRvIENTUyBmaWxlIHBhdGggJyArXG4gICAgICAgICAgICAnb3IgdG8gYHVuZGVmaW5lZGAgdG8gcHJldmVudCB0aGlzIHdhcm5pbmcuJ1xuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICB9XG5cbiAgY2F0Y2gob25SZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLmFzeW5jKCkuY2F0Y2gob25SZWplY3RlZClcbiAgfVxuXG4gIGZpbmFsbHkob25GaW5hbGx5KSB7XG4gICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRmluYWxseSwgb25GaW5hbGx5KVxuICB9XG5cbiAgYXN5bmMoKSB7XG4gICAgaWYgKHRoaXMuZXJyb3IpIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmVycm9yKVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5yZXN1bHQpXG4gIH1cblxuICBzeW5jKCkge1xuICAgIGlmICh0aGlzLmVycm9yKSB0aHJvdyB0aGlzLmVycm9yXG4gICAgcmV0dXJuIHRoaXMucmVzdWx0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBOb1dvcmtSZXN1bHRcbk5vV29ya1Jlc3VsdC5kZWZhdWx0ID0gTm9Xb3JrUmVzdWx0XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/no-work-result.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/node.js":
/*!******************************************!*\
  !*** ./node_modules/postcss/lib/node.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet { isClean, my } = __webpack_require__(/*! ./symbols */ \"./node_modules/postcss/lib/symbols.js\")\nlet CssSyntaxError = __webpack_require__(/*! ./css-syntax-error */ \"./node_modules/postcss/lib/css-syntax-error.js\")\nlet Stringifier = __webpack_require__(/*! ./stringifier */ \"./node_modules/postcss/lib/stringifier.js\")\nlet stringify = __webpack_require__(/*! ./stringify */ \"./node_modules/postcss/lib/stringify.js\")\n\nfunction cloneNode(obj, parent) {\n  let cloned = new obj.constructor()\n\n  for (let i in obj) {\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) {\n      /* c8 ignore next 2 */\n      continue\n    }\n    if (i === 'proxyCache') continue\n    let value = obj[i]\n    let type = typeof value\n\n    if (i === 'parent' && type === 'object') {\n      if (parent) cloned[i] = parent\n    } else if (i === 'source') {\n      cloned[i] = value\n    } else if (Array.isArray(value)) {\n      cloned[i] = value.map(j => cloneNode(j, cloned))\n    } else {\n      if (type === 'object' && value !== null) value = cloneNode(value)\n      cloned[i] = value\n    }\n  }\n\n  return cloned\n}\n\nclass Node {\n  constructor(defaults = {}) {\n    this.raws = {}\n    this[isClean] = false\n    this[my] = true\n\n    for (let name in defaults) {\n      if (name === 'nodes') {\n        this.nodes = []\n        for (let node of defaults[name]) {\n          if (typeof node.clone === 'function') {\n            this.append(node.clone())\n          } else {\n            this.append(node)\n          }\n        }\n      } else {\n        this[name] = defaults[name]\n      }\n    }\n  }\n\n  error(message, opts = {}) {\n    if (this.source) {\n      let { start, end } = this.rangeBy(opts)\n      return this.source.input.error(\n        message,\n        { line: start.line, column: start.column },\n        { line: end.line, column: end.column },\n        opts\n      )\n    }\n    return new CssSyntaxError(message)\n  }\n\n  warn(result, text, opts) {\n    let data = { node: this }\n    for (let i in opts) data[i] = opts[i]\n    return result.warn(text, data)\n  }\n\n  remove() {\n    if (this.parent) {\n      this.parent.removeChild(this)\n    }\n    this.parent = undefined\n    return this\n  }\n\n  toString(stringifier = stringify) {\n    if (stringifier.stringify) stringifier = stringifier.stringify\n    let result = ''\n    stringifier(this, i => {\n      result += i\n    })\n    return result\n  }\n\n  assign(overrides = {}) {\n    for (let name in overrides) {\n      this[name] = overrides[name]\n    }\n    return this\n  }\n\n  clone(overrides = {}) {\n    let cloned = cloneNode(this)\n    for (let name in overrides) {\n      cloned[name] = overrides[name]\n    }\n    return cloned\n  }\n\n  cloneBefore(overrides = {}) {\n    let cloned = this.clone(overrides)\n    this.parent.insertBefore(this, cloned)\n    return cloned\n  }\n\n  cloneAfter(overrides = {}) {\n    let cloned = this.clone(overrides)\n    this.parent.insertAfter(this, cloned)\n    return cloned\n  }\n\n  replaceWith(...nodes) {\n    if (this.parent) {\n      let bookmark = this\n      let foundSelf = false\n      for (let node of nodes) {\n        if (node === this) {\n          foundSelf = true\n        } else if (foundSelf) {\n          this.parent.insertAfter(bookmark, node)\n          bookmark = node\n        } else {\n          this.parent.insertBefore(bookmark, node)\n        }\n      }\n\n      if (!foundSelf) {\n        this.remove()\n      }\n    }\n\n    return this\n  }\n\n  next() {\n    if (!this.parent) return undefined\n    let index = this.parent.index(this)\n    return this.parent.nodes[index + 1]\n  }\n\n  prev() {\n    if (!this.parent) return undefined\n    let index = this.parent.index(this)\n    return this.parent.nodes[index - 1]\n  }\n\n  before(add) {\n    this.parent.insertBefore(this, add)\n    return this\n  }\n\n  after(add) {\n    this.parent.insertAfter(this, add)\n    return this\n  }\n\n  root() {\n    let result = this\n    while (result.parent && result.parent.type !== 'document') {\n      result = result.parent\n    }\n    return result\n  }\n\n  raw(prop, defaultType) {\n    let str = new Stringifier()\n    return str.raw(this, prop, defaultType)\n  }\n\n  cleanRaws(keepBetween) {\n    delete this.raws.before\n    delete this.raws.after\n    if (!keepBetween) delete this.raws.between\n  }\n\n  toJSON(_, inputs) {\n    let fixed = {}\n    let emitInputs = inputs == null\n    inputs = inputs || new Map()\n    let inputsNextIndex = 0\n\n    for (let name in this) {\n      if (!Object.prototype.hasOwnProperty.call(this, name)) {\n        /* c8 ignore next 2 */\n        continue\n      }\n      if (name === 'parent' || name === 'proxyCache') continue\n      let value = this[name]\n\n      if (Array.isArray(value)) {\n        fixed[name] = value.map(i => {\n          if (typeof i === 'object' && i.toJSON) {\n            return i.toJSON(null, inputs)\n          } else {\n            return i\n          }\n        })\n      } else if (typeof value === 'object' && value.toJSON) {\n        fixed[name] = value.toJSON(null, inputs)\n      } else if (name === 'source') {\n        let inputId = inputs.get(value.input)\n        if (inputId == null) {\n          inputId = inputsNextIndex\n          inputs.set(value.input, inputsNextIndex)\n          inputsNextIndex++\n        }\n        fixed[name] = {\n          inputId,\n          start: value.start,\n          end: value.end\n        }\n      } else {\n        fixed[name] = value\n      }\n    }\n\n    if (emitInputs) {\n      fixed.inputs = [...inputs.keys()].map(input => input.toJSON())\n    }\n\n    return fixed\n  }\n\n  positionInside(index) {\n    let string = this.toString()\n    let column = this.source.start.column\n    let line = this.source.start.line\n\n    for (let i = 0; i < index; i++) {\n      if (string[i] === '\\n') {\n        column = 1\n        line += 1\n      } else {\n        column += 1\n      }\n    }\n\n    return { line, column }\n  }\n\n  positionBy(opts) {\n    let pos = this.source.start\n    if (opts.index) {\n      pos = this.positionInside(opts.index)\n    } else if (opts.word) {\n      let index = this.toString().indexOf(opts.word)\n      if (index !== -1) pos = this.positionInside(index)\n    }\n    return pos\n  }\n\n  rangeBy(opts) {\n    let start = {\n      line: this.source.start.line,\n      column: this.source.start.column\n    }\n    let end = this.source.end\n      ? {\n          line: this.source.end.line,\n          column: this.source.end.column + 1\n        }\n      : {\n          line: start.line,\n          column: start.column + 1\n        }\n\n    if (opts.word) {\n      let index = this.toString().indexOf(opts.word)\n      if (index !== -1) {\n        start = this.positionInside(index)\n        end = this.positionInside(index + opts.word.length)\n      }\n    } else {\n      if (opts.start) {\n        start = {\n          line: opts.start.line,\n          column: opts.start.column\n        }\n      } else if (opts.index) {\n        start = this.positionInside(opts.index)\n      }\n\n      if (opts.end) {\n        end = {\n          line: opts.end.line,\n          column: opts.end.column\n        }\n      } else if (opts.endIndex) {\n        end = this.positionInside(opts.endIndex)\n      } else if (opts.index) {\n        end = this.positionInside(opts.index + 1)\n      }\n    }\n\n    if (\n      end.line < start.line ||\n      (end.line === start.line && end.column <= start.column)\n    ) {\n      end = { line: start.line, column: start.column + 1 }\n    }\n\n    return { start, end }\n  }\n\n  getProxyProcessor() {\n    return {\n      set(node, prop, value) {\n        if (node[prop] === value) return true\n        node[prop] = value\n        if (\n          prop === 'prop' ||\n          prop === 'value' ||\n          prop === 'name' ||\n          prop === 'params' ||\n          prop === 'important' ||\n          /* c8 ignore next */\n          prop === 'text'\n        ) {\n          node.markDirty()\n        }\n        return true\n      },\n\n      get(node, prop) {\n        if (prop === 'proxyOf') {\n          return node\n        } else if (prop === 'root') {\n          return () => node.root().toProxy()\n        } else {\n          return node[prop]\n        }\n      }\n    }\n  }\n\n  toProxy() {\n    if (!this.proxyCache) {\n      this.proxyCache = new Proxy(this, this.getProxyProcessor())\n    }\n    return this.proxyCache\n  }\n\n  addToError(error) {\n    error.postcssNode = this\n    if (error.stack && this.source && /\\n\\s{4}at /.test(error.stack)) {\n      let s = this.source\n      error.stack = error.stack.replace(\n        /\\n\\s{4}at /,\n        `$&${s.input.from}:${s.start.line}:${s.start.column}$&`\n      )\n    }\n    return error\n  }\n\n  markDirty() {\n    if (this[isClean]) {\n      this[isClean] = false\n      let next = this\n      while ((next = next.parent)) {\n        next[isClean] = false\n      }\n    }\n  }\n\n  get proxyOf() {\n    return this\n  }\n}\n\nmodule.exports = Node\nNode.default = Node\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvbm9kZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixNQUFNLGNBQWMsRUFBRSxtQkFBTyxDQUFDLHdEQUFXO0FBQ3pDLHFCQUFxQixtQkFBTyxDQUFDLDBFQUFvQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyxnRUFBZTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyw0REFBYTs7QUFFckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBLFVBQVUsd0NBQXdDO0FBQ2xELFVBQVUsb0NBQW9DO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QyxFQUFFO0FBQzlDO0FBQ0E7QUFDQSxjQUFjLEVBQUU7QUFDaEIsYUFBYSxhQUFhLEdBQUcsYUFBYSxHQUFHLGVBQWU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvbm9kZS5qcz9iMmU4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5sZXQgeyBpc0NsZWFuLCBteSB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmxldCBDc3NTeW50YXhFcnJvciA9IHJlcXVpcmUoJy4vY3NzLXN5bnRheC1lcnJvcicpXG5sZXQgU3RyaW5naWZpZXIgPSByZXF1aXJlKCcuL3N0cmluZ2lmaWVyJylcbmxldCBzdHJpbmdpZnkgPSByZXF1aXJlKCcuL3N0cmluZ2lmeScpXG5cbmZ1bmN0aW9uIGNsb25lTm9kZShvYmosIHBhcmVudCkge1xuICBsZXQgY2xvbmVkID0gbmV3IG9iai5jb25zdHJ1Y3RvcigpXG5cbiAgZm9yIChsZXQgaSBpbiBvYmopIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSB7XG4gICAgICAvKiBjOCBpZ25vcmUgbmV4dCAyICovXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoaSA9PT0gJ3Byb3h5Q2FjaGUnKSBjb250aW51ZVxuICAgIGxldCB2YWx1ZSA9IG9ialtpXVxuICAgIGxldCB0eXBlID0gdHlwZW9mIHZhbHVlXG5cbiAgICBpZiAoaSA9PT0gJ3BhcmVudCcgJiYgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwYXJlbnQpIGNsb25lZFtpXSA9IHBhcmVudFxuICAgIH0gZWxzZSBpZiAoaSA9PT0gJ3NvdXJjZScpIHtcbiAgICAgIGNsb25lZFtpXSA9IHZhbHVlXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgY2xvbmVkW2ldID0gdmFsdWUubWFwKGogPT4gY2xvbmVOb2RlKGosIGNsb25lZCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkgdmFsdWUgPSBjbG9uZU5vZGUodmFsdWUpXG4gICAgICBjbG9uZWRbaV0gPSB2YWx1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjbG9uZWRcbn1cblxuY2xhc3MgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKGRlZmF1bHRzID0ge30pIHtcbiAgICB0aGlzLnJhd3MgPSB7fVxuICAgIHRoaXNbaXNDbGVhbl0gPSBmYWxzZVxuICAgIHRoaXNbbXldID0gdHJ1ZVxuXG4gICAgZm9yIChsZXQgbmFtZSBpbiBkZWZhdWx0cykge1xuICAgICAgaWYgKG5hbWUgPT09ICdub2RlcycpIHtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdXG4gICAgICAgIGZvciAobGV0IG5vZGUgb2YgZGVmYXVsdHNbbmFtZV0pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5vZGUuY2xvbmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKG5vZGUuY2xvbmUoKSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmQobm9kZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbbmFtZV0gPSBkZWZhdWx0c1tuYW1lXVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVycm9yKG1lc3NhZ2UsIG9wdHMgPSB7fSkge1xuICAgIGlmICh0aGlzLnNvdXJjZSkge1xuICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gdGhpcy5yYW5nZUJ5KG9wdHMpXG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2UuaW5wdXQuZXJyb3IoXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHsgbGluZTogc3RhcnQubGluZSwgY29sdW1uOiBzdGFydC5jb2x1bW4gfSxcbiAgICAgICAgeyBsaW5lOiBlbmQubGluZSwgY29sdW1uOiBlbmQuY29sdW1uIH0sXG4gICAgICAgIG9wdHNcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDc3NTeW50YXhFcnJvcihtZXNzYWdlKVxuICB9XG5cbiAgd2FybihyZXN1bHQsIHRleHQsIG9wdHMpIHtcbiAgICBsZXQgZGF0YSA9IHsgbm9kZTogdGhpcyB9XG4gICAgZm9yIChsZXQgaSBpbiBvcHRzKSBkYXRhW2ldID0gb3B0c1tpXVxuICAgIHJldHVybiByZXN1bHQud2Fybih0ZXh0LCBkYXRhKVxuICB9XG5cbiAgcmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcylcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdG9TdHJpbmcoc3RyaW5naWZpZXIgPSBzdHJpbmdpZnkpIHtcbiAgICBpZiAoc3RyaW5naWZpZXIuc3RyaW5naWZ5KSBzdHJpbmdpZmllciA9IHN0cmluZ2lmaWVyLnN0cmluZ2lmeVxuICAgIGxldCByZXN1bHQgPSAnJ1xuICAgIHN0cmluZ2lmaWVyKHRoaXMsIGkgPT4ge1xuICAgICAgcmVzdWx0ICs9IGlcbiAgICB9KVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGFzc2lnbihvdmVycmlkZXMgPSB7fSkge1xuICAgIGZvciAobGV0IG5hbWUgaW4gb3ZlcnJpZGVzKSB7XG4gICAgICB0aGlzW25hbWVdID0gb3ZlcnJpZGVzW25hbWVdXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBjbG9uZShvdmVycmlkZXMgPSB7fSkge1xuICAgIGxldCBjbG9uZWQgPSBjbG9uZU5vZGUodGhpcylcbiAgICBmb3IgKGxldCBuYW1lIGluIG92ZXJyaWRlcykge1xuICAgICAgY2xvbmVkW25hbWVdID0gb3ZlcnJpZGVzW25hbWVdXG4gICAgfVxuICAgIHJldHVybiBjbG9uZWRcbiAgfVxuXG4gIGNsb25lQmVmb3JlKG92ZXJyaWRlcyA9IHt9KSB7XG4gICAgbGV0IGNsb25lZCA9IHRoaXMuY2xvbmUob3ZlcnJpZGVzKVxuICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCBjbG9uZWQpXG4gICAgcmV0dXJuIGNsb25lZFxuICB9XG5cbiAgY2xvbmVBZnRlcihvdmVycmlkZXMgPSB7fSkge1xuICAgIGxldCBjbG9uZWQgPSB0aGlzLmNsb25lKG92ZXJyaWRlcylcbiAgICB0aGlzLnBhcmVudC5pbnNlcnRBZnRlcih0aGlzLCBjbG9uZWQpXG4gICAgcmV0dXJuIGNsb25lZFxuICB9XG5cbiAgcmVwbGFjZVdpdGgoLi4ubm9kZXMpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIGxldCBib29rbWFyayA9IHRoaXNcbiAgICAgIGxldCBmb3VuZFNlbGYgPSBmYWxzZVxuICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcykge1xuICAgICAgICAgIGZvdW5kU2VsZiA9IHRydWVcbiAgICAgICAgfSBlbHNlIGlmIChmb3VuZFNlbGYpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRBZnRlcihib29rbWFyaywgbm9kZSlcbiAgICAgICAgICBib29rbWFyayA9IG5vZGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUoYm9va21hcmssIG5vZGUpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFmb3VuZFNlbGYpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBuZXh0KCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHJldHVybiB1bmRlZmluZWRcbiAgICBsZXQgaW5kZXggPSB0aGlzLnBhcmVudC5pbmRleCh0aGlzKVxuICAgIHJldHVybiB0aGlzLnBhcmVudC5ub2Rlc1tpbmRleCArIDFdXG4gIH1cblxuICBwcmV2KCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHJldHVybiB1bmRlZmluZWRcbiAgICBsZXQgaW5kZXggPSB0aGlzLnBhcmVudC5pbmRleCh0aGlzKVxuICAgIHJldHVybiB0aGlzLnBhcmVudC5ub2Rlc1tpbmRleCAtIDFdXG4gIH1cblxuICBiZWZvcmUoYWRkKSB7XG4gICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMsIGFkZClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgYWZ0ZXIoYWRkKSB7XG4gICAgdGhpcy5wYXJlbnQuaW5zZXJ0QWZ0ZXIodGhpcywgYWRkKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByb290KCkge1xuICAgIGxldCByZXN1bHQgPSB0aGlzXG4gICAgd2hpbGUgKHJlc3VsdC5wYXJlbnQgJiYgcmVzdWx0LnBhcmVudC50eXBlICE9PSAnZG9jdW1lbnQnKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQucGFyZW50XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIHJhdyhwcm9wLCBkZWZhdWx0VHlwZSkge1xuICAgIGxldCBzdHIgPSBuZXcgU3RyaW5naWZpZXIoKVxuICAgIHJldHVybiBzdHIucmF3KHRoaXMsIHByb3AsIGRlZmF1bHRUeXBlKVxuICB9XG5cbiAgY2xlYW5SYXdzKGtlZXBCZXR3ZWVuKSB7XG4gICAgZGVsZXRlIHRoaXMucmF3cy5iZWZvcmVcbiAgICBkZWxldGUgdGhpcy5yYXdzLmFmdGVyXG4gICAgaWYgKCFrZWVwQmV0d2VlbikgZGVsZXRlIHRoaXMucmF3cy5iZXR3ZWVuXG4gIH1cblxuICB0b0pTT04oXywgaW5wdXRzKSB7XG4gICAgbGV0IGZpeGVkID0ge31cbiAgICBsZXQgZW1pdElucHV0cyA9IGlucHV0cyA9PSBudWxsXG4gICAgaW5wdXRzID0gaW5wdXRzIHx8IG5ldyBNYXAoKVxuICAgIGxldCBpbnB1dHNOZXh0SW5kZXggPSAwXG5cbiAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMpIHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIG5hbWUpKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDIgKi9cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lID09PSAncGFyZW50JyB8fCBuYW1lID09PSAncHJveHlDYWNoZScpIGNvbnRpbnVlXG4gICAgICBsZXQgdmFsdWUgPSB0aGlzW25hbWVdXG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBmaXhlZFtuYW1lXSA9IHZhbHVlLm1hcChpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGkgPT09ICdvYmplY3QnICYmIGkudG9KU09OKSB7XG4gICAgICAgICAgICByZXR1cm4gaS50b0pTT04obnVsbCwgaW5wdXRzKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS50b0pTT04pIHtcbiAgICAgICAgZml4ZWRbbmFtZV0gPSB2YWx1ZS50b0pTT04obnVsbCwgaW5wdXRzKVxuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnc291cmNlJykge1xuICAgICAgICBsZXQgaW5wdXRJZCA9IGlucHV0cy5nZXQodmFsdWUuaW5wdXQpXG4gICAgICAgIGlmIChpbnB1dElkID09IG51bGwpIHtcbiAgICAgICAgICBpbnB1dElkID0gaW5wdXRzTmV4dEluZGV4XG4gICAgICAgICAgaW5wdXRzLnNldCh2YWx1ZS5pbnB1dCwgaW5wdXRzTmV4dEluZGV4KVxuICAgICAgICAgIGlucHV0c05leHRJbmRleCsrXG4gICAgICAgIH1cbiAgICAgICAgZml4ZWRbbmFtZV0gPSB7XG4gICAgICAgICAgaW5wdXRJZCxcbiAgICAgICAgICBzdGFydDogdmFsdWUuc3RhcnQsXG4gICAgICAgICAgZW5kOiB2YWx1ZS5lbmRcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZml4ZWRbbmFtZV0gPSB2YWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbWl0SW5wdXRzKSB7XG4gICAgICBmaXhlZC5pbnB1dHMgPSBbLi4uaW5wdXRzLmtleXMoKV0ubWFwKGlucHV0ID0+IGlucHV0LnRvSlNPTigpKVxuICAgIH1cblxuICAgIHJldHVybiBmaXhlZFxuICB9XG5cbiAgcG9zaXRpb25JbnNpZGUoaW5kZXgpIHtcbiAgICBsZXQgc3RyaW5nID0gdGhpcy50b1N0cmluZygpXG4gICAgbGV0IGNvbHVtbiA9IHRoaXMuc291cmNlLnN0YXJ0LmNvbHVtblxuICAgIGxldCBsaW5lID0gdGhpcy5zb3VyY2Uuc3RhcnQubGluZVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICBpZiAoc3RyaW5nW2ldID09PSAnXFxuJykge1xuICAgICAgICBjb2x1bW4gPSAxXG4gICAgICAgIGxpbmUgKz0gMVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sdW1uICs9IDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBsaW5lLCBjb2x1bW4gfVxuICB9XG5cbiAgcG9zaXRpb25CeShvcHRzKSB7XG4gICAgbGV0IHBvcyA9IHRoaXMuc291cmNlLnN0YXJ0XG4gICAgaWYgKG9wdHMuaW5kZXgpIHtcbiAgICAgIHBvcyA9IHRoaXMucG9zaXRpb25JbnNpZGUob3B0cy5pbmRleClcbiAgICB9IGVsc2UgaWYgKG9wdHMud29yZCkge1xuICAgICAgbGV0IGluZGV4ID0gdGhpcy50b1N0cmluZygpLmluZGV4T2Yob3B0cy53b3JkKVxuICAgICAgaWYgKGluZGV4ICE9PSAtMSkgcG9zID0gdGhpcy5wb3NpdGlvbkluc2lkZShpbmRleClcbiAgICB9XG4gICAgcmV0dXJuIHBvc1xuICB9XG5cbiAgcmFuZ2VCeShvcHRzKSB7XG4gICAgbGV0IHN0YXJ0ID0ge1xuICAgICAgbGluZTogdGhpcy5zb3VyY2Uuc3RhcnQubGluZSxcbiAgICAgIGNvbHVtbjogdGhpcy5zb3VyY2Uuc3RhcnQuY29sdW1uXG4gICAgfVxuICAgIGxldCBlbmQgPSB0aGlzLnNvdXJjZS5lbmRcbiAgICAgID8ge1xuICAgICAgICAgIGxpbmU6IHRoaXMuc291cmNlLmVuZC5saW5lLFxuICAgICAgICAgIGNvbHVtbjogdGhpcy5zb3VyY2UuZW5kLmNvbHVtbiArIDFcbiAgICAgICAgfVxuICAgICAgOiB7XG4gICAgICAgICAgbGluZTogc3RhcnQubGluZSxcbiAgICAgICAgICBjb2x1bW46IHN0YXJ0LmNvbHVtbiArIDFcbiAgICAgICAgfVxuXG4gICAgaWYgKG9wdHMud29yZCkge1xuICAgICAgbGV0IGluZGV4ID0gdGhpcy50b1N0cmluZygpLmluZGV4T2Yob3B0cy53b3JkKVxuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBzdGFydCA9IHRoaXMucG9zaXRpb25JbnNpZGUoaW5kZXgpXG4gICAgICAgIGVuZCA9IHRoaXMucG9zaXRpb25JbnNpZGUoaW5kZXggKyBvcHRzLndvcmQubGVuZ3RoKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0cy5zdGFydCkge1xuICAgICAgICBzdGFydCA9IHtcbiAgICAgICAgICBsaW5lOiBvcHRzLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgY29sdW1uOiBvcHRzLnN0YXJ0LmNvbHVtblxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9wdHMuaW5kZXgpIHtcbiAgICAgICAgc3RhcnQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKG9wdHMuaW5kZXgpXG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLmVuZCkge1xuICAgICAgICBlbmQgPSB7XG4gICAgICAgICAgbGluZTogb3B0cy5lbmQubGluZSxcbiAgICAgICAgICBjb2x1bW46IG9wdHMuZW5kLmNvbHVtblxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9wdHMuZW5kSW5kZXgpIHtcbiAgICAgICAgZW5kID0gdGhpcy5wb3NpdGlvbkluc2lkZShvcHRzLmVuZEluZGV4KVxuICAgICAgfSBlbHNlIGlmIChvcHRzLmluZGV4KSB7XG4gICAgICAgIGVuZCA9IHRoaXMucG9zaXRpb25JbnNpZGUob3B0cy5pbmRleCArIDEpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgZW5kLmxpbmUgPCBzdGFydC5saW5lIHx8XG4gICAgICAoZW5kLmxpbmUgPT09IHN0YXJ0LmxpbmUgJiYgZW5kLmNvbHVtbiA8PSBzdGFydC5jb2x1bW4pXG4gICAgKSB7XG4gICAgICBlbmQgPSB7IGxpbmU6IHN0YXJ0LmxpbmUsIGNvbHVtbjogc3RhcnQuY29sdW1uICsgMSB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9XG4gIH1cblxuICBnZXRQcm94eVByb2Nlc3NvcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0KG5vZGUsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgIGlmIChub2RlW3Byb3BdID09PSB2YWx1ZSkgcmV0dXJuIHRydWVcbiAgICAgICAgbm9kZVtwcm9wXSA9IHZhbHVlXG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcm9wID09PSAncHJvcCcgfHxcbiAgICAgICAgICBwcm9wID09PSAndmFsdWUnIHx8XG4gICAgICAgICAgcHJvcCA9PT0gJ25hbWUnIHx8XG4gICAgICAgICAgcHJvcCA9PT0gJ3BhcmFtcycgfHxcbiAgICAgICAgICBwcm9wID09PSAnaW1wb3J0YW50JyB8fFxuICAgICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgcHJvcCA9PT0gJ3RleHQnXG4gICAgICAgICkge1xuICAgICAgICAgIG5vZGUubWFya0RpcnR5KClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSxcblxuICAgICAgZ2V0KG5vZGUsIHByb3ApIHtcbiAgICAgICAgaWYgKHByb3AgPT09ICdwcm94eU9mJykge1xuICAgICAgICAgIHJldHVybiBub2RlXG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gJ3Jvb3QnKSB7XG4gICAgICAgICAgcmV0dXJuICgpID0+IG5vZGUucm9vdCgpLnRvUHJveHkoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBub2RlW3Byb3BdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0b1Byb3h5KCkge1xuICAgIGlmICghdGhpcy5wcm94eUNhY2hlKSB7XG4gICAgICB0aGlzLnByb3h5Q2FjaGUgPSBuZXcgUHJveHkodGhpcywgdGhpcy5nZXRQcm94eVByb2Nlc3NvcigpKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm94eUNhY2hlXG4gIH1cblxuICBhZGRUb0Vycm9yKGVycm9yKSB7XG4gICAgZXJyb3IucG9zdGNzc05vZGUgPSB0aGlzXG4gICAgaWYgKGVycm9yLnN0YWNrICYmIHRoaXMuc291cmNlICYmIC9cXG5cXHN7NH1hdCAvLnRlc3QoZXJyb3Iuc3RhY2spKSB7XG4gICAgICBsZXQgcyA9IHRoaXMuc291cmNlXG4gICAgICBlcnJvci5zdGFjayA9IGVycm9yLnN0YWNrLnJlcGxhY2UoXG4gICAgICAgIC9cXG5cXHN7NH1hdCAvLFxuICAgICAgICBgJCYke3MuaW5wdXQuZnJvbX06JHtzLnN0YXJ0LmxpbmV9OiR7cy5zdGFydC5jb2x1bW59JCZgXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBlcnJvclxuICB9XG5cbiAgbWFya0RpcnR5KCkge1xuICAgIGlmICh0aGlzW2lzQ2xlYW5dKSB7XG4gICAgICB0aGlzW2lzQ2xlYW5dID0gZmFsc2VcbiAgICAgIGxldCBuZXh0ID0gdGhpc1xuICAgICAgd2hpbGUgKChuZXh0ID0gbmV4dC5wYXJlbnQpKSB7XG4gICAgICAgIG5leHRbaXNDbGVhbl0gPSBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBwcm94eU9mKCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlXG5Ob2RlLmRlZmF1bHQgPSBOb2RlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/node.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/parse.js":
/*!*******************************************!*\
  !*** ./node_modules/postcss/lib/parse.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Container = __webpack_require__(/*! ./container */ \"./node_modules/postcss/lib/container.js\")\nlet Parser = __webpack_require__(/*! ./parser */ \"./node_modules/postcss/lib/parser.js\")\nlet Input = __webpack_require__(/*! ./input */ \"./node_modules/postcss/lib/input.js\")\n\nfunction parse(css, opts) {\n  let input = new Input(css, opts)\n  let parser = new Parser(input)\n  try {\n    parser.parse()\n  } catch (e) {\n    if (true) {\n      if (e.name === 'CssSyntaxError' && opts && opts.from) {\n        if (/\\.scss$/i.test(opts.from)) {\n          e.message +=\n            '\\nYou tried to parse SCSS with ' +\n            'the standard CSS parser; ' +\n            'try again with the postcss-scss parser'\n        } else if (/\\.sass/i.test(opts.from)) {\n          e.message +=\n            '\\nYou tried to parse Sass with ' +\n            'the standard CSS parser; ' +\n            'try again with the postcss-sass parser'\n        } else if (/\\.less$/i.test(opts.from)) {\n          e.message +=\n            '\\nYou tried to parse Less with ' +\n            'the standard CSS parser; ' +\n            'try again with the postcss-less parser'\n        }\n      }\n    }\n    throw e\n  }\n\n  return parser.root\n}\n\nmodule.exports = parse\nparse.default = parse\n\nContainer.registerParse(parse)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcGFyc2UuanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZ0JBQWdCLG1CQUFPLENBQUMsNERBQWE7QUFDckMsYUFBYSxtQkFBTyxDQUFDLHNEQUFVO0FBQy9CLFlBQVksbUJBQU8sQ0FBQyxvREFBUzs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL3BhcnNlLmpzPzM2MzMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmxldCBDb250YWluZXIgPSByZXF1aXJlKCcuL2NvbnRhaW5lcicpXG5sZXQgUGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXInKVxubGV0IElucHV0ID0gcmVxdWlyZSgnLi9pbnB1dCcpXG5cbmZ1bmN0aW9uIHBhcnNlKGNzcywgb3B0cykge1xuICBsZXQgaW5wdXQgPSBuZXcgSW5wdXQoY3NzLCBvcHRzKVxuICBsZXQgcGFyc2VyID0gbmV3IFBhcnNlcihpbnB1dClcbiAgdHJ5IHtcbiAgICBwYXJzZXIucGFyc2UoKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChlLm5hbWUgPT09ICdDc3NTeW50YXhFcnJvcicgJiYgb3B0cyAmJiBvcHRzLmZyb20pIHtcbiAgICAgICAgaWYgKC9cXC5zY3NzJC9pLnRlc3Qob3B0cy5mcm9tKSkge1xuICAgICAgICAgIGUubWVzc2FnZSArPVxuICAgICAgICAgICAgJ1xcbllvdSB0cmllZCB0byBwYXJzZSBTQ1NTIHdpdGggJyArXG4gICAgICAgICAgICAndGhlIHN0YW5kYXJkIENTUyBwYXJzZXI7ICcgK1xuICAgICAgICAgICAgJ3RyeSBhZ2FpbiB3aXRoIHRoZSBwb3N0Y3NzLXNjc3MgcGFyc2VyJ1xuICAgICAgICB9IGVsc2UgaWYgKC9cXC5zYXNzL2kudGVzdChvcHRzLmZyb20pKSB7XG4gICAgICAgICAgZS5tZXNzYWdlICs9XG4gICAgICAgICAgICAnXFxuWW91IHRyaWVkIHRvIHBhcnNlIFNhc3Mgd2l0aCAnICtcbiAgICAgICAgICAgICd0aGUgc3RhbmRhcmQgQ1NTIHBhcnNlcjsgJyArXG4gICAgICAgICAgICAndHJ5IGFnYWluIHdpdGggdGhlIHBvc3Rjc3Mtc2FzcyBwYXJzZXInXG4gICAgICAgIH0gZWxzZSBpZiAoL1xcLmxlc3MkL2kudGVzdChvcHRzLmZyb20pKSB7XG4gICAgICAgICAgZS5tZXNzYWdlICs9XG4gICAgICAgICAgICAnXFxuWW91IHRyaWVkIHRvIHBhcnNlIExlc3Mgd2l0aCAnICtcbiAgICAgICAgICAgICd0aGUgc3RhbmRhcmQgQ1NTIHBhcnNlcjsgJyArXG4gICAgICAgICAgICAndHJ5IGFnYWluIHdpdGggdGhlIHBvc3Rjc3MtbGVzcyBwYXJzZXInXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgZVxuICB9XG5cbiAgcmV0dXJuIHBhcnNlci5yb290XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VcbnBhcnNlLmRlZmF1bHQgPSBwYXJzZVxuXG5Db250YWluZXIucmVnaXN0ZXJQYXJzZShwYXJzZSlcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/parse.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/parser.js":
/*!********************************************!*\
  !*** ./node_modules/postcss/lib/parser.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Declaration = __webpack_require__(/*! ./declaration */ \"./node_modules/postcss/lib/declaration.js\")\nlet tokenizer = __webpack_require__(/*! ./tokenize */ \"./node_modules/postcss/lib/tokenize.js\")\nlet Comment = __webpack_require__(/*! ./comment */ \"./node_modules/postcss/lib/comment.js\")\nlet AtRule = __webpack_require__(/*! ./at-rule */ \"./node_modules/postcss/lib/at-rule.js\")\nlet Root = __webpack_require__(/*! ./root */ \"./node_modules/postcss/lib/root.js\")\nlet Rule = __webpack_require__(/*! ./rule */ \"./node_modules/postcss/lib/rule.js\")\n\nconst SAFE_COMMENT_NEIGHBOR = {\n  empty: true,\n  space: true\n}\n\nfunction findLastWithPosition(tokens) {\n  for (let i = tokens.length - 1; i >= 0; i--) {\n    let token = tokens[i]\n    let pos = token[3] || token[2]\n    if (pos) return pos\n  }\n}\n\nclass Parser {\n  constructor(input) {\n    this.input = input\n\n    this.root = new Root()\n    this.current = this.root\n    this.spaces = ''\n    this.semicolon = false\n    this.customProperty = false\n\n    this.createTokenizer()\n    this.root.source = { input, start: { offset: 0, line: 1, column: 1 } }\n  }\n\n  createTokenizer() {\n    this.tokenizer = tokenizer(this.input)\n  }\n\n  parse() {\n    let token\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken()\n\n      switch (token[0]) {\n        case 'space':\n          this.spaces += token[1]\n          break\n\n        case ';':\n          this.freeSemicolon(token)\n          break\n\n        case '}':\n          this.end(token)\n          break\n\n        case 'comment':\n          this.comment(token)\n          break\n\n        case 'at-word':\n          this.atrule(token)\n          break\n\n        case '{':\n          this.emptyRule(token)\n          break\n\n        default:\n          this.other(token)\n          break\n      }\n    }\n    this.endFile()\n  }\n\n  comment(token) {\n    let node = new Comment()\n    this.init(node, token[2])\n    node.source.end = this.getPosition(token[3] || token[2])\n\n    let text = token[1].slice(2, -2)\n    if (/^\\s*$/.test(text)) {\n      node.text = ''\n      node.raws.left = text\n      node.raws.right = ''\n    } else {\n      let match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/)\n      node.text = match[2]\n      node.raws.left = match[1]\n      node.raws.right = match[3]\n    }\n  }\n\n  emptyRule(token) {\n    let node = new Rule()\n    this.init(node, token[2])\n    node.selector = ''\n    node.raws.between = ''\n    this.current = node\n  }\n\n  other(start) {\n    let end = false\n    let type = null\n    let colon = false\n    let bracket = null\n    let brackets = []\n    let customProperty = start[1].startsWith('--')\n\n    let tokens = []\n    let token = start\n    while (token) {\n      type = token[0]\n      tokens.push(token)\n\n      if (type === '(' || type === '[') {\n        if (!bracket) bracket = token\n        brackets.push(type === '(' ? ')' : ']')\n      } else if (customProperty && colon && type === '{') {\n        if (!bracket) bracket = token\n        brackets.push('}')\n      } else if (brackets.length === 0) {\n        if (type === ';') {\n          if (colon) {\n            this.decl(tokens, customProperty)\n            return\n          } else {\n            break\n          }\n        } else if (type === '{') {\n          this.rule(tokens)\n          return\n        } else if (type === '}') {\n          this.tokenizer.back(tokens.pop())\n          end = true\n          break\n        } else if (type === ':') {\n          colon = true\n        }\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop()\n        if (brackets.length === 0) bracket = null\n      }\n\n      token = this.tokenizer.nextToken()\n    }\n\n    if (this.tokenizer.endOfFile()) end = true\n    if (brackets.length > 0) this.unclosedBracket(bracket)\n\n    if (end && colon) {\n      if (!customProperty) {\n        while (tokens.length) {\n          token = tokens[tokens.length - 1][0]\n          if (token !== 'space' && token !== 'comment') break\n          this.tokenizer.back(tokens.pop())\n        }\n      }\n      this.decl(tokens, customProperty)\n    } else {\n      this.unknownWord(tokens)\n    }\n  }\n\n  rule(tokens) {\n    tokens.pop()\n\n    let node = new Rule()\n    this.init(node, tokens[0][2])\n\n    node.raws.between = this.spacesAndCommentsFromEnd(tokens)\n    this.raw(node, 'selector', tokens)\n    this.current = node\n  }\n\n  decl(tokens, customProperty) {\n    let node = new Declaration()\n    this.init(node, tokens[0][2])\n\n    let last = tokens[tokens.length - 1]\n    if (last[0] === ';') {\n      this.semicolon = true\n      tokens.pop()\n    }\n\n    node.source.end = this.getPosition(\n      last[3] || last[2] || findLastWithPosition(tokens)\n    )\n\n    while (tokens[0][0] !== 'word') {\n      if (tokens.length === 1) this.unknownWord(tokens)\n      node.raws.before += tokens.shift()[1]\n    }\n    node.source.start = this.getPosition(tokens[0][2])\n\n    node.prop = ''\n    while (tokens.length) {\n      let type = tokens[0][0]\n      if (type === ':' || type === 'space' || type === 'comment') {\n        break\n      }\n      node.prop += tokens.shift()[1]\n    }\n\n    node.raws.between = ''\n\n    let token\n    while (tokens.length) {\n      token = tokens.shift()\n\n      if (token[0] === ':') {\n        node.raws.between += token[1]\n        break\n      } else {\n        if (token[0] === 'word' && /\\w/.test(token[1])) {\n          this.unknownWord([token])\n        }\n        node.raws.between += token[1]\n      }\n    }\n\n    if (node.prop[0] === '_' || node.prop[0] === '*') {\n      node.raws.before += node.prop[0]\n      node.prop = node.prop.slice(1)\n    }\n\n    let firstSpaces = []\n    let next\n    while (tokens.length) {\n      next = tokens[0][0]\n      if (next !== 'space' && next !== 'comment') break\n      firstSpaces.push(tokens.shift())\n    }\n\n    this.precheckMissedSemicolon(tokens)\n\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i]\n      if (token[1].toLowerCase() === '!important') {\n        node.important = true\n        let string = this.stringFrom(tokens, i)\n        string = this.spacesFromEnd(tokens) + string\n        if (string !== ' !important') node.raws.important = string\n        break\n      } else if (token[1].toLowerCase() === 'important') {\n        let cache = tokens.slice(0)\n        let str = ''\n        for (let j = i; j > 0; j--) {\n          let type = cache[j][0]\n          if (str.trim().indexOf('!') === 0 && type !== 'space') {\n            break\n          }\n          str = cache.pop()[1] + str\n        }\n        if (str.trim().indexOf('!') === 0) {\n          node.important = true\n          node.raws.important = str\n          tokens = cache\n        }\n      }\n\n      if (token[0] !== 'space' && token[0] !== 'comment') {\n        break\n      }\n    }\n\n    let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment')\n\n    if (hasWord) {\n      node.raws.between += firstSpaces.map(i => i[1]).join('')\n      firstSpaces = []\n    }\n    this.raw(node, 'value', firstSpaces.concat(tokens), customProperty)\n\n    if (node.value.includes(':') && !customProperty) {\n      this.checkMissedSemicolon(tokens)\n    }\n  }\n\n  atrule(token) {\n    let node = new AtRule()\n    node.name = token[1].slice(1)\n    if (node.name === '') {\n      this.unnamedAtrule(node, token)\n    }\n    this.init(node, token[2])\n\n    let type\n    let prev\n    let shift\n    let last = false\n    let open = false\n    let params = []\n    let brackets = []\n\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken()\n      type = token[0]\n\n      if (type === '(' || type === '[') {\n        brackets.push(type === '(' ? ')' : ']')\n      } else if (type === '{' && brackets.length > 0) {\n        brackets.push('}')\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop()\n      }\n\n      if (brackets.length === 0) {\n        if (type === ';') {\n          node.source.end = this.getPosition(token[2])\n          this.semicolon = true\n          break\n        } else if (type === '{') {\n          open = true\n          break\n        } else if (type === '}') {\n          if (params.length > 0) {\n            shift = params.length - 1\n            prev = params[shift]\n            while (prev && prev[0] === 'space') {\n              prev = params[--shift]\n            }\n            if (prev) {\n              node.source.end = this.getPosition(prev[3] || prev[2])\n            }\n          }\n          this.end(token)\n          break\n        } else {\n          params.push(token)\n        }\n      } else {\n        params.push(token)\n      }\n\n      if (this.tokenizer.endOfFile()) {\n        last = true\n        break\n      }\n    }\n\n    node.raws.between = this.spacesAndCommentsFromEnd(params)\n    if (params.length) {\n      node.raws.afterName = this.spacesAndCommentsFromStart(params)\n      this.raw(node, 'params', params)\n      if (last) {\n        token = params[params.length - 1]\n        node.source.end = this.getPosition(token[3] || token[2])\n        this.spaces = node.raws.between\n        node.raws.between = ''\n      }\n    } else {\n      node.raws.afterName = ''\n      node.params = ''\n    }\n\n    if (open) {\n      node.nodes = []\n      this.current = node\n    }\n  }\n\n  end(token) {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon\n    }\n    this.semicolon = false\n\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\n    this.spaces = ''\n\n    if (this.current.parent) {\n      this.current.source.end = this.getPosition(token[2])\n      this.current = this.current.parent\n    } else {\n      this.unexpectedClose(token)\n    }\n  }\n\n  endFile() {\n    if (this.current.parent) this.unclosedBlock()\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon\n    }\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\n  }\n\n  freeSemicolon(token) {\n    this.spaces += token[1]\n    if (this.current.nodes) {\n      let prev = this.current.nodes[this.current.nodes.length - 1]\n      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\n        prev.raws.ownSemicolon = this.spaces\n        this.spaces = ''\n      }\n    }\n  }\n\n  // Helpers\n\n  getPosition(offset) {\n    let pos = this.input.fromOffset(offset)\n    return {\n      offset,\n      line: pos.line,\n      column: pos.col\n    }\n  }\n\n  init(node, offset) {\n    this.current.push(node)\n    node.source = {\n      start: this.getPosition(offset),\n      input: this.input\n    }\n    node.raws.before = this.spaces\n    this.spaces = ''\n    if (node.type !== 'comment') this.semicolon = false\n  }\n\n  raw(node, prop, tokens, customProperty) {\n    let token, type\n    let length = tokens.length\n    let value = ''\n    let clean = true\n    let next, prev\n\n    for (let i = 0; i < length; i += 1) {\n      token = tokens[i]\n      type = token[0]\n      if (type === 'space' && i === length - 1 && !customProperty) {\n        clean = false\n      } else if (type === 'comment') {\n        prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty'\n        next = tokens[i + 1] ? tokens[i + 1][0] : 'empty'\n        if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {\n          if (value.slice(-1) === ',') {\n            clean = false\n          } else {\n            value += token[1]\n          }\n        } else {\n          clean = false\n        }\n      } else {\n        value += token[1]\n      }\n    }\n    if (!clean) {\n      let raw = tokens.reduce((all, i) => all + i[1], '')\n      node.raws[prop] = { value, raw }\n    }\n    node[prop] = value\n  }\n\n  spacesAndCommentsFromEnd(tokens) {\n    let lastTokenType\n    let spaces = ''\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0]\n      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break\n      spaces = tokens.pop()[1] + spaces\n    }\n    return spaces\n  }\n\n  spacesAndCommentsFromStart(tokens) {\n    let next\n    let spaces = ''\n    while (tokens.length) {\n      next = tokens[0][0]\n      if (next !== 'space' && next !== 'comment') break\n      spaces += tokens.shift()[1]\n    }\n    return spaces\n  }\n\n  spacesFromEnd(tokens) {\n    let lastTokenType\n    let spaces = ''\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0]\n      if (lastTokenType !== 'space') break\n      spaces = tokens.pop()[1] + spaces\n    }\n    return spaces\n  }\n\n  stringFrom(tokens, from) {\n    let result = ''\n    for (let i = from; i < tokens.length; i++) {\n      result += tokens[i][1]\n    }\n    tokens.splice(from, tokens.length - from)\n    return result\n  }\n\n  colon(tokens) {\n    let brackets = 0\n    let token, type, prev\n    for (let [i, element] of tokens.entries()) {\n      token = element\n      type = token[0]\n\n      if (type === '(') {\n        brackets += 1\n      }\n      if (type === ')') {\n        brackets -= 1\n      }\n      if (brackets === 0 && type === ':') {\n        if (!prev) {\n          this.doubleColon(token)\n        } else if (prev[0] === 'word' && prev[1] === 'progid') {\n          continue\n        } else {\n          return i\n        }\n      }\n\n      prev = token\n    }\n    return false\n  }\n\n  // Errors\n\n  unclosedBracket(bracket) {\n    throw this.input.error(\n      'Unclosed bracket',\n      { offset: bracket[2] },\n      { offset: bracket[2] + 1 }\n    )\n  }\n\n  unknownWord(tokens) {\n    throw this.input.error(\n      'Unknown word',\n      { offset: tokens[0][2] },\n      { offset: tokens[0][2] + tokens[0][1].length }\n    )\n  }\n\n  unexpectedClose(token) {\n    throw this.input.error(\n      'Unexpected }',\n      { offset: token[2] },\n      { offset: token[2] + 1 }\n    )\n  }\n\n  unclosedBlock() {\n    let pos = this.current.source.start\n    throw this.input.error('Unclosed block', pos.line, pos.column)\n  }\n\n  doubleColon(token) {\n    throw this.input.error(\n      'Double colon',\n      { offset: token[2] },\n      { offset: token[2] + token[1].length }\n    )\n  }\n\n  unnamedAtrule(node, token) {\n    throw this.input.error(\n      'At-rule without name',\n      { offset: token[2] },\n      { offset: token[2] + token[1].length }\n    )\n  }\n\n  precheckMissedSemicolon(/* tokens */) {\n    // Hook for Safe Parser\n  }\n\n  checkMissedSemicolon(tokens) {\n    let colon = this.colon(tokens)\n    if (colon === false) return\n\n    let founded = 0\n    let token\n    for (let j = colon - 1; j >= 0; j--) {\n      token = tokens[j]\n      if (token[0] !== 'space') {\n        founded += 1\n        if (founded === 2) break\n      }\n    }\n    // If the token is a word, e.g. `!important`, `red` or any other valid property's value.\n    // Then we need to return the colon after that word token. [3] is the \"end\" colon of that word.\n    // And because we need it after that one we do +1 to get the next one.\n    throw this.input.error(\n      'Missed semicolon',\n      token[0] === 'word' ? token[3] + 1 : token[2]\n    )\n  }\n}\n\nmodule.exports = Parser\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcGFyc2VyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGtCQUFrQixtQkFBTyxDQUFDLGdFQUFlO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLDBEQUFZO0FBQ3BDLGNBQWMsbUJBQU8sQ0FBQyx3REFBVztBQUNqQyxhQUFhLG1CQUFPLENBQUMsd0RBQVc7QUFDaEMsV0FBVyxtQkFBTyxDQUFDLGtEQUFRO0FBQzNCLFdBQVcsbUJBQU8sQ0FBQyxrREFBUTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0NBQStDO0FBQ3ZEO0FBQ0Esd0JBQXdCO0FBQ3hCLFFBQVE7QUFDUix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBO0FBQ0EsVUFBVSxvQkFBb0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxvQkFBb0I7QUFDNUIsd0JBQXdCO0FBQ3hCLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9CQUFvQjtBQUM1QixRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNCQUFzQjtBQUM5QixRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLFFBQVEsa0JBQWtCO0FBQzFCLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzL2xpYi9wYXJzZXIuanM/ZTkzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubGV0IERlY2xhcmF0aW9uID0gcmVxdWlyZSgnLi9kZWNsYXJhdGlvbicpXG5sZXQgdG9rZW5pemVyID0gcmVxdWlyZSgnLi90b2tlbml6ZScpXG5sZXQgQ29tbWVudCA9IHJlcXVpcmUoJy4vY29tbWVudCcpXG5sZXQgQXRSdWxlID0gcmVxdWlyZSgnLi9hdC1ydWxlJylcbmxldCBSb290ID0gcmVxdWlyZSgnLi9yb290JylcbmxldCBSdWxlID0gcmVxdWlyZSgnLi9ydWxlJylcblxuY29uc3QgU0FGRV9DT01NRU5UX05FSUdIQk9SID0ge1xuICBlbXB0eTogdHJ1ZSxcbiAgc3BhY2U6IHRydWVcbn1cblxuZnVuY3Rpb24gZmluZExhc3RXaXRoUG9zaXRpb24odG9rZW5zKSB7XG4gIGZvciAobGV0IGkgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgdG9rZW4gPSB0b2tlbnNbaV1cbiAgICBsZXQgcG9zID0gdG9rZW5bM10gfHwgdG9rZW5bMl1cbiAgICBpZiAocG9zKSByZXR1cm4gcG9zXG4gIH1cbn1cblxuY2xhc3MgUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXRcblxuICAgIHRoaXMucm9vdCA9IG5ldyBSb290KClcbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnJvb3RcbiAgICB0aGlzLnNwYWNlcyA9ICcnXG4gICAgdGhpcy5zZW1pY29sb24gPSBmYWxzZVxuICAgIHRoaXMuY3VzdG9tUHJvcGVydHkgPSBmYWxzZVxuXG4gICAgdGhpcy5jcmVhdGVUb2tlbml6ZXIoKVxuICAgIHRoaXMucm9vdC5zb3VyY2UgPSB7IGlucHV0LCBzdGFydDogeyBvZmZzZXQ6IDAsIGxpbmU6IDEsIGNvbHVtbjogMSB9IH1cbiAgfVxuXG4gIGNyZWF0ZVRva2VuaXplcigpIHtcbiAgICB0aGlzLnRva2VuaXplciA9IHRva2VuaXplcih0aGlzLmlucHV0KVxuICB9XG5cbiAgcGFyc2UoKSB7XG4gICAgbGV0IHRva2VuXG4gICAgd2hpbGUgKCF0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSkge1xuICAgICAgdG9rZW4gPSB0aGlzLnRva2VuaXplci5uZXh0VG9rZW4oKVxuXG4gICAgICBzd2l0Y2ggKHRva2VuWzBdKSB7XG4gICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICB0aGlzLnNwYWNlcyArPSB0b2tlblsxXVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnOyc6XG4gICAgICAgICAgdGhpcy5mcmVlU2VtaWNvbG9uKHRva2VuKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnfSc6XG4gICAgICAgICAgdGhpcy5lbmQodG9rZW4pXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICB0aGlzLmNvbW1lbnQodG9rZW4pXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdhdC13b3JkJzpcbiAgICAgICAgICB0aGlzLmF0cnVsZSh0b2tlbilcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgIHRoaXMuZW1wdHlSdWxlKHRva2VuKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLm90aGVyKHRva2VuKVxuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZW5kRmlsZSgpXG4gIH1cblxuICBjb21tZW50KHRva2VuKSB7XG4gICAgbGV0IG5vZGUgPSBuZXcgQ29tbWVudCgpXG4gICAgdGhpcy5pbml0KG5vZGUsIHRva2VuWzJdKVxuICAgIG5vZGUuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bM10gfHwgdG9rZW5bMl0pXG5cbiAgICBsZXQgdGV4dCA9IHRva2VuWzFdLnNsaWNlKDIsIC0yKVxuICAgIGlmICgvXlxccyokLy50ZXN0KHRleHQpKSB7XG4gICAgICBub2RlLnRleHQgPSAnJ1xuICAgICAgbm9kZS5yYXdzLmxlZnQgPSB0ZXh0XG4gICAgICBub2RlLnJhd3MucmlnaHQgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbWF0Y2ggPSB0ZXh0Lm1hdGNoKC9eKFxccyopKFteXSpcXFMpKFxccyopJC8pXG4gICAgICBub2RlLnRleHQgPSBtYXRjaFsyXVxuICAgICAgbm9kZS5yYXdzLmxlZnQgPSBtYXRjaFsxXVxuICAgICAgbm9kZS5yYXdzLnJpZ2h0ID0gbWF0Y2hbM11cbiAgICB9XG4gIH1cblxuICBlbXB0eVJ1bGUodG9rZW4pIHtcbiAgICBsZXQgbm9kZSA9IG5ldyBSdWxlKClcbiAgICB0aGlzLmluaXQobm9kZSwgdG9rZW5bMl0pXG4gICAgbm9kZS5zZWxlY3RvciA9ICcnXG4gICAgbm9kZS5yYXdzLmJldHdlZW4gPSAnJ1xuICAgIHRoaXMuY3VycmVudCA9IG5vZGVcbiAgfVxuXG4gIG90aGVyKHN0YXJ0KSB7XG4gICAgbGV0IGVuZCA9IGZhbHNlXG4gICAgbGV0IHR5cGUgPSBudWxsXG4gICAgbGV0IGNvbG9uID0gZmFsc2VcbiAgICBsZXQgYnJhY2tldCA9IG51bGxcbiAgICBsZXQgYnJhY2tldHMgPSBbXVxuICAgIGxldCBjdXN0b21Qcm9wZXJ0eSA9IHN0YXJ0WzFdLnN0YXJ0c1dpdGgoJy0tJylcblxuICAgIGxldCB0b2tlbnMgPSBbXVxuICAgIGxldCB0b2tlbiA9IHN0YXJ0XG4gICAgd2hpbGUgKHRva2VuKSB7XG4gICAgICB0eXBlID0gdG9rZW5bMF1cbiAgICAgIHRva2Vucy5wdXNoKHRva2VuKVxuXG4gICAgICBpZiAodHlwZSA9PT0gJygnIHx8IHR5cGUgPT09ICdbJykge1xuICAgICAgICBpZiAoIWJyYWNrZXQpIGJyYWNrZXQgPSB0b2tlblxuICAgICAgICBicmFja2V0cy5wdXNoKHR5cGUgPT09ICcoJyA/ICcpJyA6ICddJylcbiAgICAgIH0gZWxzZSBpZiAoY3VzdG9tUHJvcGVydHkgJiYgY29sb24gJiYgdHlwZSA9PT0gJ3snKSB7XG4gICAgICAgIGlmICghYnJhY2tldCkgYnJhY2tldCA9IHRva2VuXG4gICAgICAgIGJyYWNrZXRzLnB1c2goJ30nKVxuICAgICAgfSBlbHNlIGlmIChicmFja2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICc7Jykge1xuICAgICAgICAgIGlmIChjb2xvbikge1xuICAgICAgICAgICAgdGhpcy5kZWNsKHRva2VucywgY3VzdG9tUHJvcGVydHkpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3snKSB7XG4gICAgICAgICAgdGhpcy5ydWxlKHRva2VucylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnfScpIHtcbiAgICAgICAgICB0aGlzLnRva2VuaXplci5iYWNrKHRva2Vucy5wb3AoKSlcbiAgICAgICAgICBlbmQgPSB0cnVlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnOicpIHtcbiAgICAgICAgICBjb2xvbiA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBicmFja2V0c1ticmFja2V0cy5sZW5ndGggLSAxXSkge1xuICAgICAgICBicmFja2V0cy5wb3AoKVxuICAgICAgICBpZiAoYnJhY2tldHMubGVuZ3RoID09PSAwKSBicmFja2V0ID0gbnVsbFxuICAgICAgfVxuXG4gICAgICB0b2tlbiA9IHRoaXMudG9rZW5pemVyLm5leHRUb2tlbigpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMudG9rZW5pemVyLmVuZE9mRmlsZSgpKSBlbmQgPSB0cnVlXG4gICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA+IDApIHRoaXMudW5jbG9zZWRCcmFja2V0KGJyYWNrZXQpXG5cbiAgICBpZiAoZW5kICYmIGNvbG9uKSB7XG4gICAgICBpZiAoIWN1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgIHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgdG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdWzBdXG4gICAgICAgICAgaWYgKHRva2VuICE9PSAnc3BhY2UnICYmIHRva2VuICE9PSAnY29tbWVudCcpIGJyZWFrXG4gICAgICAgICAgdGhpcy50b2tlbml6ZXIuYmFjayh0b2tlbnMucG9wKCkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZGVjbCh0b2tlbnMsIGN1c3RvbVByb3BlcnR5KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVua25vd25Xb3JkKHRva2VucylcbiAgICB9XG4gIH1cblxuICBydWxlKHRva2Vucykge1xuICAgIHRva2Vucy5wb3AoKVxuXG4gICAgbGV0IG5vZGUgPSBuZXcgUnVsZSgpXG4gICAgdGhpcy5pbml0KG5vZGUsIHRva2Vuc1swXVsyXSlcblxuICAgIG5vZGUucmF3cy5iZXR3ZWVuID0gdGhpcy5zcGFjZXNBbmRDb21tZW50c0Zyb21FbmQodG9rZW5zKVxuICAgIHRoaXMucmF3KG5vZGUsICdzZWxlY3RvcicsIHRva2VucylcbiAgICB0aGlzLmN1cnJlbnQgPSBub2RlXG4gIH1cblxuICBkZWNsKHRva2VucywgY3VzdG9tUHJvcGVydHkpIHtcbiAgICBsZXQgbm9kZSA9IG5ldyBEZWNsYXJhdGlvbigpXG4gICAgdGhpcy5pbml0KG5vZGUsIHRva2Vuc1swXVsyXSlcblxuICAgIGxldCBsYXN0ID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXVxuICAgIGlmIChsYXN0WzBdID09PSAnOycpIHtcbiAgICAgIHRoaXMuc2VtaWNvbG9uID0gdHJ1ZVxuICAgICAgdG9rZW5zLnBvcCgpXG4gICAgfVxuXG4gICAgbm9kZS5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbihcbiAgICAgIGxhc3RbM10gfHwgbGFzdFsyXSB8fCBmaW5kTGFzdFdpdGhQb3NpdGlvbih0b2tlbnMpXG4gICAgKVxuXG4gICAgd2hpbGUgKHRva2Vuc1swXVswXSAhPT0gJ3dvcmQnKSB7XG4gICAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMSkgdGhpcy51bmtub3duV29yZCh0b2tlbnMpXG4gICAgICBub2RlLnJhd3MuYmVmb3JlICs9IHRva2Vucy5zaGlmdCgpWzFdXG4gICAgfVxuICAgIG5vZGUuc291cmNlLnN0YXJ0ID0gdGhpcy5nZXRQb3NpdGlvbih0b2tlbnNbMF1bMl0pXG5cbiAgICBub2RlLnByb3AgPSAnJ1xuICAgIHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICBsZXQgdHlwZSA9IHRva2Vuc1swXVswXVxuICAgICAgaWYgKHR5cGUgPT09ICc6JyB8fCB0eXBlID09PSAnc3BhY2UnIHx8IHR5cGUgPT09ICdjb21tZW50Jykge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgbm9kZS5wcm9wICs9IHRva2Vucy5zaGlmdCgpWzFdXG4gICAgfVxuXG4gICAgbm9kZS5yYXdzLmJldHdlZW4gPSAnJ1xuXG4gICAgbGV0IHRva2VuXG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIHRva2VuID0gdG9rZW5zLnNoaWZ0KClcblxuICAgICAgaWYgKHRva2VuWzBdID09PSAnOicpIHtcbiAgICAgICAgbm9kZS5yYXdzLmJldHdlZW4gKz0gdG9rZW5bMV1cbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0b2tlblswXSA9PT0gJ3dvcmQnICYmIC9cXHcvLnRlc3QodG9rZW5bMV0pKSB7XG4gICAgICAgICAgdGhpcy51bmtub3duV29yZChbdG9rZW5dKVxuICAgICAgICB9XG4gICAgICAgIG5vZGUucmF3cy5iZXR3ZWVuICs9IHRva2VuWzFdXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vZGUucHJvcFswXSA9PT0gJ18nIHx8IG5vZGUucHJvcFswXSA9PT0gJyonKSB7XG4gICAgICBub2RlLnJhd3MuYmVmb3JlICs9IG5vZGUucHJvcFswXVxuICAgICAgbm9kZS5wcm9wID0gbm9kZS5wcm9wLnNsaWNlKDEpXG4gICAgfVxuXG4gICAgbGV0IGZpcnN0U3BhY2VzID0gW11cbiAgICBsZXQgbmV4dFxuICAgIHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICBuZXh0ID0gdG9rZW5zWzBdWzBdXG4gICAgICBpZiAobmV4dCAhPT0gJ3NwYWNlJyAmJiBuZXh0ICE9PSAnY29tbWVudCcpIGJyZWFrXG4gICAgICBmaXJzdFNwYWNlcy5wdXNoKHRva2Vucy5zaGlmdCgpKVxuICAgIH1cblxuICAgIHRoaXMucHJlY2hlY2tNaXNzZWRTZW1pY29sb24odG9rZW5zKVxuXG4gICAgZm9yIChsZXQgaSA9IHRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV1cbiAgICAgIGlmICh0b2tlblsxXS50b0xvd2VyQ2FzZSgpID09PSAnIWltcG9ydGFudCcpIHtcbiAgICAgICAgbm9kZS5pbXBvcnRhbnQgPSB0cnVlXG4gICAgICAgIGxldCBzdHJpbmcgPSB0aGlzLnN0cmluZ0Zyb20odG9rZW5zLCBpKVxuICAgICAgICBzdHJpbmcgPSB0aGlzLnNwYWNlc0Zyb21FbmQodG9rZW5zKSArIHN0cmluZ1xuICAgICAgICBpZiAoc3RyaW5nICE9PSAnICFpbXBvcnRhbnQnKSBub2RlLnJhd3MuaW1wb3J0YW50ID0gc3RyaW5nXG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2UgaWYgKHRva2VuWzFdLnRvTG93ZXJDYXNlKCkgPT09ICdpbXBvcnRhbnQnKSB7XG4gICAgICAgIGxldCBjYWNoZSA9IHRva2Vucy5zbGljZSgwKVxuICAgICAgICBsZXQgc3RyID0gJydcbiAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPiAwOyBqLS0pIHtcbiAgICAgICAgICBsZXQgdHlwZSA9IGNhY2hlW2pdWzBdXG4gICAgICAgICAgaWYgKHN0ci50cmltKCkuaW5kZXhPZignIScpID09PSAwICYmIHR5cGUgIT09ICdzcGFjZScpIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIHN0ciA9IGNhY2hlLnBvcCgpWzFdICsgc3RyXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ci50cmltKCkuaW5kZXhPZignIScpID09PSAwKSB7XG4gICAgICAgICAgbm9kZS5pbXBvcnRhbnQgPSB0cnVlXG4gICAgICAgICAgbm9kZS5yYXdzLmltcG9ydGFudCA9IHN0clxuICAgICAgICAgIHRva2VucyA9IGNhY2hlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuWzBdICE9PSAnc3BhY2UnICYmIHRva2VuWzBdICE9PSAnY29tbWVudCcpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgaGFzV29yZCA9IHRva2Vucy5zb21lKGkgPT4gaVswXSAhPT0gJ3NwYWNlJyAmJiBpWzBdICE9PSAnY29tbWVudCcpXG5cbiAgICBpZiAoaGFzV29yZCkge1xuICAgICAgbm9kZS5yYXdzLmJldHdlZW4gKz0gZmlyc3RTcGFjZXMubWFwKGkgPT4gaVsxXSkuam9pbignJylcbiAgICAgIGZpcnN0U3BhY2VzID0gW11cbiAgICB9XG4gICAgdGhpcy5yYXcobm9kZSwgJ3ZhbHVlJywgZmlyc3RTcGFjZXMuY29uY2F0KHRva2VucyksIGN1c3RvbVByb3BlcnR5KVxuXG4gICAgaWYgKG5vZGUudmFsdWUuaW5jbHVkZXMoJzonKSAmJiAhY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgIHRoaXMuY2hlY2tNaXNzZWRTZW1pY29sb24odG9rZW5zKVxuICAgIH1cbiAgfVxuXG4gIGF0cnVsZSh0b2tlbikge1xuICAgIGxldCBub2RlID0gbmV3IEF0UnVsZSgpXG4gICAgbm9kZS5uYW1lID0gdG9rZW5bMV0uc2xpY2UoMSlcbiAgICBpZiAobm9kZS5uYW1lID09PSAnJykge1xuICAgICAgdGhpcy51bm5hbWVkQXRydWxlKG5vZGUsIHRva2VuKVxuICAgIH1cbiAgICB0aGlzLmluaXQobm9kZSwgdG9rZW5bMl0pXG5cbiAgICBsZXQgdHlwZVxuICAgIGxldCBwcmV2XG4gICAgbGV0IHNoaWZ0XG4gICAgbGV0IGxhc3QgPSBmYWxzZVxuICAgIGxldCBvcGVuID0gZmFsc2VcbiAgICBsZXQgcGFyYW1zID0gW11cbiAgICBsZXQgYnJhY2tldHMgPSBbXVxuXG4gICAgd2hpbGUgKCF0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSkge1xuICAgICAgdG9rZW4gPSB0aGlzLnRva2VuaXplci5uZXh0VG9rZW4oKVxuICAgICAgdHlwZSA9IHRva2VuWzBdXG5cbiAgICAgIGlmICh0eXBlID09PSAnKCcgfHwgdHlwZSA9PT0gJ1snKSB7XG4gICAgICAgIGJyYWNrZXRzLnB1c2godHlwZSA9PT0gJygnID8gJyknIDogJ10nKVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAneycgJiYgYnJhY2tldHMubGVuZ3RoID4gMCkge1xuICAgICAgICBicmFja2V0cy5wdXNoKCd9JylcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gYnJhY2tldHNbYnJhY2tldHMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgYnJhY2tldHMucG9wKClcbiAgICAgIH1cblxuICAgICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJzsnKSB7XG4gICAgICAgICAgbm9kZS5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0b2tlblsyXSlcbiAgICAgICAgICB0aGlzLnNlbWljb2xvbiA9IHRydWVcbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd7Jykge1xuICAgICAgICAgIG9wZW4gPSB0cnVlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnfScpIHtcbiAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNoaWZ0ID0gcGFyYW1zLmxlbmd0aCAtIDFcbiAgICAgICAgICAgIHByZXYgPSBwYXJhbXNbc2hpZnRdXG4gICAgICAgICAgICB3aGlsZSAocHJldiAmJiBwcmV2WzBdID09PSAnc3BhY2UnKSB7XG4gICAgICAgICAgICAgIHByZXYgPSBwYXJhbXNbLS1zaGlmdF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgIG5vZGUuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24ocHJldlszXSB8fCBwcmV2WzJdKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVuZCh0b2tlbilcbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmFtcy5wdXNoKHRva2VuKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMucHVzaCh0b2tlbilcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudG9rZW5pemVyLmVuZE9mRmlsZSgpKSB7XG4gICAgICAgIGxhc3QgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9kZS5yYXdzLmJldHdlZW4gPSB0aGlzLnNwYWNlc0FuZENvbW1lbnRzRnJvbUVuZChwYXJhbXMpXG4gICAgaWYgKHBhcmFtcy5sZW5ndGgpIHtcbiAgICAgIG5vZGUucmF3cy5hZnRlck5hbWUgPSB0aGlzLnNwYWNlc0FuZENvbW1lbnRzRnJvbVN0YXJ0KHBhcmFtcylcbiAgICAgIHRoaXMucmF3KG5vZGUsICdwYXJhbXMnLCBwYXJhbXMpXG4gICAgICBpZiAobGFzdCkge1xuICAgICAgICB0b2tlbiA9IHBhcmFtc1twYXJhbXMubGVuZ3RoIC0gMV1cbiAgICAgICAgbm9kZS5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0b2tlblszXSB8fCB0b2tlblsyXSlcbiAgICAgICAgdGhpcy5zcGFjZXMgPSBub2RlLnJhd3MuYmV0d2VlblxuICAgICAgICBub2RlLnJhd3MuYmV0d2VlbiA9ICcnXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUucmF3cy5hZnRlck5hbWUgPSAnJ1xuICAgICAgbm9kZS5wYXJhbXMgPSAnJ1xuICAgIH1cblxuICAgIGlmIChvcGVuKSB7XG4gICAgICBub2RlLm5vZGVzID0gW11cbiAgICAgIHRoaXMuY3VycmVudCA9IG5vZGVcbiAgICB9XG4gIH1cblxuICBlbmQodG9rZW4pIHtcbiAgICBpZiAodGhpcy5jdXJyZW50Lm5vZGVzICYmIHRoaXMuY3VycmVudC5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuY3VycmVudC5yYXdzLnNlbWljb2xvbiA9IHRoaXMuc2VtaWNvbG9uXG4gICAgfVxuICAgIHRoaXMuc2VtaWNvbG9uID0gZmFsc2VcblxuICAgIHRoaXMuY3VycmVudC5yYXdzLmFmdGVyID0gKHRoaXMuY3VycmVudC5yYXdzLmFmdGVyIHx8ICcnKSArIHRoaXMuc3BhY2VzXG4gICAgdGhpcy5zcGFjZXMgPSAnJ1xuXG4gICAgaWYgKHRoaXMuY3VycmVudC5wYXJlbnQpIHtcbiAgICAgIHRoaXMuY3VycmVudC5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0b2tlblsyXSlcbiAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMuY3VycmVudC5wYXJlbnRcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkQ2xvc2UodG9rZW4pXG4gICAgfVxuICB9XG5cbiAgZW5kRmlsZSgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50LnBhcmVudCkgdGhpcy51bmNsb3NlZEJsb2NrKClcbiAgICBpZiAodGhpcy5jdXJyZW50Lm5vZGVzICYmIHRoaXMuY3VycmVudC5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuY3VycmVudC5yYXdzLnNlbWljb2xvbiA9IHRoaXMuc2VtaWNvbG9uXG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5yYXdzLmFmdGVyID0gKHRoaXMuY3VycmVudC5yYXdzLmFmdGVyIHx8ICcnKSArIHRoaXMuc3BhY2VzXG4gIH1cblxuICBmcmVlU2VtaWNvbG9uKHRva2VuKSB7XG4gICAgdGhpcy5zcGFjZXMgKz0gdG9rZW5bMV1cbiAgICBpZiAodGhpcy5jdXJyZW50Lm5vZGVzKSB7XG4gICAgICBsZXQgcHJldiA9IHRoaXMuY3VycmVudC5ub2Rlc1t0aGlzLmN1cnJlbnQubm9kZXMubGVuZ3RoIC0gMV1cbiAgICAgIGlmIChwcmV2ICYmIHByZXYudHlwZSA9PT0gJ3J1bGUnICYmICFwcmV2LnJhd3Mub3duU2VtaWNvbG9uKSB7XG4gICAgICAgIHByZXYucmF3cy5vd25TZW1pY29sb24gPSB0aGlzLnNwYWNlc1xuICAgICAgICB0aGlzLnNwYWNlcyA9ICcnXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gSGVscGVyc1xuXG4gIGdldFBvc2l0aW9uKG9mZnNldCkge1xuICAgIGxldCBwb3MgPSB0aGlzLmlucHV0LmZyb21PZmZzZXQob2Zmc2V0KVxuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXQsXG4gICAgICBsaW5lOiBwb3MubGluZSxcbiAgICAgIGNvbHVtbjogcG9zLmNvbFxuICAgIH1cbiAgfVxuXG4gIGluaXQobm9kZSwgb2Zmc2V0KSB7XG4gICAgdGhpcy5jdXJyZW50LnB1c2gobm9kZSlcbiAgICBub2RlLnNvdXJjZSA9IHtcbiAgICAgIHN0YXJ0OiB0aGlzLmdldFBvc2l0aW9uKG9mZnNldCksXG4gICAgICBpbnB1dDogdGhpcy5pbnB1dFxuICAgIH1cbiAgICBub2RlLnJhd3MuYmVmb3JlID0gdGhpcy5zcGFjZXNcbiAgICB0aGlzLnNwYWNlcyA9ICcnXG4gICAgaWYgKG5vZGUudHlwZSAhPT0gJ2NvbW1lbnQnKSB0aGlzLnNlbWljb2xvbiA9IGZhbHNlXG4gIH1cblxuICByYXcobm9kZSwgcHJvcCwgdG9rZW5zLCBjdXN0b21Qcm9wZXJ0eSkge1xuICAgIGxldCB0b2tlbiwgdHlwZVxuICAgIGxldCBsZW5ndGggPSB0b2tlbnMubGVuZ3RoXG4gICAgbGV0IHZhbHVlID0gJydcbiAgICBsZXQgY2xlYW4gPSB0cnVlXG4gICAgbGV0IG5leHQsIHByZXZcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldXG4gICAgICB0eXBlID0gdG9rZW5bMF1cbiAgICAgIGlmICh0eXBlID09PSAnc3BhY2UnICYmIGkgPT09IGxlbmd0aCAtIDEgJiYgIWN1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgIGNsZWFuID0gZmFsc2VcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NvbW1lbnQnKSB7XG4gICAgICAgIHByZXYgPSB0b2tlbnNbaSAtIDFdID8gdG9rZW5zW2kgLSAxXVswXSA6ICdlbXB0eSdcbiAgICAgICAgbmV4dCA9IHRva2Vuc1tpICsgMV0gPyB0b2tlbnNbaSArIDFdWzBdIDogJ2VtcHR5J1xuICAgICAgICBpZiAoIVNBRkVfQ09NTUVOVF9ORUlHSEJPUltwcmV2XSAmJiAhU0FGRV9DT01NRU5UX05FSUdIQk9SW25leHRdKSB7XG4gICAgICAgICAgaWYgKHZhbHVlLnNsaWNlKC0xKSA9PT0gJywnKSB7XG4gICAgICAgICAgICBjbGVhbiA9IGZhbHNlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlICs9IHRva2VuWzFdXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsZWFuID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgKz0gdG9rZW5bMV1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjbGVhbikge1xuICAgICAgbGV0IHJhdyA9IHRva2Vucy5yZWR1Y2UoKGFsbCwgaSkgPT4gYWxsICsgaVsxXSwgJycpXG4gICAgICBub2RlLnJhd3NbcHJvcF0gPSB7IHZhbHVlLCByYXcgfVxuICAgIH1cbiAgICBub2RlW3Byb3BdID0gdmFsdWVcbiAgfVxuXG4gIHNwYWNlc0FuZENvbW1lbnRzRnJvbUVuZCh0b2tlbnMpIHtcbiAgICBsZXQgbGFzdFRva2VuVHlwZVxuICAgIGxldCBzcGFjZXMgPSAnJ1xuICAgIHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICBsYXN0VG9rZW5UeXBlID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXVswXVxuICAgICAgaWYgKGxhc3RUb2tlblR5cGUgIT09ICdzcGFjZScgJiYgbGFzdFRva2VuVHlwZSAhPT0gJ2NvbW1lbnQnKSBicmVha1xuICAgICAgc3BhY2VzID0gdG9rZW5zLnBvcCgpWzFdICsgc3BhY2VzXG4gICAgfVxuICAgIHJldHVybiBzcGFjZXNcbiAgfVxuXG4gIHNwYWNlc0FuZENvbW1lbnRzRnJvbVN0YXJ0KHRva2Vucykge1xuICAgIGxldCBuZXh0XG4gICAgbGV0IHNwYWNlcyA9ICcnXG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIG5leHQgPSB0b2tlbnNbMF1bMF1cbiAgICAgIGlmIChuZXh0ICE9PSAnc3BhY2UnICYmIG5leHQgIT09ICdjb21tZW50JykgYnJlYWtcbiAgICAgIHNwYWNlcyArPSB0b2tlbnMuc2hpZnQoKVsxXVxuICAgIH1cbiAgICByZXR1cm4gc3BhY2VzXG4gIH1cblxuICBzcGFjZXNGcm9tRW5kKHRva2Vucykge1xuICAgIGxldCBsYXN0VG9rZW5UeXBlXG4gICAgbGV0IHNwYWNlcyA9ICcnXG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIGxhc3RUb2tlblR5cGUgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdWzBdXG4gICAgICBpZiAobGFzdFRva2VuVHlwZSAhPT0gJ3NwYWNlJykgYnJlYWtcbiAgICAgIHNwYWNlcyA9IHRva2Vucy5wb3AoKVsxXSArIHNwYWNlc1xuICAgIH1cbiAgICByZXR1cm4gc3BhY2VzXG4gIH1cblxuICBzdHJpbmdGcm9tKHRva2VucywgZnJvbSkge1xuICAgIGxldCByZXN1bHQgPSAnJ1xuICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHQgKz0gdG9rZW5zW2ldWzFdXG4gICAgfVxuICAgIHRva2Vucy5zcGxpY2UoZnJvbSwgdG9rZW5zLmxlbmd0aCAtIGZyb20pXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgY29sb24odG9rZW5zKSB7XG4gICAgbGV0IGJyYWNrZXRzID0gMFxuICAgIGxldCB0b2tlbiwgdHlwZSwgcHJldlxuICAgIGZvciAobGV0IFtpLCBlbGVtZW50XSBvZiB0b2tlbnMuZW50cmllcygpKSB7XG4gICAgICB0b2tlbiA9IGVsZW1lbnRcbiAgICAgIHR5cGUgPSB0b2tlblswXVxuXG4gICAgICBpZiAodHlwZSA9PT0gJygnKSB7XG4gICAgICAgIGJyYWNrZXRzICs9IDFcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSAnKScpIHtcbiAgICAgICAgYnJhY2tldHMgLT0gMVxuICAgICAgfVxuICAgICAgaWYgKGJyYWNrZXRzID09PSAwICYmIHR5cGUgPT09ICc6Jykge1xuICAgICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgICB0aGlzLmRvdWJsZUNvbG9uKHRva2VuKVxuICAgICAgICB9IGVsc2UgaWYgKHByZXZbMF0gPT09ICd3b3JkJyAmJiBwcmV2WzFdID09PSAncHJvZ2lkJykge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcmV2ID0gdG9rZW5cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBFcnJvcnNcblxuICB1bmNsb3NlZEJyYWNrZXQoYnJhY2tldCkge1xuICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXG4gICAgICAnVW5jbG9zZWQgYnJhY2tldCcsXG4gICAgICB7IG9mZnNldDogYnJhY2tldFsyXSB9LFxuICAgICAgeyBvZmZzZXQ6IGJyYWNrZXRbMl0gKyAxIH1cbiAgICApXG4gIH1cblxuICB1bmtub3duV29yZCh0b2tlbnMpIHtcbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFxuICAgICAgJ1Vua25vd24gd29yZCcsXG4gICAgICB7IG9mZnNldDogdG9rZW5zWzBdWzJdIH0sXG4gICAgICB7IG9mZnNldDogdG9rZW5zWzBdWzJdICsgdG9rZW5zWzBdWzFdLmxlbmd0aCB9XG4gICAgKVxuICB9XG5cbiAgdW5leHBlY3RlZENsb3NlKHRva2VuKSB7XG4gICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcbiAgICAgICdVbmV4cGVjdGVkIH0nLFxuICAgICAgeyBvZmZzZXQ6IHRva2VuWzJdIH0sXG4gICAgICB7IG9mZnNldDogdG9rZW5bMl0gKyAxIH1cbiAgICApXG4gIH1cblxuICB1bmNsb3NlZEJsb2NrKCkge1xuICAgIGxldCBwb3MgPSB0aGlzLmN1cnJlbnQuc291cmNlLnN0YXJ0XG4gICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcignVW5jbG9zZWQgYmxvY2snLCBwb3MubGluZSwgcG9zLmNvbHVtbilcbiAgfVxuXG4gIGRvdWJsZUNvbG9uKHRva2VuKSB7XG4gICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcbiAgICAgICdEb3VibGUgY29sb24nLFxuICAgICAgeyBvZmZzZXQ6IHRva2VuWzJdIH0sXG4gICAgICB7IG9mZnNldDogdG9rZW5bMl0gKyB0b2tlblsxXS5sZW5ndGggfVxuICAgIClcbiAgfVxuXG4gIHVubmFtZWRBdHJ1bGUobm9kZSwgdG9rZW4pIHtcbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFxuICAgICAgJ0F0LXJ1bGUgd2l0aG91dCBuYW1lJyxcbiAgICAgIHsgb2Zmc2V0OiB0b2tlblsyXSB9LFxuICAgICAgeyBvZmZzZXQ6IHRva2VuWzJdICsgdG9rZW5bMV0ubGVuZ3RoIH1cbiAgICApXG4gIH1cblxuICBwcmVjaGVja01pc3NlZFNlbWljb2xvbigvKiB0b2tlbnMgKi8pIHtcbiAgICAvLyBIb29rIGZvciBTYWZlIFBhcnNlclxuICB9XG5cbiAgY2hlY2tNaXNzZWRTZW1pY29sb24odG9rZW5zKSB7XG4gICAgbGV0IGNvbG9uID0gdGhpcy5jb2xvbih0b2tlbnMpXG4gICAgaWYgKGNvbG9uID09PSBmYWxzZSkgcmV0dXJuXG5cbiAgICBsZXQgZm91bmRlZCA9IDBcbiAgICBsZXQgdG9rZW5cbiAgICBmb3IgKGxldCBqID0gY29sb24gLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbal1cbiAgICAgIGlmICh0b2tlblswXSAhPT0gJ3NwYWNlJykge1xuICAgICAgICBmb3VuZGVkICs9IDFcbiAgICAgICAgaWYgKGZvdW5kZWQgPT09IDIpIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZSB0b2tlbiBpcyBhIHdvcmQsIGUuZy4gYCFpbXBvcnRhbnRgLCBgcmVkYCBvciBhbnkgb3RoZXIgdmFsaWQgcHJvcGVydHkncyB2YWx1ZS5cbiAgICAvLyBUaGVuIHdlIG5lZWQgdG8gcmV0dXJuIHRoZSBjb2xvbiBhZnRlciB0aGF0IHdvcmQgdG9rZW4uIFszXSBpcyB0aGUgXCJlbmRcIiBjb2xvbiBvZiB0aGF0IHdvcmQuXG4gICAgLy8gQW5kIGJlY2F1c2Ugd2UgbmVlZCBpdCBhZnRlciB0aGF0IG9uZSB3ZSBkbyArMSB0byBnZXQgdGhlIG5leHQgb25lLlxuICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXG4gICAgICAnTWlzc2VkIHNlbWljb2xvbicsXG4gICAgICB0b2tlblswXSA9PT0gJ3dvcmQnID8gdG9rZW5bM10gKyAxIDogdG9rZW5bMl1cbiAgICApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/parser.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/postcss.js":
/*!*********************************************!*\
  !*** ./node_modules/postcss/lib/postcss.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ \"./node_modules/process/browser.js\");\n\n\nlet CssSyntaxError = __webpack_require__(/*! ./css-syntax-error */ \"./node_modules/postcss/lib/css-syntax-error.js\")\nlet Declaration = __webpack_require__(/*! ./declaration */ \"./node_modules/postcss/lib/declaration.js\")\nlet LazyResult = __webpack_require__(/*! ./lazy-result */ \"./node_modules/postcss/lib/lazy-result.js\")\nlet Container = __webpack_require__(/*! ./container */ \"./node_modules/postcss/lib/container.js\")\nlet Processor = __webpack_require__(/*! ./processor */ \"./node_modules/postcss/lib/processor.js\")\nlet stringify = __webpack_require__(/*! ./stringify */ \"./node_modules/postcss/lib/stringify.js\")\nlet fromJSON = __webpack_require__(/*! ./fromJSON */ \"./node_modules/postcss/lib/fromJSON.js\")\nlet Document = __webpack_require__(/*! ./document */ \"./node_modules/postcss/lib/document.js\")\nlet Warning = __webpack_require__(/*! ./warning */ \"./node_modules/postcss/lib/warning.js\")\nlet Comment = __webpack_require__(/*! ./comment */ \"./node_modules/postcss/lib/comment.js\")\nlet AtRule = __webpack_require__(/*! ./at-rule */ \"./node_modules/postcss/lib/at-rule.js\")\nlet Result = __webpack_require__(/*! ./result.js */ \"./node_modules/postcss/lib/result.js\")\nlet Input = __webpack_require__(/*! ./input */ \"./node_modules/postcss/lib/input.js\")\nlet parse = __webpack_require__(/*! ./parse */ \"./node_modules/postcss/lib/parse.js\")\nlet list = __webpack_require__(/*! ./list */ \"./node_modules/postcss/lib/list.js\")\nlet Rule = __webpack_require__(/*! ./rule */ \"./node_modules/postcss/lib/rule.js\")\nlet Root = __webpack_require__(/*! ./root */ \"./node_modules/postcss/lib/root.js\")\nlet Node = __webpack_require__(/*! ./node */ \"./node_modules/postcss/lib/node.js\")\n\nfunction postcss(...plugins) {\n  if (plugins.length === 1 && Array.isArray(plugins[0])) {\n    plugins = plugins[0]\n  }\n  return new Processor(plugins)\n}\n\npostcss.plugin = function plugin(name, initializer) {\n  let warningPrinted = false\n  function creator(...args) {\n    // eslint-disable-next-line no-console\n    if (console && console.warn && !warningPrinted) {\n      warningPrinted = true\n      // eslint-disable-next-line no-console\n      console.warn(\n        name +\n          ': postcss.plugin was deprecated. Migration guide:\\n' +\n          'https://evilmartians.com/chronicles/postcss-8-plugin-migration'\n      )\n      if (process.env.LANG && process.env.LANG.startsWith('cn')) {\n        /* c8 ignore next 7 */\n        // eslint-disable-next-line no-console\n        console.warn(\n          name +\n            ':  postcss.plugin . :\\n' +\n            'https://www.w3ctech.com/topic/2226'\n        )\n      }\n    }\n    let transformer = initializer(...args)\n    transformer.postcssPlugin = name\n    transformer.postcssVersion = new Processor().version\n    return transformer\n  }\n\n  let cache\n  Object.defineProperty(creator, 'postcss', {\n    get() {\n      if (!cache) cache = creator()\n      return cache\n    }\n  })\n\n  creator.process = function (css, processOpts, pluginOpts) {\n    return postcss([creator(pluginOpts)]).process(css, processOpts)\n  }\n\n  return creator\n}\n\npostcss.stringify = stringify\npostcss.parse = parse\npostcss.fromJSON = fromJSON\npostcss.list = list\n\npostcss.comment = defaults => new Comment(defaults)\npostcss.atRule = defaults => new AtRule(defaults)\npostcss.decl = defaults => new Declaration(defaults)\npostcss.rule = defaults => new Rule(defaults)\npostcss.root = defaults => new Root(defaults)\npostcss.document = defaults => new Document(defaults)\n\npostcss.CssSyntaxError = CssSyntaxError\npostcss.Declaration = Declaration\npostcss.Container = Container\npostcss.Processor = Processor\npostcss.Document = Document\npostcss.Comment = Comment\npostcss.Warning = Warning\npostcss.AtRule = AtRule\npostcss.Result = Result\npostcss.Input = Input\npostcss.Rule = Rule\npostcss.Root = Root\npostcss.Node = Node\n\nLazyResult.registerPostcss(postcss)\n\nmodule.exports = postcss\npostcss.default = postcss\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcG9zdGNzcy5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVk7O0FBRVoscUJBQXFCLG1CQUFPLENBQUMsMEVBQW9CO0FBQ2pELGtCQUFrQixtQkFBTyxDQUFDLGdFQUFlO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLGdFQUFlO0FBQ3hDLGdCQUFnQixtQkFBTyxDQUFDLDREQUFhO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLDREQUFhO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLDREQUFhO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQywwREFBWTtBQUNuQyxlQUFlLG1CQUFPLENBQUMsMERBQVk7QUFDbkMsY0FBYyxtQkFBTyxDQUFDLHdEQUFXO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyx3REFBVztBQUNqQyxhQUFhLG1CQUFPLENBQUMsd0RBQVc7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLHlEQUFhO0FBQ2xDLFlBQVksbUJBQU8sQ0FBQyxvREFBUztBQUM3QixZQUFZLG1CQUFPLENBQUMsb0RBQVM7QUFDN0IsV0FBVyxtQkFBTyxDQUFDLGtEQUFRO0FBQzNCLFdBQVcsbUJBQU8sQ0FBQyxrREFBUTtBQUMzQixXQUFXLG1CQUFPLENBQUMsa0RBQVE7QUFDM0IsV0FBVyxtQkFBTyxDQUFDLGtEQUFROztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPLGFBQWEsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcG9zdGNzcy5qcz9hYWNiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5sZXQgQ3NzU3ludGF4RXJyb3IgPSByZXF1aXJlKCcuL2Nzcy1zeW50YXgtZXJyb3InKVxubGV0IERlY2xhcmF0aW9uID0gcmVxdWlyZSgnLi9kZWNsYXJhdGlvbicpXG5sZXQgTGF6eVJlc3VsdCA9IHJlcXVpcmUoJy4vbGF6eS1yZXN1bHQnKVxubGV0IENvbnRhaW5lciA9IHJlcXVpcmUoJy4vY29udGFpbmVyJylcbmxldCBQcm9jZXNzb3IgPSByZXF1aXJlKCcuL3Byb2Nlc3NvcicpXG5sZXQgc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnknKVxubGV0IGZyb21KU09OID0gcmVxdWlyZSgnLi9mcm9tSlNPTicpXG5sZXQgRG9jdW1lbnQgPSByZXF1aXJlKCcuL2RvY3VtZW50JylcbmxldCBXYXJuaW5nID0gcmVxdWlyZSgnLi93YXJuaW5nJylcbmxldCBDb21tZW50ID0gcmVxdWlyZSgnLi9jb21tZW50JylcbmxldCBBdFJ1bGUgPSByZXF1aXJlKCcuL2F0LXJ1bGUnKVxubGV0IFJlc3VsdCA9IHJlcXVpcmUoJy4vcmVzdWx0LmpzJylcbmxldCBJbnB1dCA9IHJlcXVpcmUoJy4vaW5wdXQnKVxubGV0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5sZXQgbGlzdCA9IHJlcXVpcmUoJy4vbGlzdCcpXG5sZXQgUnVsZSA9IHJlcXVpcmUoJy4vcnVsZScpXG5sZXQgUm9vdCA9IHJlcXVpcmUoJy4vcm9vdCcpXG5sZXQgTm9kZSA9IHJlcXVpcmUoJy4vbm9kZScpXG5cbmZ1bmN0aW9uIHBvc3Rjc3MoLi4ucGx1Z2lucykge1xuICBpZiAocGx1Z2lucy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShwbHVnaW5zWzBdKSkge1xuICAgIHBsdWdpbnMgPSBwbHVnaW5zWzBdXG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9jZXNzb3IocGx1Z2lucylcbn1cblxucG9zdGNzcy5wbHVnaW4gPSBmdW5jdGlvbiBwbHVnaW4obmFtZSwgaW5pdGlhbGl6ZXIpIHtcbiAgbGV0IHdhcm5pbmdQcmludGVkID0gZmFsc2VcbiAgZnVuY3Rpb24gY3JlYXRvciguLi5hcmdzKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4gJiYgIXdhcm5pbmdQcmludGVkKSB7XG4gICAgICB3YXJuaW5nUHJpbnRlZCA9IHRydWVcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIG5hbWUgK1xuICAgICAgICAgICc6IHBvc3Rjc3MucGx1Z2luIHdhcyBkZXByZWNhdGVkLiBNaWdyYXRpb24gZ3VpZGU6XFxuJyArXG4gICAgICAgICAgJ2h0dHBzOi8vZXZpbG1hcnRpYW5zLmNvbS9jaHJvbmljbGVzL3Bvc3Rjc3MtOC1wbHVnaW4tbWlncmF0aW9uJ1xuICAgICAgKVxuICAgICAgaWYgKHByb2Nlc3MuZW52LkxBTkcgJiYgcHJvY2Vzcy5lbnYuTEFORy5zdGFydHNXaXRoKCdjbicpKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDcgKi9cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIG5hbWUgK1xuICAgICAgICAgICAgJzog6YeM6Z2iIHBvc3Rjc3MucGx1Z2luIOiiq+W8g+eUqC4g6L+B56e75oyH5Y2XOlxcbicgK1xuICAgICAgICAgICAgJ2h0dHBzOi8vd3d3LnczY3RlY2guY29tL3RvcGljLzIyMjYnXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHRyYW5zZm9ybWVyID0gaW5pdGlhbGl6ZXIoLi4uYXJncylcbiAgICB0cmFuc2Zvcm1lci5wb3N0Y3NzUGx1Z2luID0gbmFtZVxuICAgIHRyYW5zZm9ybWVyLnBvc3Rjc3NWZXJzaW9uID0gbmV3IFByb2Nlc3NvcigpLnZlcnNpb25cbiAgICByZXR1cm4gdHJhbnNmb3JtZXJcbiAgfVxuXG4gIGxldCBjYWNoZVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRvciwgJ3Bvc3Rjc3MnLCB7XG4gICAgZ2V0KCkge1xuICAgICAgaWYgKCFjYWNoZSkgY2FjaGUgPSBjcmVhdG9yKClcbiAgICAgIHJldHVybiBjYWNoZVxuICAgIH1cbiAgfSlcblxuICBjcmVhdG9yLnByb2Nlc3MgPSBmdW5jdGlvbiAoY3NzLCBwcm9jZXNzT3B0cywgcGx1Z2luT3B0cykge1xuICAgIHJldHVybiBwb3N0Y3NzKFtjcmVhdG9yKHBsdWdpbk9wdHMpXSkucHJvY2Vzcyhjc3MsIHByb2Nlc3NPcHRzKVxuICB9XG5cbiAgcmV0dXJuIGNyZWF0b3Jcbn1cblxucG9zdGNzcy5zdHJpbmdpZnkgPSBzdHJpbmdpZnlcbnBvc3Rjc3MucGFyc2UgPSBwYXJzZVxucG9zdGNzcy5mcm9tSlNPTiA9IGZyb21KU09OXG5wb3N0Y3NzLmxpc3QgPSBsaXN0XG5cbnBvc3Rjc3MuY29tbWVudCA9IGRlZmF1bHRzID0+IG5ldyBDb21tZW50KGRlZmF1bHRzKVxucG9zdGNzcy5hdFJ1bGUgPSBkZWZhdWx0cyA9PiBuZXcgQXRSdWxlKGRlZmF1bHRzKVxucG9zdGNzcy5kZWNsID0gZGVmYXVsdHMgPT4gbmV3IERlY2xhcmF0aW9uKGRlZmF1bHRzKVxucG9zdGNzcy5ydWxlID0gZGVmYXVsdHMgPT4gbmV3IFJ1bGUoZGVmYXVsdHMpXG5wb3N0Y3NzLnJvb3QgPSBkZWZhdWx0cyA9PiBuZXcgUm9vdChkZWZhdWx0cylcbnBvc3Rjc3MuZG9jdW1lbnQgPSBkZWZhdWx0cyA9PiBuZXcgRG9jdW1lbnQoZGVmYXVsdHMpXG5cbnBvc3Rjc3MuQ3NzU3ludGF4RXJyb3IgPSBDc3NTeW50YXhFcnJvclxucG9zdGNzcy5EZWNsYXJhdGlvbiA9IERlY2xhcmF0aW9uXG5wb3N0Y3NzLkNvbnRhaW5lciA9IENvbnRhaW5lclxucG9zdGNzcy5Qcm9jZXNzb3IgPSBQcm9jZXNzb3JcbnBvc3Rjc3MuRG9jdW1lbnQgPSBEb2N1bWVudFxucG9zdGNzcy5Db21tZW50ID0gQ29tbWVudFxucG9zdGNzcy5XYXJuaW5nID0gV2FybmluZ1xucG9zdGNzcy5BdFJ1bGUgPSBBdFJ1bGVcbnBvc3Rjc3MuUmVzdWx0ID0gUmVzdWx0XG5wb3N0Y3NzLklucHV0ID0gSW5wdXRcbnBvc3Rjc3MuUnVsZSA9IFJ1bGVcbnBvc3Rjc3MuUm9vdCA9IFJvb3RcbnBvc3Rjc3MuTm9kZSA9IE5vZGVcblxuTGF6eVJlc3VsdC5yZWdpc3RlclBvc3Rjc3MocG9zdGNzcylcblxubW9kdWxlLmV4cG9ydHMgPSBwb3N0Y3NzXG5wb3N0Y3NzLmRlZmF1bHQgPSBwb3N0Y3NzXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/postcss.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/previous-map.js":
/*!**************************************************!*\
  !*** ./node_modules/postcss/lib/previous-map.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\nlet { SourceMapConsumer, SourceMapGenerator } = __webpack_require__(/*! source-map-js */ \"?6f78\")\nlet { existsSync, readFileSync } = __webpack_require__(/*! fs */ \"?2f81\")\nlet { dirname, join } = __webpack_require__(/*! path */ \"?25fb\")\n\nfunction fromBase64(str) {\n  if (Buffer) {\n    return Buffer.from(str, 'base64').toString()\n  } else {\n    /* c8 ignore next 2 */\n    return window.atob(str)\n  }\n}\n\nclass PreviousMap {\n  constructor(css, opts) {\n    if (opts.map === false) return\n    this.loadAnnotation(css)\n    this.inline = this.startWith(this.annotation, 'data:')\n\n    let prev = opts.map ? opts.map.prev : undefined\n    let text = this.loadMap(opts.from, prev)\n    if (!this.mapFile && opts.from) {\n      this.mapFile = opts.from\n    }\n    if (this.mapFile) this.root = dirname(this.mapFile)\n    if (text) this.text = text\n  }\n\n  consumer() {\n    if (!this.consumerCache) {\n      this.consumerCache = new SourceMapConsumer(this.text)\n    }\n    return this.consumerCache\n  }\n\n  withContent() {\n    return !!(\n      this.consumer().sourcesContent &&\n      this.consumer().sourcesContent.length > 0\n    )\n  }\n\n  startWith(string, start) {\n    if (!string) return false\n    return string.substr(0, start.length) === start\n  }\n\n  getAnnotationURL(sourceMapString) {\n    return sourceMapString.replace(/^\\/\\*\\s*# sourceMappingURL=/, '').trim()\n  }\n\n  loadAnnotation(css) {\n    let comments = css.match(/\\/\\*\\s*# sourceMappingURL=/gm)\n    if (!comments) return\n\n    // sourceMappingURLs from comments, strings, etc.\n    let start = css.lastIndexOf(comments.pop())\n    let end = css.indexOf('*/', start)\n\n    if (start > -1 && end > -1) {\n      // Locate the last sourceMappingURL to avoid pickin\n      this.annotation = this.getAnnotationURL(css.substring(start, end))\n    }\n  }\n\n  decodeInline(text) {\n    let baseCharsetUri = /^data:application\\/json;charset=utf-?8;base64,/\n    let baseUri = /^data:application\\/json;base64,/\n    let charsetUri = /^data:application\\/json;charset=utf-?8,/\n    let uri = /^data:application\\/json,/\n\n    if (charsetUri.test(text) || uri.test(text)) {\n      return decodeURIComponent(text.substr(RegExp.lastMatch.length))\n    }\n\n    if (baseCharsetUri.test(text) || baseUri.test(text)) {\n      return fromBase64(text.substr(RegExp.lastMatch.length))\n    }\n\n    let encoding = text.match(/data:application\\/json;([^,]+),/)[1]\n    throw new Error('Unsupported source map encoding ' + encoding)\n  }\n\n  loadFile(path) {\n    this.root = dirname(path)\n    if (existsSync(path)) {\n      this.mapFile = path\n      return readFileSync(path, 'utf-8').toString().trim()\n    }\n  }\n\n  loadMap(file, prev) {\n    if (prev === false) return false\n\n    if (prev) {\n      if (typeof prev === 'string') {\n        return prev\n      } else if (typeof prev === 'function') {\n        let prevPath = prev(file)\n        if (prevPath) {\n          let map = this.loadFile(prevPath)\n          if (!map) {\n            throw new Error(\n              'Unable to load previous source map: ' + prevPath.toString()\n            )\n          }\n          return map\n        }\n      } else if (prev instanceof SourceMapConsumer) {\n        return SourceMapGenerator.fromSourceMap(prev).toString()\n      } else if (prev instanceof SourceMapGenerator) {\n        return prev.toString()\n      } else if (this.isMap(prev)) {\n        return JSON.stringify(prev)\n      } else {\n        throw new Error(\n          'Unsupported previous source map format: ' + prev.toString()\n        )\n      }\n    } else if (this.inline) {\n      return this.decodeInline(this.annotation)\n    } else if (this.annotation) {\n      let map = this.annotation\n      if (file) map = join(dirname(file), map)\n      return this.loadFile(map)\n    }\n  }\n\n  isMap(map) {\n    if (typeof map !== 'object') return false\n    return (\n      typeof map.mappings === 'string' ||\n      typeof map._mappings === 'string' ||\n      Array.isArray(map.sections)\n    )\n  }\n}\n\nmodule.exports = PreviousMap\nPreviousMap.default = PreviousMap\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcHJldmlvdXMtbWFwLmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBWTs7QUFFWixNQUFNLHdDQUF3QyxFQUFFLG1CQUFPLENBQUMsNEJBQWU7QUFDdkUsTUFBTSwyQkFBMkIsRUFBRSxtQkFBTyxDQUFDLGlCQUFJO0FBQy9DLE1BQU0sZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyxtQkFBTTs7QUFFdEM7QUFDQSxNQUFNLE1BQU07QUFDWixXQUFXLE1BQU07QUFDakIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0QsZUFBZTtBQUNqRSwyQ0FBMkM7QUFDM0MsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNEO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzL2xpYi9wcmV2aW91cy1tYXAuanM/NWIzYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubGV0IHsgU291cmNlTWFwQ29uc3VtZXIsIFNvdXJjZU1hcEdlbmVyYXRvciB9ID0gcmVxdWlyZSgnc291cmNlLW1hcC1qcycpXG5sZXQgeyBleGlzdHNTeW5jLCByZWFkRmlsZVN5bmMgfSA9IHJlcXVpcmUoJ2ZzJylcbmxldCB7IGRpcm5hbWUsIGpvaW4gfSA9IHJlcXVpcmUoJ3BhdGgnKVxuXG5mdW5jdGlvbiBmcm9tQmFzZTY0KHN0cikge1xuICBpZiAoQnVmZmVyKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0ciwgJ2Jhc2U2NCcpLnRvU3RyaW5nKClcbiAgfSBlbHNlIHtcbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAyICovXG4gICAgcmV0dXJuIHdpbmRvdy5hdG9iKHN0cilcbiAgfVxufVxuXG5jbGFzcyBQcmV2aW91c01hcCB7XG4gIGNvbnN0cnVjdG9yKGNzcywgb3B0cykge1xuICAgIGlmIChvcHRzLm1hcCA9PT0gZmFsc2UpIHJldHVyblxuICAgIHRoaXMubG9hZEFubm90YXRpb24oY3NzKVxuICAgIHRoaXMuaW5saW5lID0gdGhpcy5zdGFydFdpdGgodGhpcy5hbm5vdGF0aW9uLCAnZGF0YTonKVxuXG4gICAgbGV0IHByZXYgPSBvcHRzLm1hcCA/IG9wdHMubWFwLnByZXYgOiB1bmRlZmluZWRcbiAgICBsZXQgdGV4dCA9IHRoaXMubG9hZE1hcChvcHRzLmZyb20sIHByZXYpXG4gICAgaWYgKCF0aGlzLm1hcEZpbGUgJiYgb3B0cy5mcm9tKSB7XG4gICAgICB0aGlzLm1hcEZpbGUgPSBvcHRzLmZyb21cbiAgICB9XG4gICAgaWYgKHRoaXMubWFwRmlsZSkgdGhpcy5yb290ID0gZGlybmFtZSh0aGlzLm1hcEZpbGUpXG4gICAgaWYgKHRleHQpIHRoaXMudGV4dCA9IHRleHRcbiAgfVxuXG4gIGNvbnN1bWVyKCkge1xuICAgIGlmICghdGhpcy5jb25zdW1lckNhY2hlKSB7XG4gICAgICB0aGlzLmNvbnN1bWVyQ2FjaGUgPSBuZXcgU291cmNlTWFwQ29uc3VtZXIodGhpcy50ZXh0KVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb25zdW1lckNhY2hlXG4gIH1cblxuICB3aXRoQ29udGVudCgpIHtcbiAgICByZXR1cm4gISEoXG4gICAgICB0aGlzLmNvbnN1bWVyKCkuc291cmNlc0NvbnRlbnQgJiZcbiAgICAgIHRoaXMuY29uc3VtZXIoKS5zb3VyY2VzQ29udGVudC5sZW5ndGggPiAwXG4gICAgKVxuICB9XG5cbiAgc3RhcnRXaXRoKHN0cmluZywgc3RhcnQpIHtcbiAgICBpZiAoIXN0cmluZykgcmV0dXJuIGZhbHNlXG4gICAgcmV0dXJuIHN0cmluZy5zdWJzdHIoMCwgc3RhcnQubGVuZ3RoKSA9PT0gc3RhcnRcbiAgfVxuXG4gIGdldEFubm90YXRpb25VUkwoc291cmNlTWFwU3RyaW5nKSB7XG4gICAgcmV0dXJuIHNvdXJjZU1hcFN0cmluZy5yZXBsYWNlKC9eXFwvXFwqXFxzKiMgc291cmNlTWFwcGluZ1VSTD0vLCAnJykudHJpbSgpXG4gIH1cblxuICBsb2FkQW5ub3RhdGlvbihjc3MpIHtcbiAgICBsZXQgY29tbWVudHMgPSBjc3MubWF0Y2goL1xcL1xcKlxccyojIHNvdXJjZU1hcHBpbmdVUkw9L2dtKVxuICAgIGlmICghY29tbWVudHMpIHJldHVyblxuXG4gICAgLy8gc291cmNlTWFwcGluZ1VSTHMgZnJvbSBjb21tZW50cywgc3RyaW5ncywgZXRjLlxuICAgIGxldCBzdGFydCA9IGNzcy5sYXN0SW5kZXhPZihjb21tZW50cy5wb3AoKSlcbiAgICBsZXQgZW5kID0gY3NzLmluZGV4T2YoJyovJywgc3RhcnQpXG5cbiAgICBpZiAoc3RhcnQgPiAtMSAmJiBlbmQgPiAtMSkge1xuICAgICAgLy8gTG9jYXRlIHRoZSBsYXN0IHNvdXJjZU1hcHBpbmdVUkwgdG8gYXZvaWQgcGlja2luXG4gICAgICB0aGlzLmFubm90YXRpb24gPSB0aGlzLmdldEFubm90YXRpb25VUkwoY3NzLnN1YnN0cmluZyhzdGFydCwgZW5kKSlcbiAgICB9XG4gIH1cblxuICBkZWNvZGVJbmxpbmUodGV4dCkge1xuICAgIGxldCBiYXNlQ2hhcnNldFVyaSA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb247Y2hhcnNldD11dGYtPzg7YmFzZTY0LC9cbiAgICBsZXQgYmFzZVVyaSA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb247YmFzZTY0LC9cbiAgICBsZXQgY2hhcnNldFVyaSA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb247Y2hhcnNldD11dGYtPzgsL1xuICAgIGxldCB1cmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uLC9cblxuICAgIGlmIChjaGFyc2V0VXJpLnRlc3QodGV4dCkgfHwgdXJpLnRlc3QodGV4dCkpIHtcbiAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQodGV4dC5zdWJzdHIoUmVnRXhwLmxhc3RNYXRjaC5sZW5ndGgpKVxuICAgIH1cblxuICAgIGlmIChiYXNlQ2hhcnNldFVyaS50ZXN0KHRleHQpIHx8IGJhc2VVcmkudGVzdCh0ZXh0KSkge1xuICAgICAgcmV0dXJuIGZyb21CYXNlNjQodGV4dC5zdWJzdHIoUmVnRXhwLmxhc3RNYXRjaC5sZW5ndGgpKVxuICAgIH1cblxuICAgIGxldCBlbmNvZGluZyA9IHRleHQubWF0Y2goL2RhdGE6YXBwbGljYXRpb25cXC9qc29uOyhbXixdKyksLylbMV1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHNvdXJjZSBtYXAgZW5jb2RpbmcgJyArIGVuY29kaW5nKVxuICB9XG5cbiAgbG9hZEZpbGUocGF0aCkge1xuICAgIHRoaXMucm9vdCA9IGRpcm5hbWUocGF0aClcbiAgICBpZiAoZXhpc3RzU3luYyhwYXRoKSkge1xuICAgICAgdGhpcy5tYXBGaWxlID0gcGF0aFxuICAgICAgcmV0dXJuIHJlYWRGaWxlU3luYyhwYXRoLCAndXRmLTgnKS50b1N0cmluZygpLnRyaW0oKVxuICAgIH1cbiAgfVxuXG4gIGxvYWRNYXAoZmlsZSwgcHJldikge1xuICAgIGlmIChwcmV2ID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlXG5cbiAgICBpZiAocHJldikge1xuICAgICAgaWYgKHR5cGVvZiBwcmV2ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcHJldlxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHJldiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBsZXQgcHJldlBhdGggPSBwcmV2KGZpbGUpXG4gICAgICAgIGlmIChwcmV2UGF0aCkge1xuICAgICAgICAgIGxldCBtYXAgPSB0aGlzLmxvYWRGaWxlKHByZXZQYXRoKVxuICAgICAgICAgIGlmICghbWFwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICdVbmFibGUgdG8gbG9hZCBwcmV2aW91cyBzb3VyY2UgbWFwOiAnICsgcHJldlBhdGgudG9TdHJpbmcoKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWFwXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocHJldiBpbnN0YW5jZW9mIFNvdXJjZU1hcENvbnN1bWVyKSB7XG4gICAgICAgIHJldHVybiBTb3VyY2VNYXBHZW5lcmF0b3IuZnJvbVNvdXJjZU1hcChwcmV2KS50b1N0cmluZygpXG4gICAgICB9IGVsc2UgaWYgKHByZXYgaW5zdGFuY2VvZiBTb3VyY2VNYXBHZW5lcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHByZXYudG9TdHJpbmcoKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzTWFwKHByZXYpKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwcmV2KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdVbnN1cHBvcnRlZCBwcmV2aW91cyBzb3VyY2UgbWFwIGZvcm1hdDogJyArIHByZXYudG9TdHJpbmcoKVxuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlubGluZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlSW5saW5lKHRoaXMuYW5ub3RhdGlvbilcbiAgICB9IGVsc2UgaWYgKHRoaXMuYW5ub3RhdGlvbikge1xuICAgICAgbGV0IG1hcCA9IHRoaXMuYW5ub3RhdGlvblxuICAgICAgaWYgKGZpbGUpIG1hcCA9IGpvaW4oZGlybmFtZShmaWxlKSwgbWFwKVxuICAgICAgcmV0dXJuIHRoaXMubG9hZEZpbGUobWFwKVxuICAgIH1cbiAgfVxuXG4gIGlzTWFwKG1hcCkge1xuICAgIGlmICh0eXBlb2YgbWFwICE9PSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlXG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiBtYXAubWFwcGluZ3MgPT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgbWFwLl9tYXBwaW5ncyA9PT0gJ3N0cmluZycgfHxcbiAgICAgIEFycmF5LmlzQXJyYXkobWFwLnNlY3Rpb25zKVxuICAgIClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByZXZpb3VzTWFwXG5QcmV2aW91c01hcC5kZWZhdWx0ID0gUHJldmlvdXNNYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/previous-map.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/processor.js":
/*!***********************************************!*\
  !*** ./node_modules/postcss/lib/processor.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet NoWorkResult = __webpack_require__(/*! ./no-work-result */ \"./node_modules/postcss/lib/no-work-result.js\")\nlet LazyResult = __webpack_require__(/*! ./lazy-result */ \"./node_modules/postcss/lib/lazy-result.js\")\nlet Document = __webpack_require__(/*! ./document */ \"./node_modules/postcss/lib/document.js\")\nlet Root = __webpack_require__(/*! ./root */ \"./node_modules/postcss/lib/root.js\")\n\nclass Processor {\n  constructor(plugins = []) {\n    this.version = '8.4.19'\n    this.plugins = this.normalize(plugins)\n  }\n\n  use(plugin) {\n    this.plugins = this.plugins.concat(this.normalize([plugin]))\n    return this\n  }\n\n  process(css, opts = {}) {\n    if (\n      this.plugins.length === 0 &&\n      typeof opts.parser === 'undefined' &&\n      typeof opts.stringifier === 'undefined' &&\n      typeof opts.syntax === 'undefined'\n    ) {\n      return new NoWorkResult(this, css, opts)\n    } else {\n      return new LazyResult(this, css, opts)\n    }\n  }\n\n  normalize(plugins) {\n    let normalized = []\n    for (let i of plugins) {\n      if (i.postcss === true) {\n        i = i()\n      } else if (i.postcss) {\n        i = i.postcss\n      }\n\n      if (typeof i === 'object' && Array.isArray(i.plugins)) {\n        normalized = normalized.concat(i.plugins)\n      } else if (typeof i === 'object' && i.postcssPlugin) {\n        normalized.push(i)\n      } else if (typeof i === 'function') {\n        normalized.push(i)\n      } else if (typeof i === 'object' && (i.parse || i.stringify)) {\n        if (true) {\n          throw new Error(\n            'PostCSS syntaxes cannot be used as plugins. Instead, please use ' +\n              'one of the syntax/parser/stringifier options as outlined ' +\n              'in your PostCSS runner documentation.'\n          )\n        }\n      } else {\n        throw new Error(i + ' is not a PostCSS plugin')\n      }\n    }\n    return normalized\n  }\n}\n\nmodule.exports = Processor\nProcessor.default = Processor\n\nRoot.registerProcessor(Processor)\nDocument.registerProcessor(Processor)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcHJvY2Vzc29yLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLG1CQUFtQixtQkFBTyxDQUFDLHNFQUFrQjtBQUM3QyxpQkFBaUIsbUJBQU8sQ0FBQyxnRUFBZTtBQUN4QyxlQUFlLG1CQUFPLENBQUMsMERBQVk7QUFDbkMsV0FBVyxtQkFBTyxDQUFDLGtEQUFROztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1IsWUFBWSxJQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzL2xpYi9wcm9jZXNzb3IuanM/MjMzMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubGV0IE5vV29ya1Jlc3VsdCA9IHJlcXVpcmUoJy4vbm8td29yay1yZXN1bHQnKVxubGV0IExhenlSZXN1bHQgPSByZXF1aXJlKCcuL2xhenktcmVzdWx0JylcbmxldCBEb2N1bWVudCA9IHJlcXVpcmUoJy4vZG9jdW1lbnQnKVxubGV0IFJvb3QgPSByZXF1aXJlKCcuL3Jvb3QnKVxuXG5jbGFzcyBQcm9jZXNzb3Ige1xuICBjb25zdHJ1Y3RvcihwbHVnaW5zID0gW10pIHtcbiAgICB0aGlzLnZlcnNpb24gPSAnOC40LjE5J1xuICAgIHRoaXMucGx1Z2lucyA9IHRoaXMubm9ybWFsaXplKHBsdWdpbnMpXG4gIH1cblxuICB1c2UocGx1Z2luKSB7XG4gICAgdGhpcy5wbHVnaW5zID0gdGhpcy5wbHVnaW5zLmNvbmNhdCh0aGlzLm5vcm1hbGl6ZShbcGx1Z2luXSkpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHByb2Nlc3MoY3NzLCBvcHRzID0ge30pIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLnBsdWdpbnMubGVuZ3RoID09PSAwICYmXG4gICAgICB0eXBlb2Ygb3B0cy5wYXJzZXIgPT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2Ygb3B0cy5zdHJpbmdpZmllciA9PT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBvcHRzLnN5bnRheCA9PT0gJ3VuZGVmaW5lZCdcbiAgICApIHtcbiAgICAgIHJldHVybiBuZXcgTm9Xb3JrUmVzdWx0KHRoaXMsIGNzcywgb3B0cylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBMYXp5UmVzdWx0KHRoaXMsIGNzcywgb3B0cylcbiAgICB9XG4gIH1cblxuICBub3JtYWxpemUocGx1Z2lucykge1xuICAgIGxldCBub3JtYWxpemVkID0gW11cbiAgICBmb3IgKGxldCBpIG9mIHBsdWdpbnMpIHtcbiAgICAgIGlmIChpLnBvc3Rjc3MgPT09IHRydWUpIHtcbiAgICAgICAgaSA9IGkoKVxuICAgICAgfSBlbHNlIGlmIChpLnBvc3Rjc3MpIHtcbiAgICAgICAgaSA9IGkucG9zdGNzc1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGkgPT09ICdvYmplY3QnICYmIEFycmF5LmlzQXJyYXkoaS5wbHVnaW5zKSkge1xuICAgICAgICBub3JtYWxpemVkID0gbm9ybWFsaXplZC5jb25jYXQoaS5wbHVnaW5zKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaSA9PT0gJ29iamVjdCcgJiYgaS5wb3N0Y3NzUGx1Z2luKSB7XG4gICAgICAgIG5vcm1hbGl6ZWQucHVzaChpKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBub3JtYWxpemVkLnB1c2goaSlcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGkgPT09ICdvYmplY3QnICYmIChpLnBhcnNlIHx8IGkuc3RyaW5naWZ5KSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdQb3N0Q1NTIHN5bnRheGVzIGNhbm5vdCBiZSB1c2VkIGFzIHBsdWdpbnMuIEluc3RlYWQsIHBsZWFzZSB1c2UgJyArXG4gICAgICAgICAgICAgICdvbmUgb2YgdGhlIHN5bnRheC9wYXJzZXIvc3RyaW5naWZpZXIgb3B0aW9ucyBhcyBvdXRsaW5lZCAnICtcbiAgICAgICAgICAgICAgJ2luIHlvdXIgUG9zdENTUyBydW5uZXIgZG9jdW1lbnRhdGlvbi4nXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaSArICcgaXMgbm90IGEgUG9zdENTUyBwbHVnaW4nKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvY2Vzc29yXG5Qcm9jZXNzb3IuZGVmYXVsdCA9IFByb2Nlc3NvclxuXG5Sb290LnJlZ2lzdGVyUHJvY2Vzc29yKFByb2Nlc3NvcilcbkRvY3VtZW50LnJlZ2lzdGVyUHJvY2Vzc29yKFByb2Nlc3NvcilcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/processor.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/result.js":
/*!********************************************!*\
  !*** ./node_modules/postcss/lib/result.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Warning = __webpack_require__(/*! ./warning */ \"./node_modules/postcss/lib/warning.js\")\n\nclass Result {\n  constructor(processor, root, opts) {\n    this.processor = processor\n    this.messages = []\n    this.root = root\n    this.opts = opts\n    this.css = undefined\n    this.map = undefined\n  }\n\n  toString() {\n    return this.css\n  }\n\n  warn(text, opts = {}) {\n    if (!opts.plugin) {\n      if (this.lastPlugin && this.lastPlugin.postcssPlugin) {\n        opts.plugin = this.lastPlugin.postcssPlugin\n      }\n    }\n\n    let warning = new Warning(text, opts)\n    this.messages.push(warning)\n\n    return warning\n  }\n\n  warnings() {\n    return this.messages.filter(i => i.type === 'warning')\n  }\n\n  get content() {\n    return this.css\n  }\n}\n\nmodule.exports = Result\nResult.default = Result\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcmVzdWx0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGNBQWMsbUJBQU8sQ0FBQyx3REFBVzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcmVzdWx0LmpzPzM2OGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmxldCBXYXJuaW5nID0gcmVxdWlyZSgnLi93YXJuaW5nJylcblxuY2xhc3MgUmVzdWx0IHtcbiAgY29uc3RydWN0b3IocHJvY2Vzc29yLCByb290LCBvcHRzKSB7XG4gICAgdGhpcy5wcm9jZXNzb3IgPSBwcm9jZXNzb3JcbiAgICB0aGlzLm1lc3NhZ2VzID0gW11cbiAgICB0aGlzLnJvb3QgPSByb290XG4gICAgdGhpcy5vcHRzID0gb3B0c1xuICAgIHRoaXMuY3NzID0gdW5kZWZpbmVkXG4gICAgdGhpcy5tYXAgPSB1bmRlZmluZWRcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmNzc1xuICB9XG5cbiAgd2Fybih0ZXh0LCBvcHRzID0ge30pIHtcbiAgICBpZiAoIW9wdHMucGx1Z2luKSB7XG4gICAgICBpZiAodGhpcy5sYXN0UGx1Z2luICYmIHRoaXMubGFzdFBsdWdpbi5wb3N0Y3NzUGx1Z2luKSB7XG4gICAgICAgIG9wdHMucGx1Z2luID0gdGhpcy5sYXN0UGx1Z2luLnBvc3Rjc3NQbHVnaW5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgd2FybmluZyA9IG5ldyBXYXJuaW5nKHRleHQsIG9wdHMpXG4gICAgdGhpcy5tZXNzYWdlcy5wdXNoKHdhcm5pbmcpXG5cbiAgICByZXR1cm4gd2FybmluZ1xuICB9XG5cbiAgd2FybmluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZXMuZmlsdGVyKGkgPT4gaS50eXBlID09PSAnd2FybmluZycpXG4gIH1cblxuICBnZXQgY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jc3NcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlc3VsdFxuUmVzdWx0LmRlZmF1bHQgPSBSZXN1bHRcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/result.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/root.js":
/*!******************************************!*\
  !*** ./node_modules/postcss/lib/root.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Container = __webpack_require__(/*! ./container */ \"./node_modules/postcss/lib/container.js\")\n\nlet LazyResult, Processor\n\nclass Root extends Container {\n  constructor(defaults) {\n    super(defaults)\n    this.type = 'root'\n    if (!this.nodes) this.nodes = []\n  }\n\n  removeChild(child, ignore) {\n    let index = this.index(child)\n\n    if (!ignore && index === 0 && this.nodes.length > 1) {\n      this.nodes[1].raws.before = this.nodes[index].raws.before\n    }\n\n    return super.removeChild(child)\n  }\n\n  normalize(child, sample, type) {\n    let nodes = super.normalize(child)\n\n    if (sample) {\n      if (type === 'prepend') {\n        if (this.nodes.length > 1) {\n          sample.raws.before = this.nodes[1].raws.before\n        } else {\n          delete sample.raws.before\n        }\n      } else if (this.first !== sample) {\n        for (let node of nodes) {\n          node.raws.before = sample.raws.before\n        }\n      }\n    }\n\n    return nodes\n  }\n\n  toResult(opts = {}) {\n    let lazy = new LazyResult(new Processor(), this, opts)\n    return lazy.stringify()\n  }\n}\n\nRoot.registerLazyResult = dependant => {\n  LazyResult = dependant\n}\n\nRoot.registerProcessor = dependant => {\n  Processor = dependant\n}\n\nmodule.exports = Root\nRoot.default = Root\n\nContainer.registerRoot(Root)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcm9vdC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQyw0REFBYTs7QUFFckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL3Jvb3QuanM/NTlkMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubGV0IENvbnRhaW5lciA9IHJlcXVpcmUoJy4vY29udGFpbmVyJylcblxubGV0IExhenlSZXN1bHQsIFByb2Nlc3NvclxuXG5jbGFzcyBSb290IGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdHMpIHtcbiAgICBzdXBlcihkZWZhdWx0cylcbiAgICB0aGlzLnR5cGUgPSAncm9vdCdcbiAgICBpZiAoIXRoaXMubm9kZXMpIHRoaXMubm9kZXMgPSBbXVxuICB9XG5cbiAgcmVtb3ZlQ2hpbGQoY2hpbGQsIGlnbm9yZSkge1xuICAgIGxldCBpbmRleCA9IHRoaXMuaW5kZXgoY2hpbGQpXG5cbiAgICBpZiAoIWlnbm9yZSAmJiBpbmRleCA9PT0gMCAmJiB0aGlzLm5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMubm9kZXNbMV0ucmF3cy5iZWZvcmUgPSB0aGlzLm5vZGVzW2luZGV4XS5yYXdzLmJlZm9yZVxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5yZW1vdmVDaGlsZChjaGlsZClcbiAgfVxuXG4gIG5vcm1hbGl6ZShjaGlsZCwgc2FtcGxlLCB0eXBlKSB7XG4gICAgbGV0IG5vZGVzID0gc3VwZXIubm9ybWFsaXplKGNoaWxkKVxuXG4gICAgaWYgKHNhbXBsZSkge1xuICAgICAgaWYgKHR5cGUgPT09ICdwcmVwZW5kJykge1xuICAgICAgICBpZiAodGhpcy5ub2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgc2FtcGxlLnJhd3MuYmVmb3JlID0gdGhpcy5ub2Rlc1sxXS5yYXdzLmJlZm9yZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBzYW1wbGUucmF3cy5iZWZvcmVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmZpcnN0ICE9PSBzYW1wbGUpIHtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICAgIG5vZGUucmF3cy5iZWZvcmUgPSBzYW1wbGUucmF3cy5iZWZvcmVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2Rlc1xuICB9XG5cbiAgdG9SZXN1bHQob3B0cyA9IHt9KSB7XG4gICAgbGV0IGxhenkgPSBuZXcgTGF6eVJlc3VsdChuZXcgUHJvY2Vzc29yKCksIHRoaXMsIG9wdHMpXG4gICAgcmV0dXJuIGxhenkuc3RyaW5naWZ5KClcbiAgfVxufVxuXG5Sb290LnJlZ2lzdGVyTGF6eVJlc3VsdCA9IGRlcGVuZGFudCA9PiB7XG4gIExhenlSZXN1bHQgPSBkZXBlbmRhbnRcbn1cblxuUm9vdC5yZWdpc3RlclByb2Nlc3NvciA9IGRlcGVuZGFudCA9PiB7XG4gIFByb2Nlc3NvciA9IGRlcGVuZGFudFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJvb3RcblJvb3QuZGVmYXVsdCA9IFJvb3RcblxuQ29udGFpbmVyLnJlZ2lzdGVyUm9vdChSb290KVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/root.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/rule.js":
/*!******************************************!*\
  !*** ./node_modules/postcss/lib/rule.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Container = __webpack_require__(/*! ./container */ \"./node_modules/postcss/lib/container.js\")\nlet list = __webpack_require__(/*! ./list */ \"./node_modules/postcss/lib/list.js\")\n\nclass Rule extends Container {\n  constructor(defaults) {\n    super(defaults)\n    this.type = 'rule'\n    if (!this.nodes) this.nodes = []\n  }\n\n  get selectors() {\n    return list.comma(this.selector)\n  }\n\n  set selectors(values) {\n    let match = this.selector ? this.selector.match(/,\\s*/) : null\n    let sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen')\n    this.selector = values.join(sep)\n  }\n}\n\nmodule.exports = Rule\nRule.default = Rule\n\nContainer.registerRule(Rule)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcnVsZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQyw0REFBYTtBQUNyQyxXQUFXLG1CQUFPLENBQUMsa0RBQVE7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcnVsZS5qcz81M2JhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5sZXQgQ29udGFpbmVyID0gcmVxdWlyZSgnLi9jb250YWluZXInKVxubGV0IGxpc3QgPSByZXF1aXJlKCcuL2xpc3QnKVxuXG5jbGFzcyBSdWxlIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdHMpIHtcbiAgICBzdXBlcihkZWZhdWx0cylcbiAgICB0aGlzLnR5cGUgPSAncnVsZSdcbiAgICBpZiAoIXRoaXMubm9kZXMpIHRoaXMubm9kZXMgPSBbXVxuICB9XG5cbiAgZ2V0IHNlbGVjdG9ycygpIHtcbiAgICByZXR1cm4gbGlzdC5jb21tYSh0aGlzLnNlbGVjdG9yKVxuICB9XG5cbiAgc2V0IHNlbGVjdG9ycyh2YWx1ZXMpIHtcbiAgICBsZXQgbWF0Y2ggPSB0aGlzLnNlbGVjdG9yID8gdGhpcy5zZWxlY3Rvci5tYXRjaCgvLFxccyovKSA6IG51bGxcbiAgICBsZXQgc2VwID0gbWF0Y2ggPyBtYXRjaFswXSA6ICcsJyArIHRoaXMucmF3KCdiZXR3ZWVuJywgJ2JlZm9yZU9wZW4nKVxuICAgIHRoaXMuc2VsZWN0b3IgPSB2YWx1ZXMuam9pbihzZXApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSdWxlXG5SdWxlLmRlZmF1bHQgPSBSdWxlXG5cbkNvbnRhaW5lci5yZWdpc3RlclJ1bGUoUnVsZSlcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/rule.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/stringifier.js":
/*!*************************************************!*\
  !*** ./node_modules/postcss/lib/stringifier.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst DEFAULT_RAW = {\n  colon: ': ',\n  indent: '    ',\n  beforeDecl: '\\n',\n  beforeRule: '\\n',\n  beforeOpen: ' ',\n  beforeClose: '\\n',\n  beforeComment: '\\n',\n  after: '\\n',\n  emptyBody: '',\n  commentLeft: ' ',\n  commentRight: ' ',\n  semicolon: false\n}\n\nfunction capitalize(str) {\n  return str[0].toUpperCase() + str.slice(1)\n}\n\nclass Stringifier {\n  constructor(builder) {\n    this.builder = builder\n  }\n\n  stringify(node, semicolon) {\n    /* c8 ignore start */\n    if (!this[node.type]) {\n      throw new Error(\n        'Unknown AST node type ' +\n          node.type +\n          '. ' +\n          'Maybe you need to change PostCSS stringifier.'\n      )\n    }\n    /* c8 ignore stop */\n    this[node.type](node, semicolon)\n  }\n\n  document(node) {\n    this.body(node)\n  }\n\n  root(node) {\n    this.body(node)\n    if (node.raws.after) this.builder(node.raws.after)\n  }\n\n  comment(node) {\n    let left = this.raw(node, 'left', 'commentLeft')\n    let right = this.raw(node, 'right', 'commentRight')\n    this.builder('/*' + left + node.text + right + '*/', node)\n  }\n\n  decl(node, semicolon) {\n    let between = this.raw(node, 'between', 'colon')\n    let string = node.prop + between + this.rawValue(node, 'value')\n\n    if (node.important) {\n      string += node.raws.important || ' !important'\n    }\n\n    if (semicolon) string += ';'\n    this.builder(string, node)\n  }\n\n  rule(node) {\n    this.block(node, this.rawValue(node, 'selector'))\n    if (node.raws.ownSemicolon) {\n      this.builder(node.raws.ownSemicolon, node, 'end')\n    }\n  }\n\n  atrule(node, semicolon) {\n    let name = '@' + node.name\n    let params = node.params ? this.rawValue(node, 'params') : ''\n\n    if (typeof node.raws.afterName !== 'undefined') {\n      name += node.raws.afterName\n    } else if (params) {\n      name += ' '\n    }\n\n    if (node.nodes) {\n      this.block(node, name + params)\n    } else {\n      let end = (node.raws.between || '') + (semicolon ? ';' : '')\n      this.builder(name + params + end, node)\n    }\n  }\n\n  body(node) {\n    let last = node.nodes.length - 1\n    while (last > 0) {\n      if (node.nodes[last].type !== 'comment') break\n      last -= 1\n    }\n\n    let semicolon = this.raw(node, 'semicolon')\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i]\n      let before = this.raw(child, 'before')\n      if (before) this.builder(before)\n      this.stringify(child, last !== i || semicolon)\n    }\n  }\n\n  block(node, start) {\n    let between = this.raw(node, 'between', 'beforeOpen')\n    this.builder(start + between + '{', node, 'start')\n\n    let after\n    if (node.nodes && node.nodes.length) {\n      this.body(node)\n      after = this.raw(node, 'after')\n    } else {\n      after = this.raw(node, 'after', 'emptyBody')\n    }\n\n    if (after) this.builder(after)\n    this.builder('}', node, 'end')\n  }\n\n  raw(node, own, detect) {\n    let value\n    if (!detect) detect = own\n\n    // Already had\n    if (own) {\n      value = node.raws[own]\n      if (typeof value !== 'undefined') return value\n    }\n\n    let parent = node.parent\n\n    if (detect === 'before') {\n      // Hack for first rule in CSS\n      if (!parent || (parent.type === 'root' && parent.first === node)) {\n        return ''\n      }\n\n      // `root` nodes in `document` should use only their own raws\n      if (parent && parent.type === 'document') {\n        return ''\n      }\n    }\n\n    // Floating child without parent\n    if (!parent) return DEFAULT_RAW[detect]\n\n    // Detect style by other nodes\n    let root = node.root()\n    if (!root.rawCache) root.rawCache = {}\n    if (typeof root.rawCache[detect] !== 'undefined') {\n      return root.rawCache[detect]\n    }\n\n    if (detect === 'before' || detect === 'after') {\n      return this.beforeAfter(node, detect)\n    } else {\n      let method = 'raw' + capitalize(detect)\n      if (this[method]) {\n        value = this[method](root, node)\n      } else {\n        root.walk(i => {\n          value = i.raws[own]\n          if (typeof value !== 'undefined') return false\n        })\n      }\n    }\n\n    if (typeof value === 'undefined') value = DEFAULT_RAW[detect]\n\n    root.rawCache[detect] = value\n    return value\n  }\n\n  rawSemicolon(root) {\n    let value\n    root.walk(i => {\n      if (i.nodes && i.nodes.length && i.last.type === 'decl') {\n        value = i.raws.semicolon\n        if (typeof value !== 'undefined') return false\n      }\n    })\n    return value\n  }\n\n  rawEmptyBody(root) {\n    let value\n    root.walk(i => {\n      if (i.nodes && i.nodes.length === 0) {\n        value = i.raws.after\n        if (typeof value !== 'undefined') return false\n      }\n    })\n    return value\n  }\n\n  rawIndent(root) {\n    if (root.raws.indent) return root.raws.indent\n    let value\n    root.walk(i => {\n      let p = i.parent\n      if (p && p !== root && p.parent && p.parent === root) {\n        if (typeof i.raws.before !== 'undefined') {\n          let parts = i.raws.before.split('\\n')\n          value = parts[parts.length - 1]\n          value = value.replace(/\\S/g, '')\n          return false\n        }\n      }\n    })\n    return value\n  }\n\n  rawBeforeComment(root, node) {\n    let value\n    root.walkComments(i => {\n      if (typeof i.raws.before !== 'undefined') {\n        value = i.raws.before\n        if (value.includes('\\n')) {\n          value = value.replace(/[^\\n]+$/, '')\n        }\n        return false\n      }\n    })\n    if (typeof value === 'undefined') {\n      value = this.raw(node, null, 'beforeDecl')\n    } else if (value) {\n      value = value.replace(/\\S/g, '')\n    }\n    return value\n  }\n\n  rawBeforeDecl(root, node) {\n    let value\n    root.walkDecls(i => {\n      if (typeof i.raws.before !== 'undefined') {\n        value = i.raws.before\n        if (value.includes('\\n')) {\n          value = value.replace(/[^\\n]+$/, '')\n        }\n        return false\n      }\n    })\n    if (typeof value === 'undefined') {\n      value = this.raw(node, null, 'beforeRule')\n    } else if (value) {\n      value = value.replace(/\\S/g, '')\n    }\n    return value\n  }\n\n  rawBeforeRule(root) {\n    let value\n    root.walk(i => {\n      if (i.nodes && (i.parent !== root || root.first !== i)) {\n        if (typeof i.raws.before !== 'undefined') {\n          value = i.raws.before\n          if (value.includes('\\n')) {\n            value = value.replace(/[^\\n]+$/, '')\n          }\n          return false\n        }\n      }\n    })\n    if (value) value = value.replace(/\\S/g, '')\n    return value\n  }\n\n  rawBeforeClose(root) {\n    let value\n    root.walk(i => {\n      if (i.nodes && i.nodes.length > 0) {\n        if (typeof i.raws.after !== 'undefined') {\n          value = i.raws.after\n          if (value.includes('\\n')) {\n            value = value.replace(/[^\\n]+$/, '')\n          }\n          return false\n        }\n      }\n    })\n    if (value) value = value.replace(/\\S/g, '')\n    return value\n  }\n\n  rawBeforeOpen(root) {\n    let value\n    root.walk(i => {\n      if (i.type !== 'decl') {\n        value = i.raws.between\n        if (typeof value !== 'undefined') return false\n      }\n    })\n    return value\n  }\n\n  rawColon(root) {\n    let value\n    root.walkDecls(i => {\n      if (typeof i.raws.between !== 'undefined') {\n        value = i.raws.between.replace(/[^\\s:]/g, '')\n        return false\n      }\n    })\n    return value\n  }\n\n  beforeAfter(node, detect) {\n    let value\n    if (node.type === 'decl') {\n      value = this.raw(node, null, 'beforeDecl')\n    } else if (node.type === 'comment') {\n      value = this.raw(node, null, 'beforeComment')\n    } else if (detect === 'before') {\n      value = this.raw(node, null, 'beforeRule')\n    } else {\n      value = this.raw(node, null, 'beforeClose')\n    }\n\n    let buf = node.parent\n    let depth = 0\n    while (buf && buf.type !== 'root') {\n      depth += 1\n      buf = buf.parent\n    }\n\n    if (value.includes('\\n')) {\n      let indent = this.raw(node, null, 'indent')\n      if (indent.length) {\n        for (let step = 0; step < depth; step++) value += indent\n      }\n    }\n\n    return value\n  }\n\n  rawValue(node, prop) {\n    let value = node[prop]\n    let raw = node.raws[prop]\n    if (raw && raw.value === value) {\n      return raw.raw\n    }\n\n    return value\n  }\n}\n\nmodule.exports = Stringifier\nStringifier.default = Stringifier\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvc3RyaW5naWZpZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvc3RyaW5naWZpZXIuanM/ODM1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgREVGQVVMVF9SQVcgPSB7XG4gIGNvbG9uOiAnOiAnLFxuICBpbmRlbnQ6ICcgICAgJyxcbiAgYmVmb3JlRGVjbDogJ1xcbicsXG4gIGJlZm9yZVJ1bGU6ICdcXG4nLFxuICBiZWZvcmVPcGVuOiAnICcsXG4gIGJlZm9yZUNsb3NlOiAnXFxuJyxcbiAgYmVmb3JlQ29tbWVudDogJ1xcbicsXG4gIGFmdGVyOiAnXFxuJyxcbiAgZW1wdHlCb2R5OiAnJyxcbiAgY29tbWVudExlZnQ6ICcgJyxcbiAgY29tbWVudFJpZ2h0OiAnICcsXG4gIHNlbWljb2xvbjogZmFsc2Vcbn1cblxuZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHIpIHtcbiAgcmV0dXJuIHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59XG5cbmNsYXNzIFN0cmluZ2lmaWVyIHtcbiAgY29uc3RydWN0b3IoYnVpbGRlcikge1xuICAgIHRoaXMuYnVpbGRlciA9IGJ1aWxkZXJcbiAgfVxuXG4gIHN0cmluZ2lmeShub2RlLCBzZW1pY29sb24pIHtcbiAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICBpZiAoIXRoaXNbbm9kZS50eXBlXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVW5rbm93biBBU1Qgbm9kZSB0eXBlICcgK1xuICAgICAgICAgIG5vZGUudHlwZSArXG4gICAgICAgICAgJy4gJyArXG4gICAgICAgICAgJ01heWJlIHlvdSBuZWVkIHRvIGNoYW5nZSBQb3N0Q1NTIHN0cmluZ2lmaWVyLidcbiAgICAgIClcbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICB0aGlzW25vZGUudHlwZV0obm9kZSwgc2VtaWNvbG9uKVxuICB9XG5cbiAgZG9jdW1lbnQobm9kZSkge1xuICAgIHRoaXMuYm9keShub2RlKVxuICB9XG5cbiAgcm9vdChub2RlKSB7XG4gICAgdGhpcy5ib2R5KG5vZGUpXG4gICAgaWYgKG5vZGUucmF3cy5hZnRlcikgdGhpcy5idWlsZGVyKG5vZGUucmF3cy5hZnRlcilcbiAgfVxuXG4gIGNvbW1lbnQobm9kZSkge1xuICAgIGxldCBsZWZ0ID0gdGhpcy5yYXcobm9kZSwgJ2xlZnQnLCAnY29tbWVudExlZnQnKVxuICAgIGxldCByaWdodCA9IHRoaXMucmF3KG5vZGUsICdyaWdodCcsICdjb21tZW50UmlnaHQnKVxuICAgIHRoaXMuYnVpbGRlcignLyonICsgbGVmdCArIG5vZGUudGV4dCArIHJpZ2h0ICsgJyovJywgbm9kZSlcbiAgfVxuXG4gIGRlY2wobm9kZSwgc2VtaWNvbG9uKSB7XG4gICAgbGV0IGJldHdlZW4gPSB0aGlzLnJhdyhub2RlLCAnYmV0d2VlbicsICdjb2xvbicpXG4gICAgbGV0IHN0cmluZyA9IG5vZGUucHJvcCArIGJldHdlZW4gKyB0aGlzLnJhd1ZhbHVlKG5vZGUsICd2YWx1ZScpXG5cbiAgICBpZiAobm9kZS5pbXBvcnRhbnQpIHtcbiAgICAgIHN0cmluZyArPSBub2RlLnJhd3MuaW1wb3J0YW50IHx8ICcgIWltcG9ydGFudCdcbiAgICB9XG5cbiAgICBpZiAoc2VtaWNvbG9uKSBzdHJpbmcgKz0gJzsnXG4gICAgdGhpcy5idWlsZGVyKHN0cmluZywgbm9kZSlcbiAgfVxuXG4gIHJ1bGUobm9kZSkge1xuICAgIHRoaXMuYmxvY2sobm9kZSwgdGhpcy5yYXdWYWx1ZShub2RlLCAnc2VsZWN0b3InKSlcbiAgICBpZiAobm9kZS5yYXdzLm93blNlbWljb2xvbikge1xuICAgICAgdGhpcy5idWlsZGVyKG5vZGUucmF3cy5vd25TZW1pY29sb24sIG5vZGUsICdlbmQnKVxuICAgIH1cbiAgfVxuXG4gIGF0cnVsZShub2RlLCBzZW1pY29sb24pIHtcbiAgICBsZXQgbmFtZSA9ICdAJyArIG5vZGUubmFtZVxuICAgIGxldCBwYXJhbXMgPSBub2RlLnBhcmFtcyA/IHRoaXMucmF3VmFsdWUobm9kZSwgJ3BhcmFtcycpIDogJydcblxuICAgIGlmICh0eXBlb2Ygbm9kZS5yYXdzLmFmdGVyTmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG5hbWUgKz0gbm9kZS5yYXdzLmFmdGVyTmFtZVxuICAgIH0gZWxzZSBpZiAocGFyYW1zKSB7XG4gICAgICBuYW1lICs9ICcgJ1xuICAgIH1cblxuICAgIGlmIChub2RlLm5vZGVzKSB7XG4gICAgICB0aGlzLmJsb2NrKG5vZGUsIG5hbWUgKyBwYXJhbXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBlbmQgPSAobm9kZS5yYXdzLmJldHdlZW4gfHwgJycpICsgKHNlbWljb2xvbiA/ICc7JyA6ICcnKVxuICAgICAgdGhpcy5idWlsZGVyKG5hbWUgKyBwYXJhbXMgKyBlbmQsIG5vZGUpXG4gICAgfVxuICB9XG5cbiAgYm9keShub2RlKSB7XG4gICAgbGV0IGxhc3QgPSBub2RlLm5vZGVzLmxlbmd0aCAtIDFcbiAgICB3aGlsZSAobGFzdCA+IDApIHtcbiAgICAgIGlmIChub2RlLm5vZGVzW2xhc3RdLnR5cGUgIT09ICdjb21tZW50JykgYnJlYWtcbiAgICAgIGxhc3QgLT0gMVxuICAgIH1cblxuICAgIGxldCBzZW1pY29sb24gPSB0aGlzLnJhdyhub2RlLCAnc2VtaWNvbG9uJylcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUubm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBjaGlsZCA9IG5vZGUubm9kZXNbaV1cbiAgICAgIGxldCBiZWZvcmUgPSB0aGlzLnJhdyhjaGlsZCwgJ2JlZm9yZScpXG4gICAgICBpZiAoYmVmb3JlKSB0aGlzLmJ1aWxkZXIoYmVmb3JlKVxuICAgICAgdGhpcy5zdHJpbmdpZnkoY2hpbGQsIGxhc3QgIT09IGkgfHwgc2VtaWNvbG9uKVxuICAgIH1cbiAgfVxuXG4gIGJsb2NrKG5vZGUsIHN0YXJ0KSB7XG4gICAgbGV0IGJldHdlZW4gPSB0aGlzLnJhdyhub2RlLCAnYmV0d2VlbicsICdiZWZvcmVPcGVuJylcbiAgICB0aGlzLmJ1aWxkZXIoc3RhcnQgKyBiZXR3ZWVuICsgJ3snLCBub2RlLCAnc3RhcnQnKVxuXG4gICAgbGV0IGFmdGVyXG4gICAgaWYgKG5vZGUubm9kZXMgJiYgbm9kZS5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuYm9keShub2RlKVxuICAgICAgYWZ0ZXIgPSB0aGlzLnJhdyhub2RlLCAnYWZ0ZXInKVxuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlciA9IHRoaXMucmF3KG5vZGUsICdhZnRlcicsICdlbXB0eUJvZHknKVxuICAgIH1cblxuICAgIGlmIChhZnRlcikgdGhpcy5idWlsZGVyKGFmdGVyKVxuICAgIHRoaXMuYnVpbGRlcignfScsIG5vZGUsICdlbmQnKVxuICB9XG5cbiAgcmF3KG5vZGUsIG93biwgZGV0ZWN0KSB7XG4gICAgbGV0IHZhbHVlXG4gICAgaWYgKCFkZXRlY3QpIGRldGVjdCA9IG93blxuXG4gICAgLy8gQWxyZWFkeSBoYWRcbiAgICBpZiAob3duKSB7XG4gICAgICB2YWx1ZSA9IG5vZGUucmF3c1tvd25dXG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50XG5cbiAgICBpZiAoZGV0ZWN0ID09PSAnYmVmb3JlJykge1xuICAgICAgLy8gSGFjayBmb3IgZmlyc3QgcnVsZSBpbiBDU1NcbiAgICAgIGlmICghcGFyZW50IHx8IChwYXJlbnQudHlwZSA9PT0gJ3Jvb3QnICYmIHBhcmVudC5maXJzdCA9PT0gbm9kZSkpIHtcbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9XG5cbiAgICAgIC8vIGByb290YCBub2RlcyBpbiBgZG9jdW1lbnRgIHNob3VsZCB1c2Ugb25seSB0aGVpciBvd24gcmF3c1xuICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQudHlwZSA9PT0gJ2RvY3VtZW50Jykge1xuICAgICAgICByZXR1cm4gJydcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGbG9hdGluZyBjaGlsZCB3aXRob3V0IHBhcmVudFxuICAgIGlmICghcGFyZW50KSByZXR1cm4gREVGQVVMVF9SQVdbZGV0ZWN0XVxuXG4gICAgLy8gRGV0ZWN0IHN0eWxlIGJ5IG90aGVyIG5vZGVzXG4gICAgbGV0IHJvb3QgPSBub2RlLnJvb3QoKVxuICAgIGlmICghcm9vdC5yYXdDYWNoZSkgcm9vdC5yYXdDYWNoZSA9IHt9XG4gICAgaWYgKHR5cGVvZiByb290LnJhd0NhY2hlW2RldGVjdF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gcm9vdC5yYXdDYWNoZVtkZXRlY3RdXG4gICAgfVxuXG4gICAgaWYgKGRldGVjdCA9PT0gJ2JlZm9yZScgfHwgZGV0ZWN0ID09PSAnYWZ0ZXInKSB7XG4gICAgICByZXR1cm4gdGhpcy5iZWZvcmVBZnRlcihub2RlLCBkZXRlY3QpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBtZXRob2QgPSAncmF3JyArIGNhcGl0YWxpemUoZGV0ZWN0KVxuICAgICAgaWYgKHRoaXNbbWV0aG9kXSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXNbbWV0aG9kXShyb290LCBub2RlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC53YWxrKGkgPT4ge1xuICAgICAgICAgIHZhbHVlID0gaS5yYXdzW293bl1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHZhbHVlID0gREVGQVVMVF9SQVdbZGV0ZWN0XVxuXG4gICAgcm9vdC5yYXdDYWNoZVtkZXRlY3RdID0gdmFsdWVcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIHJhd1NlbWljb2xvbihyb290KSB7XG4gICAgbGV0IHZhbHVlXG4gICAgcm9vdC53YWxrKGkgPT4ge1xuICAgICAgaWYgKGkubm9kZXMgJiYgaS5ub2Rlcy5sZW5ndGggJiYgaS5sYXN0LnR5cGUgPT09ICdkZWNsJykge1xuICAgICAgICB2YWx1ZSA9IGkucmF3cy5zZW1pY29sb25cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICByYXdFbXB0eUJvZHkocm9vdCkge1xuICAgIGxldCB2YWx1ZVxuICAgIHJvb3Qud2FsayhpID0+IHtcbiAgICAgIGlmIChpLm5vZGVzICYmIGkubm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhbHVlID0gaS5yYXdzLmFmdGVyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgcmF3SW5kZW50KHJvb3QpIHtcbiAgICBpZiAocm9vdC5yYXdzLmluZGVudCkgcmV0dXJuIHJvb3QucmF3cy5pbmRlbnRcbiAgICBsZXQgdmFsdWVcbiAgICByb290LndhbGsoaSA9PiB7XG4gICAgICBsZXQgcCA9IGkucGFyZW50XG4gICAgICBpZiAocCAmJiBwICE9PSByb290ICYmIHAucGFyZW50ICYmIHAucGFyZW50ID09PSByb290KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaS5yYXdzLmJlZm9yZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBsZXQgcGFydHMgPSBpLnJhd3MuYmVmb3JlLnNwbGl0KCdcXG4nKVxuICAgICAgICAgIHZhbHVlID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV1cbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcUy9nLCAnJylcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICByYXdCZWZvcmVDb21tZW50KHJvb3QsIG5vZGUpIHtcbiAgICBsZXQgdmFsdWVcbiAgICByb290LndhbGtDb21tZW50cyhpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaS5yYXdzLmJlZm9yZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFsdWUgPSBpLnJhd3MuYmVmb3JlXG4gICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcygnXFxuJykpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywgJycpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSlcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlLCBudWxsLCAnYmVmb3JlRGVjbCcpXG4gICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgJycpXG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgcmF3QmVmb3JlRGVjbChyb290LCBub2RlKSB7XG4gICAgbGV0IHZhbHVlXG4gICAgcm9vdC53YWxrRGVjbHMoaSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGkucmF3cy5iZWZvcmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhbHVlID0gaS5yYXdzLmJlZm9yZVxuICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoJ1xcbicpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sICcnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZSwgbnVsbCwgJ2JlZm9yZVJ1bGUnKVxuICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csICcnKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIHJhd0JlZm9yZVJ1bGUocm9vdCkge1xuICAgIGxldCB2YWx1ZVxuICAgIHJvb3Qud2FsayhpID0+IHtcbiAgICAgIGlmIChpLm5vZGVzICYmIChpLnBhcmVudCAhPT0gcm9vdCB8fCByb290LmZpcnN0ICE9PSBpKSkge1xuICAgICAgICBpZiAodHlwZW9mIGkucmF3cy5iZWZvcmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdmFsdWUgPSBpLnJhd3MuYmVmb3JlXG4gICAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKCdcXG4nKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sICcnKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKHZhbHVlKSB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcUy9nLCAnJylcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIHJhd0JlZm9yZUNsb3NlKHJvb3QpIHtcbiAgICBsZXQgdmFsdWVcbiAgICByb290LndhbGsoaSA9PiB7XG4gICAgICBpZiAoaS5ub2RlcyAmJiBpLm5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpLnJhd3MuYWZ0ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdmFsdWUgPSBpLnJhd3MuYWZ0ZXJcbiAgICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoJ1xcbicpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywgJycpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgICBpZiAodmFsdWUpIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csICcnKVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgcmF3QmVmb3JlT3Blbihyb290KSB7XG4gICAgbGV0IHZhbHVlXG4gICAgcm9vdC53YWxrKGkgPT4ge1xuICAgICAgaWYgKGkudHlwZSAhPT0gJ2RlY2wnKSB7XG4gICAgICAgIHZhbHVlID0gaS5yYXdzLmJldHdlZW5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICByYXdDb2xvbihyb290KSB7XG4gICAgbGV0IHZhbHVlXG4gICAgcm9vdC53YWxrRGVjbHMoaSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGkucmF3cy5iZXR3ZWVuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YWx1ZSA9IGkucmF3cy5iZXR3ZWVuLnJlcGxhY2UoL1teXFxzOl0vZywgJycpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICBiZWZvcmVBZnRlcihub2RlLCBkZXRlY3QpIHtcbiAgICBsZXQgdmFsdWVcbiAgICBpZiAobm9kZS50eXBlID09PSAnZGVjbCcpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZSwgbnVsbCwgJ2JlZm9yZURlY2wnKVxuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAnY29tbWVudCcpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZSwgbnVsbCwgJ2JlZm9yZUNvbW1lbnQnKVxuICAgIH0gZWxzZSBpZiAoZGV0ZWN0ID09PSAnYmVmb3JlJykge1xuICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlLCBudWxsLCAnYmVmb3JlUnVsZScpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZSwgbnVsbCwgJ2JlZm9yZUNsb3NlJylcbiAgICB9XG5cbiAgICBsZXQgYnVmID0gbm9kZS5wYXJlbnRcbiAgICBsZXQgZGVwdGggPSAwXG4gICAgd2hpbGUgKGJ1ZiAmJiBidWYudHlwZSAhPT0gJ3Jvb3QnKSB7XG4gICAgICBkZXB0aCArPSAxXG4gICAgICBidWYgPSBidWYucGFyZW50XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLmluY2x1ZGVzKCdcXG4nKSkge1xuICAgICAgbGV0IGluZGVudCA9IHRoaXMucmF3KG5vZGUsIG51bGwsICdpbmRlbnQnKVxuICAgICAgaWYgKGluZGVudC5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgc3RlcCA9IDA7IHN0ZXAgPCBkZXB0aDsgc3RlcCsrKSB2YWx1ZSArPSBpbmRlbnRcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIHJhd1ZhbHVlKG5vZGUsIHByb3ApIHtcbiAgICBsZXQgdmFsdWUgPSBub2RlW3Byb3BdXG4gICAgbGV0IHJhdyA9IG5vZGUucmF3c1twcm9wXVxuICAgIGlmIChyYXcgJiYgcmF3LnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHJhdy5yYXdcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmluZ2lmaWVyXG5TdHJpbmdpZmllci5kZWZhdWx0ID0gU3RyaW5naWZpZXJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/stringifier.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/stringify.js":
/*!***********************************************!*\
  !*** ./node_modules/postcss/lib/stringify.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Stringifier = __webpack_require__(/*! ./stringifier */ \"./node_modules/postcss/lib/stringifier.js\")\n\nfunction stringify(node, builder) {\n  let str = new Stringifier(builder)\n  str.stringify(node)\n}\n\nmodule.exports = stringify\nstringify.default = stringify\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvc3RyaW5naWZ5LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGtCQUFrQixtQkFBTyxDQUFDLGdFQUFlOztBQUV6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL3N0cmluZ2lmeS5qcz9kN2MzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5sZXQgU3RyaW5naWZpZXIgPSByZXF1aXJlKCcuL3N0cmluZ2lmaWVyJylcblxuZnVuY3Rpb24gc3RyaW5naWZ5KG5vZGUsIGJ1aWxkZXIpIHtcbiAgbGV0IHN0ciA9IG5ldyBTdHJpbmdpZmllcihidWlsZGVyKVxuICBzdHIuc3RyaW5naWZ5KG5vZGUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5naWZ5XG5zdHJpbmdpZnkuZGVmYXVsdCA9IHN0cmluZ2lmeVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/stringify.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/symbols.js":
/*!*********************************************!*\
  !*** ./node_modules/postcss/lib/symbols.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports.isClean = Symbol('isClean')\n\nmodule.exports.my = Symbol('my')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvc3ltYm9scy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixzQkFBc0I7O0FBRXRCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzL2xpYi9zeW1ib2xzLmpzP2IwY2IiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzLmlzQ2xlYW4gPSBTeW1ib2woJ2lzQ2xlYW4nKVxuXG5tb2R1bGUuZXhwb3J0cy5teSA9IFN5bWJvbCgnbXknKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/symbols.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/tokenize.js":
/*!**********************************************!*\
  !*** ./node_modules/postcss/lib/tokenize.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst SINGLE_QUOTE = \"'\".charCodeAt(0)\nconst DOUBLE_QUOTE = '\"'.charCodeAt(0)\nconst BACKSLASH = '\\\\'.charCodeAt(0)\nconst SLASH = '/'.charCodeAt(0)\nconst NEWLINE = '\\n'.charCodeAt(0)\nconst SPACE = ' '.charCodeAt(0)\nconst FEED = '\\f'.charCodeAt(0)\nconst TAB = '\\t'.charCodeAt(0)\nconst CR = '\\r'.charCodeAt(0)\nconst OPEN_SQUARE = '['.charCodeAt(0)\nconst CLOSE_SQUARE = ']'.charCodeAt(0)\nconst OPEN_PARENTHESES = '('.charCodeAt(0)\nconst CLOSE_PARENTHESES = ')'.charCodeAt(0)\nconst OPEN_CURLY = '{'.charCodeAt(0)\nconst CLOSE_CURLY = '}'.charCodeAt(0)\nconst SEMICOLON = ';'.charCodeAt(0)\nconst ASTERISK = '*'.charCodeAt(0)\nconst COLON = ':'.charCodeAt(0)\nconst AT = '@'.charCodeAt(0)\n\nconst RE_AT_END = /[\\t\\n\\f\\r \"#'()/;[\\\\\\]{}]/g\nconst RE_WORD_END = /[\\t\\n\\f\\r !\"#'():;@[\\\\\\]{}]|\\/(?=\\*)/g\nconst RE_BAD_BRACKET = /.[\\n\"'(/\\\\]/\nconst RE_HEX_ESCAPE = /[\\da-f]/i\n\nmodule.exports = function tokenizer(input, options = {}) {\n  let css = input.css.valueOf()\n  let ignore = options.ignoreErrors\n\n  let code, next, quote, content, escape\n  let escaped, escapePos, prev, n, currentToken\n\n  let length = css.length\n  let pos = 0\n  let buffer = []\n  let returned = []\n\n  function position() {\n    return pos\n  }\n\n  function unclosed(what) {\n    throw input.error('Unclosed ' + what, pos)\n  }\n\n  function endOfFile() {\n    return returned.length === 0 && pos >= length\n  }\n\n  function nextToken(opts) {\n    if (returned.length) return returned.pop()\n    if (pos >= length) return\n\n    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false\n\n    code = css.charCodeAt(pos)\n\n    switch (code) {\n      case NEWLINE:\n      case SPACE:\n      case TAB:\n      case CR:\n      case FEED: {\n        next = pos\n        do {\n          next += 1\n          code = css.charCodeAt(next)\n        } while (\n          code === SPACE ||\n          code === NEWLINE ||\n          code === TAB ||\n          code === CR ||\n          code === FEED\n        )\n\n        currentToken = ['space', css.slice(pos, next)]\n        pos = next - 1\n        break\n      }\n\n      case OPEN_SQUARE:\n      case CLOSE_SQUARE:\n      case OPEN_CURLY:\n      case CLOSE_CURLY:\n      case COLON:\n      case SEMICOLON:\n      case CLOSE_PARENTHESES: {\n        let controlChar = String.fromCharCode(code)\n        currentToken = [controlChar, controlChar, pos]\n        break\n      }\n\n      case OPEN_PARENTHESES: {\n        prev = buffer.length ? buffer.pop()[1] : ''\n        n = css.charCodeAt(pos + 1)\n        if (\n          prev === 'url' &&\n          n !== SINGLE_QUOTE &&\n          n !== DOUBLE_QUOTE &&\n          n !== SPACE &&\n          n !== NEWLINE &&\n          n !== TAB &&\n          n !== FEED &&\n          n !== CR\n        ) {\n          next = pos\n          do {\n            escaped = false\n            next = css.indexOf(')', next + 1)\n            if (next === -1) {\n              if (ignore || ignoreUnclosed) {\n                next = pos\n                break\n              } else {\n                unclosed('bracket')\n              }\n            }\n            escapePos = next\n            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n              escapePos -= 1\n              escaped = !escaped\n            }\n          } while (escaped)\n\n          currentToken = ['brackets', css.slice(pos, next + 1), pos, next]\n\n          pos = next\n        } else {\n          next = css.indexOf(')', pos + 1)\n          content = css.slice(pos, next + 1)\n\n          if (next === -1 || RE_BAD_BRACKET.test(content)) {\n            currentToken = ['(', '(', pos]\n          } else {\n            currentToken = ['brackets', content, pos, next]\n            pos = next\n          }\n        }\n\n        break\n      }\n\n      case SINGLE_QUOTE:\n      case DOUBLE_QUOTE: {\n        quote = code === SINGLE_QUOTE ? \"'\" : '\"'\n        next = pos\n        do {\n          escaped = false\n          next = css.indexOf(quote, next + 1)\n          if (next === -1) {\n            if (ignore || ignoreUnclosed) {\n              next = pos + 1\n              break\n            } else {\n              unclosed('string')\n            }\n          }\n          escapePos = next\n          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n            escapePos -= 1\n            escaped = !escaped\n          }\n        } while (escaped)\n\n        currentToken = ['string', css.slice(pos, next + 1), pos, next]\n        pos = next\n        break\n      }\n\n      case AT: {\n        RE_AT_END.lastIndex = pos + 1\n        RE_AT_END.test(css)\n        if (RE_AT_END.lastIndex === 0) {\n          next = css.length - 1\n        } else {\n          next = RE_AT_END.lastIndex - 2\n        }\n\n        currentToken = ['at-word', css.slice(pos, next + 1), pos, next]\n\n        pos = next\n        break\n      }\n\n      case BACKSLASH: {\n        next = pos\n        escape = true\n        while (css.charCodeAt(next + 1) === BACKSLASH) {\n          next += 1\n          escape = !escape\n        }\n        code = css.charCodeAt(next + 1)\n        if (\n          escape &&\n          code !== SLASH &&\n          code !== SPACE &&\n          code !== NEWLINE &&\n          code !== TAB &&\n          code !== CR &&\n          code !== FEED\n        ) {\n          next += 1\n          if (RE_HEX_ESCAPE.test(css.charAt(next))) {\n            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {\n              next += 1\n            }\n            if (css.charCodeAt(next + 1) === SPACE) {\n              next += 1\n            }\n          }\n        }\n\n        currentToken = ['word', css.slice(pos, next + 1), pos, next]\n\n        pos = next\n        break\n      }\n\n      default: {\n        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {\n          next = css.indexOf('*/', pos + 2) + 1\n          if (next === 0) {\n            if (ignore || ignoreUnclosed) {\n              next = css.length\n            } else {\n              unclosed('comment')\n            }\n          }\n\n          currentToken = ['comment', css.slice(pos, next + 1), pos, next]\n          pos = next\n        } else {\n          RE_WORD_END.lastIndex = pos + 1\n          RE_WORD_END.test(css)\n          if (RE_WORD_END.lastIndex === 0) {\n            next = css.length - 1\n          } else {\n            next = RE_WORD_END.lastIndex - 2\n          }\n\n          currentToken = ['word', css.slice(pos, next + 1), pos, next]\n          buffer.push(currentToken)\n          pos = next\n        }\n\n        break\n      }\n    }\n\n    pos++\n    return currentToken\n  }\n\n  function back(token) {\n    returned.push(token)\n  }\n\n  return {\n    back,\n    nextToken,\n    endOfFile,\n    position\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvdG9rZW5pemUuanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLE9BQU87QUFDM0MsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTs7QUFFQSx1REFBdUQ7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvdG9rZW5pemUuanM/NDM3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgU0lOR0xFX1FVT1RFID0gXCInXCIuY2hhckNvZGVBdCgwKVxuY29uc3QgRE9VQkxFX1FVT1RFID0gJ1wiJy5jaGFyQ29kZUF0KDApXG5jb25zdCBCQUNLU0xBU0ggPSAnXFxcXCcuY2hhckNvZGVBdCgwKVxuY29uc3QgU0xBU0ggPSAnLycuY2hhckNvZGVBdCgwKVxuY29uc3QgTkVXTElORSA9ICdcXG4nLmNoYXJDb2RlQXQoMClcbmNvbnN0IFNQQUNFID0gJyAnLmNoYXJDb2RlQXQoMClcbmNvbnN0IEZFRUQgPSAnXFxmJy5jaGFyQ29kZUF0KDApXG5jb25zdCBUQUIgPSAnXFx0Jy5jaGFyQ29kZUF0KDApXG5jb25zdCBDUiA9ICdcXHInLmNoYXJDb2RlQXQoMClcbmNvbnN0IE9QRU5fU1FVQVJFID0gJ1snLmNoYXJDb2RlQXQoMClcbmNvbnN0IENMT1NFX1NRVUFSRSA9ICddJy5jaGFyQ29kZUF0KDApXG5jb25zdCBPUEVOX1BBUkVOVEhFU0VTID0gJygnLmNoYXJDb2RlQXQoMClcbmNvbnN0IENMT1NFX1BBUkVOVEhFU0VTID0gJyknLmNoYXJDb2RlQXQoMClcbmNvbnN0IE9QRU5fQ1VSTFkgPSAneycuY2hhckNvZGVBdCgwKVxuY29uc3QgQ0xPU0VfQ1VSTFkgPSAnfScuY2hhckNvZGVBdCgwKVxuY29uc3QgU0VNSUNPTE9OID0gJzsnLmNoYXJDb2RlQXQoMClcbmNvbnN0IEFTVEVSSVNLID0gJyonLmNoYXJDb2RlQXQoMClcbmNvbnN0IENPTE9OID0gJzonLmNoYXJDb2RlQXQoMClcbmNvbnN0IEFUID0gJ0AnLmNoYXJDb2RlQXQoMClcblxuY29uc3QgUkVfQVRfRU5EID0gL1tcXHRcXG5cXGZcXHIgXCIjJygpLztbXFxcXFxcXXt9XS9nXG5jb25zdCBSRV9XT1JEX0VORCA9IC9bXFx0XFxuXFxmXFxyICFcIiMnKCk6O0BbXFxcXFxcXXt9XXxcXC8oPz1cXCopL2dcbmNvbnN0IFJFX0JBRF9CUkFDS0VUID0gLy5bXFxuXCInKC9cXFxcXS9cbmNvbnN0IFJFX0hFWF9FU0NBUEUgPSAvW1xcZGEtZl0vaVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRva2VuaXplcihpbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gIGxldCBjc3MgPSBpbnB1dC5jc3MudmFsdWVPZigpXG4gIGxldCBpZ25vcmUgPSBvcHRpb25zLmlnbm9yZUVycm9yc1xuXG4gIGxldCBjb2RlLCBuZXh0LCBxdW90ZSwgY29udGVudCwgZXNjYXBlXG4gIGxldCBlc2NhcGVkLCBlc2NhcGVQb3MsIHByZXYsIG4sIGN1cnJlbnRUb2tlblxuXG4gIGxldCBsZW5ndGggPSBjc3MubGVuZ3RoXG4gIGxldCBwb3MgPSAwXG4gIGxldCBidWZmZXIgPSBbXVxuICBsZXQgcmV0dXJuZWQgPSBbXVxuXG4gIGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xuICAgIHJldHVybiBwb3NcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuY2xvc2VkKHdoYXQpIHtcbiAgICB0aHJvdyBpbnB1dC5lcnJvcignVW5jbG9zZWQgJyArIHdoYXQsIHBvcylcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZE9mRmlsZSgpIHtcbiAgICByZXR1cm4gcmV0dXJuZWQubGVuZ3RoID09PSAwICYmIHBvcyA+PSBsZW5ndGhcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHRUb2tlbihvcHRzKSB7XG4gICAgaWYgKHJldHVybmVkLmxlbmd0aCkgcmV0dXJuIHJldHVybmVkLnBvcCgpXG4gICAgaWYgKHBvcyA+PSBsZW5ndGgpIHJldHVyblxuXG4gICAgbGV0IGlnbm9yZVVuY2xvc2VkID0gb3B0cyA/IG9wdHMuaWdub3JlVW5jbG9zZWQgOiBmYWxzZVxuXG4gICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KHBvcylcblxuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgY2FzZSBORVdMSU5FOlxuICAgICAgY2FzZSBTUEFDRTpcbiAgICAgIGNhc2UgVEFCOlxuICAgICAgY2FzZSBDUjpcbiAgICAgIGNhc2UgRkVFRDoge1xuICAgICAgICBuZXh0ID0gcG9zXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBuZXh0ICs9IDFcbiAgICAgICAgICBjb2RlID0gY3NzLmNoYXJDb2RlQXQobmV4dClcbiAgICAgICAgfSB3aGlsZSAoXG4gICAgICAgICAgY29kZSA9PT0gU1BBQ0UgfHxcbiAgICAgICAgICBjb2RlID09PSBORVdMSU5FIHx8XG4gICAgICAgICAgY29kZSA9PT0gVEFCIHx8XG4gICAgICAgICAgY29kZSA9PT0gQ1IgfHxcbiAgICAgICAgICBjb2RlID09PSBGRUVEXG4gICAgICAgIClcblxuICAgICAgICBjdXJyZW50VG9rZW4gPSBbJ3NwYWNlJywgY3NzLnNsaWNlKHBvcywgbmV4dCldXG4gICAgICAgIHBvcyA9IG5leHQgLSAxXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGNhc2UgT1BFTl9TUVVBUkU6XG4gICAgICBjYXNlIENMT1NFX1NRVUFSRTpcbiAgICAgIGNhc2UgT1BFTl9DVVJMWTpcbiAgICAgIGNhc2UgQ0xPU0VfQ1VSTFk6XG4gICAgICBjYXNlIENPTE9OOlxuICAgICAgY2FzZSBTRU1JQ09MT046XG4gICAgICBjYXNlIENMT1NFX1BBUkVOVEhFU0VTOiB7XG4gICAgICAgIGxldCBjb250cm9sQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSlcbiAgICAgICAgY3VycmVudFRva2VuID0gW2NvbnRyb2xDaGFyLCBjb250cm9sQ2hhciwgcG9zXVxuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBjYXNlIE9QRU5fUEFSRU5USEVTRVM6IHtcbiAgICAgICAgcHJldiA9IGJ1ZmZlci5sZW5ndGggPyBidWZmZXIucG9wKClbMV0gOiAnJ1xuICAgICAgICBuID0gY3NzLmNoYXJDb2RlQXQocG9zICsgMSlcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByZXYgPT09ICd1cmwnICYmXG4gICAgICAgICAgbiAhPT0gU0lOR0xFX1FVT1RFICYmXG4gICAgICAgICAgbiAhPT0gRE9VQkxFX1FVT1RFICYmXG4gICAgICAgICAgbiAhPT0gU1BBQ0UgJiZcbiAgICAgICAgICBuICE9PSBORVdMSU5FICYmXG4gICAgICAgICAgbiAhPT0gVEFCICYmXG4gICAgICAgICAgbiAhPT0gRkVFRCAmJlxuICAgICAgICAgIG4gIT09IENSXG4gICAgICAgICkge1xuICAgICAgICAgIG5leHQgPSBwb3NcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBlc2NhcGVkID0gZmFsc2VcbiAgICAgICAgICAgIG5leHQgPSBjc3MuaW5kZXhPZignKScsIG5leHQgKyAxKVxuICAgICAgICAgICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICAgICAgICAgIGlmIChpZ25vcmUgfHwgaWdub3JlVW5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gcG9zXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1bmNsb3NlZCgnYnJhY2tldCcpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVzY2FwZVBvcyA9IG5leHRcbiAgICAgICAgICAgIHdoaWxlIChjc3MuY2hhckNvZGVBdChlc2NhcGVQb3MgLSAxKSA9PT0gQkFDS1NMQVNIKSB7XG4gICAgICAgICAgICAgIGVzY2FwZVBvcyAtPSAxXG4gICAgICAgICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGVzY2FwZWQpXG5cbiAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbJ2JyYWNrZXRzJywgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLCBwb3MsIG5leHRdXG5cbiAgICAgICAgICBwb3MgPSBuZXh0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKCcpJywgcG9zICsgMSlcbiAgICAgICAgICBjb250ZW50ID0gY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpXG5cbiAgICAgICAgICBpZiAobmV4dCA9PT0gLTEgfHwgUkVfQkFEX0JSQUNLRVQudGVzdChjb250ZW50KSkge1xuICAgICAgICAgICAgY3VycmVudFRva2VuID0gWycoJywgJygnLCBwb3NdXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFsnYnJhY2tldHMnLCBjb250ZW50LCBwb3MsIG5leHRdXG4gICAgICAgICAgICBwb3MgPSBuZXh0XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgY2FzZSBTSU5HTEVfUVVPVEU6XG4gICAgICBjYXNlIERPVUJMRV9RVU9URToge1xuICAgICAgICBxdW90ZSA9IGNvZGUgPT09IFNJTkdMRV9RVU9URSA/IFwiJ1wiIDogJ1wiJ1xuICAgICAgICBuZXh0ID0gcG9zXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBlc2NhcGVkID0gZmFsc2VcbiAgICAgICAgICBuZXh0ID0gY3NzLmluZGV4T2YocXVvdGUsIG5leHQgKyAxKVxuICAgICAgICAgIGlmIChuZXh0ID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKGlnbm9yZSB8fCBpZ25vcmVVbmNsb3NlZCkge1xuICAgICAgICAgICAgICBuZXh0ID0gcG9zICsgMVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdW5jbG9zZWQoJ3N0cmluZycpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVzY2FwZVBvcyA9IG5leHRcbiAgICAgICAgICB3aGlsZSAoY3NzLmNoYXJDb2RlQXQoZXNjYXBlUG9zIC0gMSkgPT09IEJBQ0tTTEFTSCkge1xuICAgICAgICAgICAgZXNjYXBlUG9zIC09IDFcbiAgICAgICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZFxuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZXNjYXBlZClcblxuICAgICAgICBjdXJyZW50VG9rZW4gPSBbJ3N0cmluZycsIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSwgcG9zLCBuZXh0XVxuICAgICAgICBwb3MgPSBuZXh0XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGNhc2UgQVQ6IHtcbiAgICAgICAgUkVfQVRfRU5ELmxhc3RJbmRleCA9IHBvcyArIDFcbiAgICAgICAgUkVfQVRfRU5ELnRlc3QoY3NzKVxuICAgICAgICBpZiAoUkVfQVRfRU5ELmxhc3RJbmRleCA9PT0gMCkge1xuICAgICAgICAgIG5leHQgPSBjc3MubGVuZ3RoIC0gMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQgPSBSRV9BVF9FTkQubGFzdEluZGV4IC0gMlxuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFRva2VuID0gWydhdC13b3JkJywgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLCBwb3MsIG5leHRdXG5cbiAgICAgICAgcG9zID0gbmV4dFxuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBjYXNlIEJBQ0tTTEFTSDoge1xuICAgICAgICBuZXh0ID0gcG9zXG4gICAgICAgIGVzY2FwZSA9IHRydWVcbiAgICAgICAgd2hpbGUgKGNzcy5jaGFyQ29kZUF0KG5leHQgKyAxKSA9PT0gQkFDS1NMQVNIKSB7XG4gICAgICAgICAgbmV4dCArPSAxXG4gICAgICAgICAgZXNjYXBlID0gIWVzY2FwZVxuICAgICAgICB9XG4gICAgICAgIGNvZGUgPSBjc3MuY2hhckNvZGVBdChuZXh0ICsgMSlcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGVzY2FwZSAmJlxuICAgICAgICAgIGNvZGUgIT09IFNMQVNIICYmXG4gICAgICAgICAgY29kZSAhPT0gU1BBQ0UgJiZcbiAgICAgICAgICBjb2RlICE9PSBORVdMSU5FICYmXG4gICAgICAgICAgY29kZSAhPT0gVEFCICYmXG4gICAgICAgICAgY29kZSAhPT0gQ1IgJiZcbiAgICAgICAgICBjb2RlICE9PSBGRUVEXG4gICAgICAgICkge1xuICAgICAgICAgIG5leHQgKz0gMVxuICAgICAgICAgIGlmIChSRV9IRVhfRVNDQVBFLnRlc3QoY3NzLmNoYXJBdChuZXh0KSkpIHtcbiAgICAgICAgICAgIHdoaWxlIChSRV9IRVhfRVNDQVBFLnRlc3QoY3NzLmNoYXJBdChuZXh0ICsgMSkpKSB7XG4gICAgICAgICAgICAgIG5leHQgKz0gMVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNzcy5jaGFyQ29kZUF0KG5leHQgKyAxKSA9PT0gU1BBQ0UpIHtcbiAgICAgICAgICAgICAgbmV4dCArPSAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFRva2VuID0gWyd3b3JkJywgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLCBwb3MsIG5leHRdXG5cbiAgICAgICAgcG9zID0gbmV4dFxuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGlmIChjb2RlID09PSBTTEFTSCAmJiBjc3MuY2hhckNvZGVBdChwb3MgKyAxKSA9PT0gQVNURVJJU0spIHtcbiAgICAgICAgICBuZXh0ID0gY3NzLmluZGV4T2YoJyovJywgcG9zICsgMikgKyAxXG4gICAgICAgICAgaWYgKG5leHQgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChpZ25vcmUgfHwgaWdub3JlVW5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgbmV4dCA9IGNzcy5sZW5ndGhcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHVuY2xvc2VkKCdjb21tZW50JylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbJ2NvbW1lbnQnLCBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksIHBvcywgbmV4dF1cbiAgICAgICAgICBwb3MgPSBuZXh0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUkVfV09SRF9FTkQubGFzdEluZGV4ID0gcG9zICsgMVxuICAgICAgICAgIFJFX1dPUkRfRU5ELnRlc3QoY3NzKVxuICAgICAgICAgIGlmIChSRV9XT1JEX0VORC5sYXN0SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIG5leHQgPSBjc3MubGVuZ3RoIC0gMVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0ID0gUkVfV09SRF9FTkQubGFzdEluZGV4IC0gMlxuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFsnd29yZCcsIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSwgcG9zLCBuZXh0XVxuICAgICAgICAgIGJ1ZmZlci5wdXNoKGN1cnJlbnRUb2tlbilcbiAgICAgICAgICBwb3MgPSBuZXh0XG4gICAgICAgIH1cblxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIHBvcysrXG4gICAgcmV0dXJuIGN1cnJlbnRUb2tlblxuICB9XG5cbiAgZnVuY3Rpb24gYmFjayh0b2tlbikge1xuICAgIHJldHVybmVkLnB1c2godG9rZW4pXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJhY2ssXG4gICAgbmV4dFRva2VuLFxuICAgIGVuZE9mRmlsZSxcbiAgICBwb3NpdGlvblxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/tokenize.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/warn-once.js":
/*!***********************************************!*\
  !*** ./node_modules/postcss/lib/warn-once.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("/* eslint-disable no-console */\n\n\nlet printed = {}\n\nmodule.exports = function warnOnce(message) {\n  if (printed[message]) return\n  printed[message] = true\n\n  if (typeof console !== 'undefined' && console.warn) {\n    console.warn(message)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvd2Fybi1vbmNlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ1k7O0FBRVo7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL3dhcm4tb25jZS5qcz8zOTcxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbid1c2Ugc3RyaWN0J1xuXG5sZXQgcHJpbnRlZCA9IHt9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2Fybk9uY2UobWVzc2FnZSkge1xuICBpZiAocHJpbnRlZFttZXNzYWdlXSkgcmV0dXJuXG4gIHByaW50ZWRbbWVzc2FnZV0gPSB0cnVlXG5cbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLndhcm4pIHtcbiAgICBjb25zb2xlLndhcm4obWVzc2FnZSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/warn-once.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/warning.js":
/*!*********************************************!*\
  !*** ./node_modules/postcss/lib/warning.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nclass Warning {\n  constructor(text, opts = {}) {\n    this.type = 'warning'\n    this.text = text\n\n    if (opts.node && opts.node.source) {\n      let range = opts.node.rangeBy(opts)\n      this.line = range.start.line\n      this.column = range.start.column\n      this.endLine = range.end.line\n      this.endColumn = range.end.column\n    }\n\n    for (let opt in opts) this[opt] = opts[opt]\n  }\n\n  toString() {\n    if (this.node) {\n      return this.node.error(this.text, {\n        plugin: this.plugin,\n        index: this.index,\n        word: this.word\n      }).message\n    }\n\n    if (this.plugin) {\n      return this.plugin + ': ' + this.text\n    }\n\n    return this.text\n  }\n}\n\nmodule.exports = Warning\nWarning.default = Warning\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvd2FybmluZy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzL2xpYi93YXJuaW5nLmpzP2E0YjMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNsYXNzIFdhcm5pbmcge1xuICBjb25zdHJ1Y3Rvcih0ZXh0LCBvcHRzID0ge30pIHtcbiAgICB0aGlzLnR5cGUgPSAnd2FybmluZydcbiAgICB0aGlzLnRleHQgPSB0ZXh0XG5cbiAgICBpZiAob3B0cy5ub2RlICYmIG9wdHMubm9kZS5zb3VyY2UpIHtcbiAgICAgIGxldCByYW5nZSA9IG9wdHMubm9kZS5yYW5nZUJ5KG9wdHMpXG4gICAgICB0aGlzLmxpbmUgPSByYW5nZS5zdGFydC5saW5lXG4gICAgICB0aGlzLmNvbHVtbiA9IHJhbmdlLnN0YXJ0LmNvbHVtblxuICAgICAgdGhpcy5lbmRMaW5lID0gcmFuZ2UuZW5kLmxpbmVcbiAgICAgIHRoaXMuZW5kQ29sdW1uID0gcmFuZ2UuZW5kLmNvbHVtblxuICAgIH1cblxuICAgIGZvciAobGV0IG9wdCBpbiBvcHRzKSB0aGlzW29wdF0gPSBvcHRzW29wdF1cbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGlmICh0aGlzLm5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGUuZXJyb3IodGhpcy50ZXh0LCB7XG4gICAgICAgIHBsdWdpbjogdGhpcy5wbHVnaW4sXG4gICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgICB3b3JkOiB0aGlzLndvcmRcbiAgICAgIH0pLm1lc3NhZ2VcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wbHVnaW4pIHtcbiAgICAgIHJldHVybiB0aGlzLnBsdWdpbiArICc6ICcgKyB0aGlzLnRleHRcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50ZXh0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBXYXJuaW5nXG5XYXJuaW5nLmRlZmF1bHQgPSBXYXJuaW5nXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/warning.js\n");

/***/ }),

/***/ "?fe98":
/*!**************************************!*\
  !*** ./terminal-highlight (ignored) ***!
  \**************************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?2f81":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?25fb":
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?6f78":
/*!*******************************!*\
  !*** source-map-js (ignored) ***!
  \*******************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?9214":
/*!*********************!*\
  !*** url (ignored) ***!
  \*********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "./node_modules/nanoid/non-secure/index.cjs":
/*!**************************************************!*\
  !*** ./node_modules/nanoid/non-secure/index.cjs ***!
  \**************************************************/
/***/ ((module) => {

eval("let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\nmodule.exports = { nanoid, customAlphabet }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmFub2lkL25vbi1zZWN1cmUvaW5kZXguY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmFub2lkL25vbi1zZWN1cmUvaW5kZXguY2pzPzhhZGIiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IHVybEFscGhhYmV0ID1cbiAgJ3VzZWFuZG9tLTI2VDE5ODM0MFBYNzVweEpBQ0tWRVJZTUlOREJVU0hXT0xGX0dRWmJmZ2hqa2xxdnd5enJpY3QnXG5sZXQgY3VzdG9tQWxwaGFiZXQgPSAoYWxwaGFiZXQsIGRlZmF1bHRTaXplID0gMjEpID0+IHtcbiAgcmV0dXJuIChzaXplID0gZGVmYXVsdFNpemUpID0+IHtcbiAgICBsZXQgaWQgPSAnJ1xuICAgIGxldCBpID0gc2l6ZVxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlkICs9IGFscGhhYmV0WyhNYXRoLnJhbmRvbSgpICogYWxwaGFiZXQubGVuZ3RoKSB8IDBdXG4gICAgfVxuICAgIHJldHVybiBpZFxuICB9XG59XG5sZXQgbmFub2lkID0gKHNpemUgPSAyMSkgPT4ge1xuICBsZXQgaWQgPSAnJ1xuICBsZXQgaSA9IHNpemVcbiAgd2hpbGUgKGktLSkge1xuICAgIGlkICs9IHVybEFscGhhYmV0WyhNYXRoLnJhbmRvbSgpICogNjQpIHwgMF1cbiAgfVxuICByZXR1cm4gaWRcbn1cbm1vZHVsZS5leHBvcnRzID0geyBuYW5vaWQsIGN1c3RvbUFscGhhYmV0IH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/nanoid/non-secure/index.cjs\n");

/***/ }),

/***/ "./node_modules/postcss/lib/postcss.mjs":
/*!**********************************************!*\
  !*** ./node_modules/postcss/lib/postcss.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AtRule\": () => (/* binding */ AtRule),\n/* harmony export */   \"Comment\": () => (/* binding */ Comment),\n/* harmony export */   \"Container\": () => (/* binding */ Container),\n/* harmony export */   \"CssSyntaxError\": () => (/* binding */ CssSyntaxError),\n/* harmony export */   \"Declaration\": () => (/* binding */ Declaration),\n/* harmony export */   \"Document\": () => (/* binding */ Document),\n/* harmony export */   \"Input\": () => (/* binding */ Input),\n/* harmony export */   \"Node\": () => (/* binding */ Node),\n/* harmony export */   \"Processor\": () => (/* binding */ Processor),\n/* harmony export */   \"Result\": () => (/* binding */ Result),\n/* harmony export */   \"Root\": () => (/* binding */ Root),\n/* harmony export */   \"Rule\": () => (/* binding */ Rule),\n/* harmony export */   \"Warning\": () => (/* binding */ Warning),\n/* harmony export */   \"atRule\": () => (/* binding */ atRule),\n/* harmony export */   \"comment\": () => (/* binding */ comment),\n/* harmony export */   \"decl\": () => (/* binding */ decl),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"document\": () => (/* binding */ document),\n/* harmony export */   \"fromJSON\": () => (/* binding */ fromJSON),\n/* harmony export */   \"list\": () => (/* binding */ list),\n/* harmony export */   \"parse\": () => (/* binding */ parse),\n/* harmony export */   \"plugin\": () => (/* binding */ plugin),\n/* harmony export */   \"root\": () => (/* binding */ root),\n/* harmony export */   \"rule\": () => (/* binding */ rule),\n/* harmony export */   \"stringify\": () => (/* binding */ stringify)\n/* harmony export */ });\n/* harmony import */ var _postcss_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./postcss.js */ \"./node_modules/postcss/lib/postcss.js\");\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_postcss_js__WEBPACK_IMPORTED_MODULE_0__);\n\nconst stringify = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.stringify\nconst fromJSON = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.fromJSON\nconst plugin = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.plugin\nconst parse = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.parse\nconst list = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.list\n\nconst document = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.document\nconst comment = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.comment\nconst atRule = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.atRule\nconst rule = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.rule\nconst decl = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.decl\nconst root = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.root\n\nconst CssSyntaxError = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.CssSyntaxError\nconst Declaration = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Declaration\nconst Container = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Container\nconst Processor = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Processor\nconst Document = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Document\nconst Comment = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Comment\nconst Warning = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Warning\nconst AtRule = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.AtRule\nconst Result = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Result\nconst Input = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Input\nconst Rule = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Rule\nconst Root = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Root\nconst Node = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Node\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcG9zdGNzcy5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0M7O0FBRWxDLGlFQUFlLHdDQUFPOztBQUVmLGtCQUFrQixrREFBaUI7QUFDbkMsaUJBQWlCLGlEQUFnQjtBQUNqQyxlQUFlLCtDQUFjO0FBQzdCLGNBQWMsOENBQWE7QUFDM0IsYUFBYSw2Q0FBWTs7QUFFekIsaUJBQWlCLGlEQUFnQjtBQUNqQyxnQkFBZ0IsZ0RBQWU7QUFDL0IsZUFBZSwrQ0FBYztBQUM3QixhQUFhLDZDQUFZO0FBQ3pCLGFBQWEsNkNBQVk7QUFDekIsYUFBYSw2Q0FBWTs7QUFFekIsdUJBQXVCLHVEQUFzQjtBQUM3QyxvQkFBb0Isb0RBQW1CO0FBQ3ZDLGtCQUFrQixrREFBaUI7QUFDbkMsa0JBQWtCLGtEQUFpQjtBQUNuQyxpQkFBaUIsaURBQWdCO0FBQ2pDLGdCQUFnQixnREFBZTtBQUMvQixnQkFBZ0IsZ0RBQWU7QUFDL0IsZUFBZSwrQ0FBYztBQUM3QixlQUFlLCtDQUFjO0FBQzdCLGNBQWMsOENBQWE7QUFDM0IsYUFBYSw2Q0FBWTtBQUN6QixhQUFhLDZDQUFZO0FBQ3pCLGFBQWEsNkNBQVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcG9zdGNzcy5tanM/YmYzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcG9zdGNzcyBmcm9tICcuL3Bvc3Rjc3MuanMnXG5cbmV4cG9ydCBkZWZhdWx0IHBvc3Rjc3NcblxuZXhwb3J0IGNvbnN0IHN0cmluZ2lmeSA9IHBvc3Rjc3Muc3RyaW5naWZ5XG5leHBvcnQgY29uc3QgZnJvbUpTT04gPSBwb3N0Y3NzLmZyb21KU09OXG5leHBvcnQgY29uc3QgcGx1Z2luID0gcG9zdGNzcy5wbHVnaW5cbmV4cG9ydCBjb25zdCBwYXJzZSA9IHBvc3Rjc3MucGFyc2VcbmV4cG9ydCBjb25zdCBsaXN0ID0gcG9zdGNzcy5saXN0XG5cbmV4cG9ydCBjb25zdCBkb2N1bWVudCA9IHBvc3Rjc3MuZG9jdW1lbnRcbmV4cG9ydCBjb25zdCBjb21tZW50ID0gcG9zdGNzcy5jb21tZW50XG5leHBvcnQgY29uc3QgYXRSdWxlID0gcG9zdGNzcy5hdFJ1bGVcbmV4cG9ydCBjb25zdCBydWxlID0gcG9zdGNzcy5ydWxlXG5leHBvcnQgY29uc3QgZGVjbCA9IHBvc3Rjc3MuZGVjbFxuZXhwb3J0IGNvbnN0IHJvb3QgPSBwb3N0Y3NzLnJvb3RcblxuZXhwb3J0IGNvbnN0IENzc1N5bnRheEVycm9yID0gcG9zdGNzcy5Dc3NTeW50YXhFcnJvclxuZXhwb3J0IGNvbnN0IERlY2xhcmF0aW9uID0gcG9zdGNzcy5EZWNsYXJhdGlvblxuZXhwb3J0IGNvbnN0IENvbnRhaW5lciA9IHBvc3Rjc3MuQ29udGFpbmVyXG5leHBvcnQgY29uc3QgUHJvY2Vzc29yID0gcG9zdGNzcy5Qcm9jZXNzb3JcbmV4cG9ydCBjb25zdCBEb2N1bWVudCA9IHBvc3Rjc3MuRG9jdW1lbnRcbmV4cG9ydCBjb25zdCBDb21tZW50ID0gcG9zdGNzcy5Db21tZW50XG5leHBvcnQgY29uc3QgV2FybmluZyA9IHBvc3Rjc3MuV2FybmluZ1xuZXhwb3J0IGNvbnN0IEF0UnVsZSA9IHBvc3Rjc3MuQXRSdWxlXG5leHBvcnQgY29uc3QgUmVzdWx0ID0gcG9zdGNzcy5SZXN1bHRcbmV4cG9ydCBjb25zdCBJbnB1dCA9IHBvc3Rjc3MuSW5wdXRcbmV4cG9ydCBjb25zdCBSdWxlID0gcG9zdGNzcy5SdWxlXG5leHBvcnQgY29uc3QgUm9vdCA9IHBvc3Rjc3MuUm9vdFxuZXhwb3J0IGNvbnN0IE5vZGUgPSBwb3N0Y3NzLk5vZGVcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/postcss.mjs\n");

/***/ }),

/***/ "./node_modules/vite/dist/node/chunks/dep-07a79996.js":
/*!************************************************************!*\
  !*** ./node_modules/vite/dist/node/chunks/dep-07a79996.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"l\": () => (/* binding */ lib)\n/* harmony export */ });\n/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:url */ \"node:url\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var node_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:module */ \"node:module\");\n\n\n\n\nconst __filename = (0,node_url__WEBPACK_IMPORTED_MODULE_0__.fileURLToPath)(\"file:///var/www/projects/woopons/woopons/node_modules/vite/dist/node/chunks/dep-07a79996.js\");\nconst __dirname = (0,node_path__WEBPACK_IMPORTED_MODULE_1__.dirname)(__filename);\nconst require = (0,node_module__WEBPACK_IMPORTED_MODULE_2__.createRequire)(\"file:///var/www/projects/woopons/woopons/node_modules/vite/dist/node/chunks/dep-07a79996.js\");\nconst __require = require;\nvar openParentheses = \"(\".charCodeAt(0);\nvar closeParentheses = \")\".charCodeAt(0);\nvar singleQuote = \"'\".charCodeAt(0);\nvar doubleQuote = '\"'.charCodeAt(0);\nvar backslash = \"\\\\\".charCodeAt(0);\nvar slash = \"/\".charCodeAt(0);\nvar comma = \",\".charCodeAt(0);\nvar colon = \":\".charCodeAt(0);\nvar star = \"*\".charCodeAt(0);\nvar uLower = \"u\".charCodeAt(0);\nvar uUpper = \"U\".charCodeAt(0);\nvar plus = \"+\".charCodeAt(0);\nvar isUnicodeRange = /^[a-f0-9?-]+$/i;\n\nvar parse$1 = function(input) {\n  var tokens = [];\n  var value = input;\n\n  var next,\n    quote,\n    prev,\n    token,\n    escape,\n    escapePos,\n    whitespacePos,\n    parenthesesOpenPos;\n  var pos = 0;\n  var code = value.charCodeAt(pos);\n  var max = value.length;\n  var stack = [{ nodes: tokens }];\n  var balanced = 0;\n  var parent;\n\n  var name = \"\";\n  var before = \"\";\n  var after = \"\";\n\n  while (pos < max) {\n    // Whitespaces\n    if (code <= 32) {\n      next = pos;\n      do {\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (code <= 32);\n      token = value.slice(pos, next);\n\n      prev = tokens[tokens.length - 1];\n      if (code === closeParentheses && balanced) {\n        after = token;\n      } else if (prev && prev.type === \"div\") {\n        prev.after = token;\n        prev.sourceEndIndex += token.length;\n      } else if (\n        code === comma ||\n        code === colon ||\n        (code === slash &&\n          value.charCodeAt(next + 1) !== star &&\n          (!parent ||\n            (parent && parent.type === \"function\" && parent.value !== \"calc\")))\n      ) {\n        before = token;\n      } else {\n        tokens.push({\n          type: \"space\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      }\n\n      pos = next;\n\n      // Quotes\n    } else if (code === singleQuote || code === doubleQuote) {\n      next = pos;\n      quote = code === singleQuote ? \"'\" : '\"';\n      token = {\n        type: \"string\",\n        sourceIndex: pos,\n        quote: quote\n      };\n      do {\n        escape = false;\n        next = value.indexOf(quote, next + 1);\n        if (~next) {\n          escapePos = next;\n          while (value.charCodeAt(escapePos - 1) === backslash) {\n            escapePos -= 1;\n            escape = !escape;\n          }\n        } else {\n          value += quote;\n          next = value.length - 1;\n          token.unclosed = true;\n        }\n      } while (escape);\n      token.value = value.slice(pos + 1, next);\n      token.sourceEndIndex = token.unclosed ? next : next + 1;\n      tokens.push(token);\n      pos = next + 1;\n      code = value.charCodeAt(pos);\n\n      // Comments\n    } else if (code === slash && value.charCodeAt(pos + 1) === star) {\n      next = value.indexOf(\"*/\", pos);\n\n      token = {\n        type: \"comment\",\n        sourceIndex: pos,\n        sourceEndIndex: next + 2\n      };\n\n      if (next === -1) {\n        token.unclosed = true;\n        next = value.length;\n        token.sourceEndIndex = next;\n      }\n\n      token.value = value.slice(pos + 2, next);\n      tokens.push(token);\n\n      pos = next + 2;\n      code = value.charCodeAt(pos);\n\n      // Operation within calc\n    } else if (\n      (code === slash || code === star) &&\n      parent &&\n      parent.type === \"function\" &&\n      parent.value === \"calc\"\n    ) {\n      token = value[pos];\n      tokens.push({\n        type: \"word\",\n        sourceIndex: pos - before.length,\n        sourceEndIndex: pos + token.length,\n        value: token\n      });\n      pos += 1;\n      code = value.charCodeAt(pos);\n\n      // Dividers\n    } else if (code === slash || code === comma || code === colon) {\n      token = value[pos];\n\n      tokens.push({\n        type: \"div\",\n        sourceIndex: pos - before.length,\n        sourceEndIndex: pos + token.length,\n        value: token,\n        before: before,\n        after: \"\"\n      });\n      before = \"\";\n\n      pos += 1;\n      code = value.charCodeAt(pos);\n\n      // Open parentheses\n    } else if (openParentheses === code) {\n      // Whitespaces after open parentheses\n      next = pos;\n      do {\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (code <= 32);\n      parenthesesOpenPos = pos;\n      token = {\n        type: \"function\",\n        sourceIndex: pos - name.length,\n        value: name,\n        before: value.slice(parenthesesOpenPos + 1, next)\n      };\n      pos = next;\n\n      if (name === \"url\" && code !== singleQuote && code !== doubleQuote) {\n        next -= 1;\n        do {\n          escape = false;\n          next = value.indexOf(\")\", next + 1);\n          if (~next) {\n            escapePos = next;\n            while (value.charCodeAt(escapePos - 1) === backslash) {\n              escapePos -= 1;\n              escape = !escape;\n            }\n          } else {\n            value += \")\";\n            next = value.length - 1;\n            token.unclosed = true;\n          }\n        } while (escape);\n        // Whitespaces before closed\n        whitespacePos = next;\n        do {\n          whitespacePos -= 1;\n          code = value.charCodeAt(whitespacePos);\n        } while (code <= 32);\n        if (parenthesesOpenPos < whitespacePos) {\n          if (pos !== whitespacePos + 1) {\n            token.nodes = [\n              {\n                type: \"word\",\n                sourceIndex: pos,\n                sourceEndIndex: whitespacePos + 1,\n                value: value.slice(pos, whitespacePos + 1)\n              }\n            ];\n          } else {\n            token.nodes = [];\n          }\n          if (token.unclosed && whitespacePos + 1 !== next) {\n            token.after = \"\";\n            token.nodes.push({\n              type: \"space\",\n              sourceIndex: whitespacePos + 1,\n              sourceEndIndex: next,\n              value: value.slice(whitespacePos + 1, next)\n            });\n          } else {\n            token.after = value.slice(whitespacePos + 1, next);\n            token.sourceEndIndex = next;\n          }\n        } else {\n          token.after = \"\";\n          token.nodes = [];\n        }\n        pos = next + 1;\n        token.sourceEndIndex = token.unclosed ? next : pos;\n        code = value.charCodeAt(pos);\n        tokens.push(token);\n      } else {\n        balanced += 1;\n        token.after = \"\";\n        token.sourceEndIndex = pos + 1;\n        tokens.push(token);\n        stack.push(token);\n        tokens = token.nodes = [];\n        parent = token;\n      }\n      name = \"\";\n\n      // Close parentheses\n    } else if (closeParentheses === code && balanced) {\n      pos += 1;\n      code = value.charCodeAt(pos);\n\n      parent.after = after;\n      parent.sourceEndIndex += after.length;\n      after = \"\";\n      balanced -= 1;\n      stack[stack.length - 1].sourceEndIndex = pos;\n      stack.pop();\n      parent = stack[balanced];\n      tokens = parent.nodes;\n\n      // Words\n    } else {\n      next = pos;\n      do {\n        if (code === backslash) {\n          next += 1;\n        }\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (\n        next < max &&\n        !(\n          code <= 32 ||\n          code === singleQuote ||\n          code === doubleQuote ||\n          code === comma ||\n          code === colon ||\n          code === slash ||\n          code === openParentheses ||\n          (code === star &&\n            parent &&\n            parent.type === \"function\" &&\n            parent.value === \"calc\") ||\n          (code === slash &&\n            parent.type === \"function\" &&\n            parent.value === \"calc\") ||\n          (code === closeParentheses && balanced)\n        )\n      );\n      token = value.slice(pos, next);\n\n      if (openParentheses === code) {\n        name = token;\n      } else if (\n        (uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) &&\n        plus === token.charCodeAt(1) &&\n        isUnicodeRange.test(token.slice(2))\n      ) {\n        tokens.push({\n          type: \"unicode-range\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      } else {\n        tokens.push({\n          type: \"word\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      }\n\n      pos = next;\n    }\n  }\n\n  for (pos = stack.length - 1; pos; pos -= 1) {\n    stack[pos].unclosed = true;\n    stack[pos].sourceEndIndex = value.length;\n  }\n\n  return stack[0].nodes;\n};\n\nvar walk$1 = function walk(nodes, cb, bubble) {\n  var i, max, node, result;\n\n  for (i = 0, max = nodes.length; i < max; i += 1) {\n    node = nodes[i];\n    if (!bubble) {\n      result = cb(node, i, nodes);\n    }\n\n    if (\n      result !== false &&\n      node.type === \"function\" &&\n      Array.isArray(node.nodes)\n    ) {\n      walk(node.nodes, cb, bubble);\n    }\n\n    if (bubble) {\n      cb(node, i, nodes);\n    }\n  }\n};\n\nfunction stringifyNode(node, custom) {\n  var type = node.type;\n  var value = node.value;\n  var buf;\n  var customResult;\n\n  if (custom && (customResult = custom(node)) !== undefined) {\n    return customResult;\n  } else if (type === \"word\" || type === \"space\") {\n    return value;\n  } else if (type === \"string\") {\n    buf = node.quote || \"\";\n    return buf + value + (node.unclosed ? \"\" : buf);\n  } else if (type === \"comment\") {\n    return \"/*\" + value + (node.unclosed ? \"\" : \"*/\");\n  } else if (type === \"div\") {\n    return (node.before || \"\") + value + (node.after || \"\");\n  } else if (Array.isArray(node.nodes)) {\n    buf = stringify$1(node.nodes, custom);\n    if (type !== \"function\") {\n      return buf;\n    }\n    return (\n      value +\n      \"(\" +\n      (node.before || \"\") +\n      buf +\n      (node.after || \"\") +\n      (node.unclosed ? \"\" : \")\")\n    );\n  }\n  return value;\n}\n\nfunction stringify$1(nodes, custom) {\n  var result, i;\n\n  if (Array.isArray(nodes)) {\n    result = \"\";\n    for (i = nodes.length - 1; ~i; i -= 1) {\n      result = stringifyNode(nodes[i], custom) + result;\n    }\n    return result;\n  }\n  return stringifyNode(nodes, custom);\n}\n\nvar stringify_1 = stringify$1;\n\nvar unit;\nvar hasRequiredUnit;\n\nfunction requireUnit () {\n\tif (hasRequiredUnit) return unit;\n\thasRequiredUnit = 1;\n\tvar minus = \"-\".charCodeAt(0);\n\tvar plus = \"+\".charCodeAt(0);\n\tvar dot = \".\".charCodeAt(0);\n\tvar exp = \"e\".charCodeAt(0);\n\tvar EXP = \"E\".charCodeAt(0);\n\n\t// Check if three code points would start a number\n\t// https://www.w3.org/TR/css-syntax-3/#starts-with-a-number\n\tfunction likeNumber(value) {\n\t  var code = value.charCodeAt(0);\n\t  var nextCode;\n\n\t  if (code === plus || code === minus) {\n\t    nextCode = value.charCodeAt(1);\n\n\t    if (nextCode >= 48 && nextCode <= 57) {\n\t      return true;\n\t    }\n\n\t    var nextNextCode = value.charCodeAt(2);\n\n\t    if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {\n\t      return true;\n\t    }\n\n\t    return false;\n\t  }\n\n\t  if (code === dot) {\n\t    nextCode = value.charCodeAt(1);\n\n\t    if (nextCode >= 48 && nextCode <= 57) {\n\t      return true;\n\t    }\n\n\t    return false;\n\t  }\n\n\t  if (code >= 48 && code <= 57) {\n\t    return true;\n\t  }\n\n\t  return false;\n\t}\n\n\t// Consume a number\n\t// https://www.w3.org/TR/css-syntax-3/#consume-number\n\tunit = function(value) {\n\t  var pos = 0;\n\t  var length = value.length;\n\t  var code;\n\t  var nextCode;\n\t  var nextNextCode;\n\n\t  if (length === 0 || !likeNumber(value)) {\n\t    return false;\n\t  }\n\n\t  code = value.charCodeAt(pos);\n\n\t  if (code === plus || code === minus) {\n\t    pos++;\n\t  }\n\n\t  while (pos < length) {\n\t    code = value.charCodeAt(pos);\n\n\t    if (code < 48 || code > 57) {\n\t      break;\n\t    }\n\n\t    pos += 1;\n\t  }\n\n\t  code = value.charCodeAt(pos);\n\t  nextCode = value.charCodeAt(pos + 1);\n\n\t  if (code === dot && nextCode >= 48 && nextCode <= 57) {\n\t    pos += 2;\n\n\t    while (pos < length) {\n\t      code = value.charCodeAt(pos);\n\n\t      if (code < 48 || code > 57) {\n\t        break;\n\t      }\n\n\t      pos += 1;\n\t    }\n\t  }\n\n\t  code = value.charCodeAt(pos);\n\t  nextCode = value.charCodeAt(pos + 1);\n\t  nextNextCode = value.charCodeAt(pos + 2);\n\n\t  if (\n\t    (code === exp || code === EXP) &&\n\t    ((nextCode >= 48 && nextCode <= 57) ||\n\t      ((nextCode === plus || nextCode === minus) &&\n\t        nextNextCode >= 48 &&\n\t        nextNextCode <= 57))\n\t  ) {\n\t    pos += nextCode === plus || nextCode === minus ? 3 : 2;\n\n\t    while (pos < length) {\n\t      code = value.charCodeAt(pos);\n\n\t      if (code < 48 || code > 57) {\n\t        break;\n\t      }\n\n\t      pos += 1;\n\t    }\n\t  }\n\n\t  return {\n\t    number: value.slice(0, pos),\n\t    unit: value.slice(pos)\n\t  };\n\t};\n\treturn unit;\n}\n\nvar parse = parse$1;\nvar walk = walk$1;\nvar stringify = stringify_1;\n\nfunction ValueParser(value) {\n  if (this instanceof ValueParser) {\n    this.nodes = parse(value);\n    return this;\n  }\n  return new ValueParser(value);\n}\n\nValueParser.prototype.toString = function() {\n  return Array.isArray(this.nodes) ? stringify(this.nodes) : \"\";\n};\n\nValueParser.prototype.walk = function(cb, bubble) {\n  walk(this.nodes, cb, bubble);\n  return this;\n};\n\nValueParser.unit = requireUnit();\n\nValueParser.walk = walk;\n\nValueParser.stringify = stringify;\n\nvar lib = ValueParser;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdml0ZS9kaXN0L25vZGUvY2h1bmtzL2RlcC0wN2E3OTk5Ni5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdFO0FBQ1g7QUFDYzs7QUFFbkUsbUJBQW1CLHVEQUFtQixDQUFDLDZGQUFlO0FBQ3RELGtCQUFrQixrREFBYTtBQUMvQixnQkFBZ0IsMERBQW1CLENBQUMsNkZBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLElBQUk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdml0ZS9kaXN0L25vZGUvY2h1bmtzL2RlcC0wN2E3OTk5Ni5qcz85Nzc1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZpbGVVUkxUb1BhdGggYXMgX19janNfZmlsZVVSTFRvUGF0aCB9IGZyb20gJ25vZGU6dXJsJztcbmltcG9ydCB7IGRpcm5hbWUgYXMgX19janNfZGlybmFtZSB9IGZyb20gJ25vZGU6cGF0aCc7XG5pbXBvcnQgeyBjcmVhdGVSZXF1aXJlIGFzIF9fY2pzX2NyZWF0ZVJlcXVpcmUgfSBmcm9tICdub2RlOm1vZHVsZSc7XG5cbmNvbnN0IF9fZmlsZW5hbWUgPSBfX2Nqc19maWxlVVJMVG9QYXRoKGltcG9ydC5tZXRhLnVybCk7XG5jb25zdCBfX2Rpcm5hbWUgPSBfX2Nqc19kaXJuYW1lKF9fZmlsZW5hbWUpO1xuY29uc3QgcmVxdWlyZSA9IF9fY2pzX2NyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKTtcbmNvbnN0IF9fcmVxdWlyZSA9IHJlcXVpcmU7XG52YXIgb3BlblBhcmVudGhlc2VzID0gXCIoXCIuY2hhckNvZGVBdCgwKTtcbnZhciBjbG9zZVBhcmVudGhlc2VzID0gXCIpXCIuY2hhckNvZGVBdCgwKTtcbnZhciBzaW5nbGVRdW90ZSA9IFwiJ1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgZG91YmxlUXVvdGUgPSAnXCInLmNoYXJDb2RlQXQoMCk7XG52YXIgYmFja3NsYXNoID0gXCJcXFxcXCIuY2hhckNvZGVBdCgwKTtcbnZhciBzbGFzaCA9IFwiL1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgY29tbWEgPSBcIixcIi5jaGFyQ29kZUF0KDApO1xudmFyIGNvbG9uID0gXCI6XCIuY2hhckNvZGVBdCgwKTtcbnZhciBzdGFyID0gXCIqXCIuY2hhckNvZGVBdCgwKTtcbnZhciB1TG93ZXIgPSBcInVcIi5jaGFyQ29kZUF0KDApO1xudmFyIHVVcHBlciA9IFwiVVwiLmNoYXJDb2RlQXQoMCk7XG52YXIgcGx1cyA9IFwiK1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgaXNVbmljb2RlUmFuZ2UgPSAvXlthLWYwLTk/LV0rJC9pO1xuXG52YXIgcGFyc2UkMSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIHZhbHVlID0gaW5wdXQ7XG5cbiAgdmFyIG5leHQsXG4gICAgcXVvdGUsXG4gICAgcHJldixcbiAgICB0b2tlbixcbiAgICBlc2NhcGUsXG4gICAgZXNjYXBlUG9zLFxuICAgIHdoaXRlc3BhY2VQb3MsXG4gICAgcGFyZW50aGVzZXNPcGVuUG9zO1xuICB2YXIgcG9zID0gMDtcbiAgdmFyIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyk7XG4gIHZhciBtYXggPSB2YWx1ZS5sZW5ndGg7XG4gIHZhciBzdGFjayA9IFt7IG5vZGVzOiB0b2tlbnMgfV07XG4gIHZhciBiYWxhbmNlZCA9IDA7XG4gIHZhciBwYXJlbnQ7XG5cbiAgdmFyIG5hbWUgPSBcIlwiO1xuICB2YXIgYmVmb3JlID0gXCJcIjtcbiAgdmFyIGFmdGVyID0gXCJcIjtcblxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgLy8gV2hpdGVzcGFjZXNcbiAgICBpZiAoY29kZSA8PSAzMikge1xuICAgICAgbmV4dCA9IHBvcztcbiAgICAgIGRvIHtcbiAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChuZXh0KTtcbiAgICAgIH0gd2hpbGUgKGNvZGUgPD0gMzIpO1xuICAgICAgdG9rZW4gPSB2YWx1ZS5zbGljZShwb3MsIG5leHQpO1xuXG4gICAgICBwcmV2ID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChjb2RlID09PSBjbG9zZVBhcmVudGhlc2VzICYmIGJhbGFuY2VkKSB7XG4gICAgICAgIGFmdGVyID0gdG9rZW47XG4gICAgICB9IGVsc2UgaWYgKHByZXYgJiYgcHJldi50eXBlID09PSBcImRpdlwiKSB7XG4gICAgICAgIHByZXYuYWZ0ZXIgPSB0b2tlbjtcbiAgICAgICAgcHJldi5zb3VyY2VFbmRJbmRleCArPSB0b2tlbi5sZW5ndGg7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBjb2RlID09PSBjb21tYSB8fFxuICAgICAgICBjb2RlID09PSBjb2xvbiB8fFxuICAgICAgICAoY29kZSA9PT0gc2xhc2ggJiZcbiAgICAgICAgICB2YWx1ZS5jaGFyQ29kZUF0KG5leHQgKyAxKSAhPT0gc3RhciAmJlxuICAgICAgICAgICghcGFyZW50IHx8XG4gICAgICAgICAgICAocGFyZW50ICYmIHBhcmVudC50eXBlID09PSBcImZ1bmN0aW9uXCIgJiYgcGFyZW50LnZhbHVlICE9PSBcImNhbGNcIikpKVxuICAgICAgKSB7XG4gICAgICAgIGJlZm9yZSA9IHRva2VuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwic3BhY2VcIixcbiAgICAgICAgICBzb3VyY2VJbmRleDogcG9zLFxuICAgICAgICAgIHNvdXJjZUVuZEluZGV4OiBuZXh0LFxuICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcG9zID0gbmV4dDtcblxuICAgICAgLy8gUXVvdGVzXG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBzaW5nbGVRdW90ZSB8fCBjb2RlID09PSBkb3VibGVRdW90ZSkge1xuICAgICAgbmV4dCA9IHBvcztcbiAgICAgIHF1b3RlID0gY29kZSA9PT0gc2luZ2xlUXVvdGUgPyBcIidcIiA6ICdcIic7XG4gICAgICB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgc291cmNlSW5kZXg6IHBvcyxcbiAgICAgICAgcXVvdGU6IHF1b3RlXG4gICAgICB9O1xuICAgICAgZG8ge1xuICAgICAgICBlc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgbmV4dCA9IHZhbHVlLmluZGV4T2YocXVvdGUsIG5leHQgKyAxKTtcbiAgICAgICAgaWYgKH5uZXh0KSB7XG4gICAgICAgICAgZXNjYXBlUG9zID0gbmV4dDtcbiAgICAgICAgICB3aGlsZSAodmFsdWUuY2hhckNvZGVBdChlc2NhcGVQb3MgLSAxKSA9PT0gYmFja3NsYXNoKSB7XG4gICAgICAgICAgICBlc2NhcGVQb3MgLT0gMTtcbiAgICAgICAgICAgIGVzY2FwZSA9ICFlc2NhcGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlICs9IHF1b3RlO1xuICAgICAgICAgIG5leHQgPSB2YWx1ZS5sZW5ndGggLSAxO1xuICAgICAgICAgIHRva2VuLnVuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoZXNjYXBlKTtcbiAgICAgIHRva2VuLnZhbHVlID0gdmFsdWUuc2xpY2UocG9zICsgMSwgbmV4dCk7XG4gICAgICB0b2tlbi5zb3VyY2VFbmRJbmRleCA9IHRva2VuLnVuY2xvc2VkID8gbmV4dCA6IG5leHQgKyAxO1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgcG9zID0gbmV4dCArIDE7XG4gICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgICAvLyBDb21tZW50c1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gc2xhc2ggJiYgdmFsdWUuY2hhckNvZGVBdChwb3MgKyAxKSA9PT0gc3Rhcikge1xuICAgICAgbmV4dCA9IHZhbHVlLmluZGV4T2YoXCIqL1wiLCBwb3MpO1xuXG4gICAgICB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogXCJjb21tZW50XCIsXG4gICAgICAgIHNvdXJjZUluZGV4OiBwb3MsXG4gICAgICAgIHNvdXJjZUVuZEluZGV4OiBuZXh0ICsgMlxuICAgICAgfTtcblxuICAgICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICAgIHRva2VuLnVuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgbmV4dCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgdG9rZW4uc291cmNlRW5kSW5kZXggPSBuZXh0O1xuICAgICAgfVxuXG4gICAgICB0b2tlbi52YWx1ZSA9IHZhbHVlLnNsaWNlKHBvcyArIDIsIG5leHQpO1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuXG4gICAgICBwb3MgPSBuZXh0ICsgMjtcbiAgICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgIC8vIE9wZXJhdGlvbiB3aXRoaW4gY2FsY1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAoY29kZSA9PT0gc2xhc2ggfHwgY29kZSA9PT0gc3RhcikgJiZcbiAgICAgIHBhcmVudCAmJlxuICAgICAgcGFyZW50LnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgcGFyZW50LnZhbHVlID09PSBcImNhbGNcIlxuICAgICkge1xuICAgICAgdG9rZW4gPSB2YWx1ZVtwb3NdO1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiBcIndvcmRcIixcbiAgICAgICAgc291cmNlSW5kZXg6IHBvcyAtIGJlZm9yZS5sZW5ndGgsXG4gICAgICAgIHNvdXJjZUVuZEluZGV4OiBwb3MgKyB0b2tlbi5sZW5ndGgsXG4gICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgfSk7XG4gICAgICBwb3MgKz0gMTtcbiAgICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgIC8vIERpdmlkZXJzXG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBzbGFzaCB8fCBjb2RlID09PSBjb21tYSB8fCBjb2RlID09PSBjb2xvbikge1xuICAgICAgdG9rZW4gPSB2YWx1ZVtwb3NdO1xuXG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiZGl2XCIsXG4gICAgICAgIHNvdXJjZUluZGV4OiBwb3MgLSBiZWZvcmUubGVuZ3RoLFxuICAgICAgICBzb3VyY2VFbmRJbmRleDogcG9zICsgdG9rZW4ubGVuZ3RoLFxuICAgICAgICB2YWx1ZTogdG9rZW4sXG4gICAgICAgIGJlZm9yZTogYmVmb3JlLFxuICAgICAgICBhZnRlcjogXCJcIlxuICAgICAgfSk7XG4gICAgICBiZWZvcmUgPSBcIlwiO1xuXG4gICAgICBwb3MgKz0gMTtcbiAgICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgIC8vIE9wZW4gcGFyZW50aGVzZXNcbiAgICB9IGVsc2UgaWYgKG9wZW5QYXJlbnRoZXNlcyA9PT0gY29kZSkge1xuICAgICAgLy8gV2hpdGVzcGFjZXMgYWZ0ZXIgb3BlbiBwYXJlbnRoZXNlc1xuICAgICAgbmV4dCA9IHBvcztcbiAgICAgIGRvIHtcbiAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChuZXh0KTtcbiAgICAgIH0gd2hpbGUgKGNvZGUgPD0gMzIpO1xuICAgICAgcGFyZW50aGVzZXNPcGVuUG9zID0gcG9zO1xuICAgICAgdG9rZW4gPSB7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgc291cmNlSW5kZXg6IHBvcyAtIG5hbWUubGVuZ3RoLFxuICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgYmVmb3JlOiB2YWx1ZS5zbGljZShwYXJlbnRoZXNlc09wZW5Qb3MgKyAxLCBuZXh0KVxuICAgICAgfTtcbiAgICAgIHBvcyA9IG5leHQ7XG5cbiAgICAgIGlmIChuYW1lID09PSBcInVybFwiICYmIGNvZGUgIT09IHNpbmdsZVF1b3RlICYmIGNvZGUgIT09IGRvdWJsZVF1b3RlKSB7XG4gICAgICAgIG5leHQgLT0gMTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGVzY2FwZSA9IGZhbHNlO1xuICAgICAgICAgIG5leHQgPSB2YWx1ZS5pbmRleE9mKFwiKVwiLCBuZXh0ICsgMSk7XG4gICAgICAgICAgaWYgKH5uZXh0KSB7XG4gICAgICAgICAgICBlc2NhcGVQb3MgPSBuZXh0O1xuICAgICAgICAgICAgd2hpbGUgKHZhbHVlLmNoYXJDb2RlQXQoZXNjYXBlUG9zIC0gMSkgPT09IGJhY2tzbGFzaCkge1xuICAgICAgICAgICAgICBlc2NhcGVQb3MgLT0gMTtcbiAgICAgICAgICAgICAgZXNjYXBlID0gIWVzY2FwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgKz0gXCIpXCI7XG4gICAgICAgICAgICBuZXh0ID0gdmFsdWUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHRva2VuLnVuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGVzY2FwZSk7XG4gICAgICAgIC8vIFdoaXRlc3BhY2VzIGJlZm9yZSBjbG9zZWRcbiAgICAgICAgd2hpdGVzcGFjZVBvcyA9IG5leHQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB3aGl0ZXNwYWNlUG9zIC09IDE7XG4gICAgICAgICAgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQod2hpdGVzcGFjZVBvcyk7XG4gICAgICAgIH0gd2hpbGUgKGNvZGUgPD0gMzIpO1xuICAgICAgICBpZiAocGFyZW50aGVzZXNPcGVuUG9zIDwgd2hpdGVzcGFjZVBvcykge1xuICAgICAgICAgIGlmIChwb3MgIT09IHdoaXRlc3BhY2VQb3MgKyAxKSB7XG4gICAgICAgICAgICB0b2tlbi5ub2RlcyA9IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwid29yZFwiLFxuICAgICAgICAgICAgICAgIHNvdXJjZUluZGV4OiBwb3MsXG4gICAgICAgICAgICAgICAgc291cmNlRW5kSW5kZXg6IHdoaXRlc3BhY2VQb3MgKyAxLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS5zbGljZShwb3MsIHdoaXRlc3BhY2VQb3MgKyAxKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi5ub2RlcyA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodG9rZW4udW5jbG9zZWQgJiYgd2hpdGVzcGFjZVBvcyArIDEgIT09IG5leHQpIHtcbiAgICAgICAgICAgIHRva2VuLmFmdGVyID0gXCJcIjtcbiAgICAgICAgICAgIHRva2VuLm5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiBcInNwYWNlXCIsXG4gICAgICAgICAgICAgIHNvdXJjZUluZGV4OiB3aGl0ZXNwYWNlUG9zICsgMSxcbiAgICAgICAgICAgICAgc291cmNlRW5kSW5kZXg6IG5leHQsXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS5zbGljZSh3aGl0ZXNwYWNlUG9zICsgMSwgbmV4dClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi5hZnRlciA9IHZhbHVlLnNsaWNlKHdoaXRlc3BhY2VQb3MgKyAxLCBuZXh0KTtcbiAgICAgICAgICAgIHRva2VuLnNvdXJjZUVuZEluZGV4ID0gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW4uYWZ0ZXIgPSBcIlwiO1xuICAgICAgICAgIHRva2VuLm5vZGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gbmV4dCArIDE7XG4gICAgICAgIHRva2VuLnNvdXJjZUVuZEluZGV4ID0gdG9rZW4udW5jbG9zZWQgPyBuZXh0IDogcG9zO1xuICAgICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYWxhbmNlZCArPSAxO1xuICAgICAgICB0b2tlbi5hZnRlciA9IFwiXCI7XG4gICAgICAgIHRva2VuLnNvdXJjZUVuZEluZGV4ID0gcG9zICsgMTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBzdGFjay5wdXNoKHRva2VuKTtcbiAgICAgICAgdG9rZW5zID0gdG9rZW4ubm9kZXMgPSBbXTtcbiAgICAgICAgcGFyZW50ID0gdG9rZW47XG4gICAgICB9XG4gICAgICBuYW1lID0gXCJcIjtcblxuICAgICAgLy8gQ2xvc2UgcGFyZW50aGVzZXNcbiAgICB9IGVsc2UgaWYgKGNsb3NlUGFyZW50aGVzZXMgPT09IGNvZGUgJiYgYmFsYW5jZWQpIHtcbiAgICAgIHBvcyArPSAxO1xuICAgICAgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQocG9zKTtcblxuICAgICAgcGFyZW50LmFmdGVyID0gYWZ0ZXI7XG4gICAgICBwYXJlbnQuc291cmNlRW5kSW5kZXggKz0gYWZ0ZXIubGVuZ3RoO1xuICAgICAgYWZ0ZXIgPSBcIlwiO1xuICAgICAgYmFsYW5jZWQgLT0gMTtcbiAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLnNvdXJjZUVuZEluZGV4ID0gcG9zO1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgICBwYXJlbnQgPSBzdGFja1tiYWxhbmNlZF07XG4gICAgICB0b2tlbnMgPSBwYXJlbnQubm9kZXM7XG5cbiAgICAgIC8vIFdvcmRzXG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHQgPSBwb3M7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChjb2RlID09PSBiYWNrc2xhc2gpIHtcbiAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChuZXh0KTtcbiAgICAgIH0gd2hpbGUgKFxuICAgICAgICBuZXh0IDwgbWF4ICYmXG4gICAgICAgICEoXG4gICAgICAgICAgY29kZSA8PSAzMiB8fFxuICAgICAgICAgIGNvZGUgPT09IHNpbmdsZVF1b3RlIHx8XG4gICAgICAgICAgY29kZSA9PT0gZG91YmxlUXVvdGUgfHxcbiAgICAgICAgICBjb2RlID09PSBjb21tYSB8fFxuICAgICAgICAgIGNvZGUgPT09IGNvbG9uIHx8XG4gICAgICAgICAgY29kZSA9PT0gc2xhc2ggfHxcbiAgICAgICAgICBjb2RlID09PSBvcGVuUGFyZW50aGVzZXMgfHxcbiAgICAgICAgICAoY29kZSA9PT0gc3RhciAmJlxuICAgICAgICAgICAgcGFyZW50ICYmXG4gICAgICAgICAgICBwYXJlbnQudHlwZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICBwYXJlbnQudmFsdWUgPT09IFwiY2FsY1wiKSB8fFxuICAgICAgICAgIChjb2RlID09PSBzbGFzaCAmJlxuICAgICAgICAgICAgcGFyZW50LnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgcGFyZW50LnZhbHVlID09PSBcImNhbGNcIikgfHxcbiAgICAgICAgICAoY29kZSA9PT0gY2xvc2VQYXJlbnRoZXNlcyAmJiBiYWxhbmNlZClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHRva2VuID0gdmFsdWUuc2xpY2UocG9zLCBuZXh0KTtcblxuICAgICAgaWYgKG9wZW5QYXJlbnRoZXNlcyA9PT0gY29kZSkge1xuICAgICAgICBuYW1lID0gdG9rZW47XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAodUxvd2VyID09PSB0b2tlbi5jaGFyQ29kZUF0KDApIHx8IHVVcHBlciA9PT0gdG9rZW4uY2hhckNvZGVBdCgwKSkgJiZcbiAgICAgICAgcGx1cyA9PT0gdG9rZW4uY2hhckNvZGVBdCgxKSAmJlxuICAgICAgICBpc1VuaWNvZGVSYW5nZS50ZXN0KHRva2VuLnNsaWNlKDIpKVxuICAgICAgKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcInVuaWNvZGUtcmFuZ2VcIixcbiAgICAgICAgICBzb3VyY2VJbmRleDogcG9zLFxuICAgICAgICAgIHNvdXJjZUVuZEluZGV4OiBuZXh0LFxuICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcIndvcmRcIixcbiAgICAgICAgICBzb3VyY2VJbmRleDogcG9zLFxuICAgICAgICAgIHNvdXJjZUVuZEluZGV4OiBuZXh0LFxuICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcG9zID0gbmV4dDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvczsgcG9zIC09IDEpIHtcbiAgICBzdGFja1twb3NdLnVuY2xvc2VkID0gdHJ1ZTtcbiAgICBzdGFja1twb3NdLnNvdXJjZUVuZEluZGV4ID0gdmFsdWUubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN0YWNrWzBdLm5vZGVzO1xufTtcblxudmFyIHdhbGskMSA9IGZ1bmN0aW9uIHdhbGsobm9kZXMsIGNiLCBidWJibGUpIHtcbiAgdmFyIGksIG1heCwgbm9kZSwgcmVzdWx0O1xuXG4gIGZvciAoaSA9IDAsIG1heCA9IG5vZGVzLmxlbmd0aDsgaSA8IG1heDsgaSArPSAxKSB7XG4gICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmICghYnViYmxlKSB7XG4gICAgICByZXN1bHQgPSBjYihub2RlLCBpLCBub2Rlcyk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgcmVzdWx0ICE9PSBmYWxzZSAmJlxuICAgICAgbm9kZS50eXBlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgIEFycmF5LmlzQXJyYXkobm9kZS5ub2RlcylcbiAgICApIHtcbiAgICAgIHdhbGsobm9kZS5ub2RlcywgY2IsIGJ1YmJsZSk7XG4gICAgfVxuXG4gICAgaWYgKGJ1YmJsZSkge1xuICAgICAgY2Iobm9kZSwgaSwgbm9kZXMpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc3RyaW5naWZ5Tm9kZShub2RlLCBjdXN0b20pIHtcbiAgdmFyIHR5cGUgPSBub2RlLnR5cGU7XG4gIHZhciB2YWx1ZSA9IG5vZGUudmFsdWU7XG4gIHZhciBidWY7XG4gIHZhciBjdXN0b21SZXN1bHQ7XG5cbiAgaWYgKGN1c3RvbSAmJiAoY3VzdG9tUmVzdWx0ID0gY3VzdG9tKG5vZGUpKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGN1c3RvbVJlc3VsdDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcIndvcmRcIiB8fCB0eXBlID09PSBcInNwYWNlXCIpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGJ1ZiA9IG5vZGUucXVvdGUgfHwgXCJcIjtcbiAgICByZXR1cm4gYnVmICsgdmFsdWUgKyAobm9kZS51bmNsb3NlZCA/IFwiXCIgOiBidWYpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgcmV0dXJuIFwiLypcIiArIHZhbHVlICsgKG5vZGUudW5jbG9zZWQgPyBcIlwiIDogXCIqL1wiKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcImRpdlwiKSB7XG4gICAgcmV0dXJuIChub2RlLmJlZm9yZSB8fCBcIlwiKSArIHZhbHVlICsgKG5vZGUuYWZ0ZXIgfHwgXCJcIik7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShub2RlLm5vZGVzKSkge1xuICAgIGJ1ZiA9IHN0cmluZ2lmeSQxKG5vZGUubm9kZXMsIGN1c3RvbSk7XG4gICAgaWYgKHR5cGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIHZhbHVlICtcbiAgICAgIFwiKFwiICtcbiAgICAgIChub2RlLmJlZm9yZSB8fCBcIlwiKSArXG4gICAgICBidWYgK1xuICAgICAgKG5vZGUuYWZ0ZXIgfHwgXCJcIikgK1xuICAgICAgKG5vZGUudW5jbG9zZWQgPyBcIlwiIDogXCIpXCIpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeSQxKG5vZGVzLCBjdXN0b20pIHtcbiAgdmFyIHJlc3VsdCwgaTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlcykpIHtcbiAgICByZXN1bHQgPSBcIlwiO1xuICAgIGZvciAoaSA9IG5vZGVzLmxlbmd0aCAtIDE7IH5pOyBpIC09IDEpIHtcbiAgICAgIHJlc3VsdCA9IHN0cmluZ2lmeU5vZGUobm9kZXNbaV0sIGN1c3RvbSkgKyByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHN0cmluZ2lmeU5vZGUobm9kZXMsIGN1c3RvbSk7XG59XG5cbnZhciBzdHJpbmdpZnlfMSA9IHN0cmluZ2lmeSQxO1xuXG52YXIgdW5pdDtcbnZhciBoYXNSZXF1aXJlZFVuaXQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVVbml0ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkVW5pdCkgcmV0dXJuIHVuaXQ7XG5cdGhhc1JlcXVpcmVkVW5pdCA9IDE7XG5cdHZhciBtaW51cyA9IFwiLVwiLmNoYXJDb2RlQXQoMCk7XG5cdHZhciBwbHVzID0gXCIrXCIuY2hhckNvZGVBdCgwKTtcblx0dmFyIGRvdCA9IFwiLlwiLmNoYXJDb2RlQXQoMCk7XG5cdHZhciBleHAgPSBcImVcIi5jaGFyQ29kZUF0KDApO1xuXHR2YXIgRVhQID0gXCJFXCIuY2hhckNvZGVBdCgwKTtcblxuXHQvLyBDaGVjayBpZiB0aHJlZSBjb2RlIHBvaW50cyB3b3VsZCBzdGFydCBhIG51bWJlclxuXHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLXN5bnRheC0zLyNzdGFydHMtd2l0aC1hLW51bWJlclxuXHRmdW5jdGlvbiBsaWtlTnVtYmVyKHZhbHVlKSB7XG5cdCAgdmFyIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuXHQgIHZhciBuZXh0Q29kZTtcblxuXHQgIGlmIChjb2RlID09PSBwbHVzIHx8IGNvZGUgPT09IG1pbnVzKSB7XG5cdCAgICBuZXh0Q29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoMSk7XG5cblx0ICAgIGlmIChuZXh0Q29kZSA+PSA0OCAmJiBuZXh0Q29kZSA8PSA1Nykge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgdmFyIG5leHROZXh0Q29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoMik7XG5cblx0ICAgIGlmIChuZXh0Q29kZSA9PT0gZG90ICYmIG5leHROZXh0Q29kZSA+PSA0OCAmJiBuZXh0TmV4dENvZGUgPD0gNTcpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cblx0ICBpZiAoY29kZSA9PT0gZG90KSB7XG5cdCAgICBuZXh0Q29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoMSk7XG5cblx0ICAgIGlmIChuZXh0Q29kZSA+PSA0OCAmJiBuZXh0Q29kZSA8PSA1Nykge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblxuXHQgIGlmIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHtcblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIENvbnN1bWUgYSBudW1iZXJcblx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1zeW50YXgtMy8jY29uc3VtZS1udW1iZXJcblx0dW5pdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgdmFyIHBvcyA9IDA7XG5cdCAgdmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblx0ICB2YXIgY29kZTtcblx0ICB2YXIgbmV4dENvZGU7XG5cdCAgdmFyIG5leHROZXh0Q29kZTtcblxuXHQgIGlmIChsZW5ndGggPT09IDAgfHwgIWxpa2VOdW1iZXIodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXG5cdCAgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQocG9zKTtcblxuXHQgIGlmIChjb2RlID09PSBwbHVzIHx8IGNvZGUgPT09IG1pbnVzKSB7XG5cdCAgICBwb3MrKztcblx0ICB9XG5cblx0ICB3aGlsZSAocG9zIDwgbGVuZ3RoKSB7XG5cdCAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuXG5cdCAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiA1Nykge1xuXHQgICAgICBicmVhaztcblx0ICAgIH1cblxuXHQgICAgcG9zICs9IDE7XG5cdCAgfVxuXG5cdCAgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQocG9zKTtcblx0ICBuZXh0Q29kZSA9IHZhbHVlLmNoYXJDb2RlQXQocG9zICsgMSk7XG5cblx0ICBpZiAoY29kZSA9PT0gZG90ICYmIG5leHRDb2RlID49IDQ4ICYmIG5leHRDb2RlIDw9IDU3KSB7XG5cdCAgICBwb3MgKz0gMjtcblxuXHQgICAgd2hpbGUgKHBvcyA8IGxlbmd0aCkge1xuXHQgICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuXG5cdCAgICAgIGlmIChjb2RlIDwgNDggfHwgY29kZSA+IDU3KSB7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblxuXHQgICAgICBwb3MgKz0gMTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuXHQgIG5leHRDb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MgKyAxKTtcblx0ICBuZXh0TmV4dENvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyArIDIpO1xuXG5cdCAgaWYgKFxuXHQgICAgKGNvZGUgPT09IGV4cCB8fCBjb2RlID09PSBFWFApICYmXG5cdCAgICAoKG5leHRDb2RlID49IDQ4ICYmIG5leHRDb2RlIDw9IDU3KSB8fFxuXHQgICAgICAoKG5leHRDb2RlID09PSBwbHVzIHx8IG5leHRDb2RlID09PSBtaW51cykgJiZcblx0ICAgICAgICBuZXh0TmV4dENvZGUgPj0gNDggJiZcblx0ICAgICAgICBuZXh0TmV4dENvZGUgPD0gNTcpKVxuXHQgICkge1xuXHQgICAgcG9zICs9IG5leHRDb2RlID09PSBwbHVzIHx8IG5leHRDb2RlID09PSBtaW51cyA/IDMgOiAyO1xuXG5cdCAgICB3aGlsZSAocG9zIDwgbGVuZ3RoKSB7XG5cdCAgICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyk7XG5cblx0ICAgICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gNTcpIHtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXG5cdCAgICAgIHBvcyArPSAxO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiB7XG5cdCAgICBudW1iZXI6IHZhbHVlLnNsaWNlKDAsIHBvcyksXG5cdCAgICB1bml0OiB2YWx1ZS5zbGljZShwb3MpXG5cdCAgfTtcblx0fTtcblx0cmV0dXJuIHVuaXQ7XG59XG5cbnZhciBwYXJzZSA9IHBhcnNlJDE7XG52YXIgd2FsayA9IHdhbGskMTtcbnZhciBzdHJpbmdpZnkgPSBzdHJpbmdpZnlfMTtcblxuZnVuY3Rpb24gVmFsdWVQYXJzZXIodmFsdWUpIHtcbiAgaWYgKHRoaXMgaW5zdGFuY2VvZiBWYWx1ZVBhcnNlcikge1xuICAgIHRoaXMubm9kZXMgPSBwYXJzZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmV0dXJuIG5ldyBWYWx1ZVBhcnNlcih2YWx1ZSk7XG59XG5cblZhbHVlUGFyc2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLm5vZGVzKSA/IHN0cmluZ2lmeSh0aGlzLm5vZGVzKSA6IFwiXCI7XG59O1xuXG5WYWx1ZVBhcnNlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uKGNiLCBidWJibGUpIHtcbiAgd2Fsayh0aGlzLm5vZGVzLCBjYiwgYnViYmxlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5WYWx1ZVBhcnNlci51bml0ID0gcmVxdWlyZVVuaXQoKTtcblxuVmFsdWVQYXJzZXIud2FsayA9IHdhbGs7XG5cblZhbHVlUGFyc2VyLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcblxudmFyIGxpYiA9IFZhbHVlUGFyc2VyO1xuXG5leHBvcnQgeyBsaWIgYXMgbCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vite/dist/node/chunks/dep-07a79996.js\n");

/***/ }),

/***/ "./node_modules/vite/dist/node/chunks/dep-7591464a.js":
/*!************************************************************!*\
  !*** ./node_modules/vite/dist/node/chunks/dep-7591464a.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"i\": () => (/* binding */ index)\n/* harmony export */ });\n/* harmony import */ var postcss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! postcss */ \"./node_modules/postcss/lib/postcss.mjs\");\n/* harmony import */ var _dep_51c4f80a_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dep-51c4f80a.js */ \"./node_modules/vite/dist/node/chunks/dep-51c4f80a.js\");\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module 'crypto'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\n/* harmony import */ var _dep_07a79996_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dep-07a79996.js */ \"./node_modules/vite/dist/node/chunks/dep-07a79996.js\");\n/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! node:url */ \"node:url\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var node_module__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! node:module */ \"node:module\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ \"./node_modules/process/browser.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst __filename = (0,node_url__WEBPACK_IMPORTED_MODULE_5__.fileURLToPath)(\"file:///var/www/projects/woopons/woopons/node_modules/vite/dist/node/chunks/dep-7591464a.js\");\nconst __dirname = (0,node_path__WEBPACK_IMPORTED_MODULE_6__.dirname)(__filename);\nconst require = (0,node_module__WEBPACK_IMPORTED_MODULE_7__.createRequire)(\"file:///var/www/projects/woopons/woopons/node_modules/vite/dist/node/chunks/dep-7591464a.js\");\nconst __require = require;\nfunction _mergeNamespaces(n, m) {\n  for (var i = 0; i < m.length; i++) {\n    var e = m[i];\n    if (typeof e !== 'string' && !Array.isArray(e)) { for (var k in e) {\n      if (k !== 'default' && !(k in n)) {\n        n[k] = e[k];\n      }\n    } }\n  }\n  return n;\n}\n\nvar build = {exports: {}};\n\n/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match words composed of alphanumeric characters. */\nvar reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n/** Used to match Latin Unicode letters (excluding mathematical operators). */\nvar reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n    rsComboMarksRange = '\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20f0',\n    rsDingbatRange = '\\\\u2700-\\\\u27bf',\n    rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\n    rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\n    rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\n    rsPunctuationRange = '\\\\u2000-\\\\u206f',\n    rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\n    rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\n    rsVarRange = '\\\\ufe0e\\\\ufe0f',\n    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n/** Used to compose unicode capture groups. */\nvar rsApos = \"['\\u2019]\",\n    rsAstral = '[' + rsAstralRange + ']',\n    rsBreak = '[' + rsBreakRange + ']',\n    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',\n    rsDigits = '\\\\d+',\n    rsDingbat = '[' + rsDingbatRange + ']',\n    rsLower = '[' + rsLowerRange + ']',\n    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\n    rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n    rsNonAstral = '[^' + rsAstralRange + ']',\n    rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n    rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n    rsUpper = '[' + rsUpperRange + ']',\n    rsZWJ = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nvar rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',\n    rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',\n    rsOptLowerContr = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',\n    rsOptUpperContr = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',\n    reOptMod = rsModifier + '?',\n    rsOptVar = '[' + rsVarRange + ']?',\n    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n    rsSeq = rsOptVar + reOptMod + rsOptJoin,\n    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,\n    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n/** Used to match apostrophes. */\nvar reApos = RegExp(rsApos, 'g');\n\n/**\n * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n */\nvar reComboMark = RegExp(rsCombo, 'g');\n\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\nvar reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n/** Used to match complex or compound words. */\nvar reUnicodeWord = RegExp([\n  rsUpper + '?' + rsLower + '+' + rsOptLowerContr + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\n  rsUpperMisc + '+' + rsOptUpperContr + '(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')',\n  rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr,\n  rsUpper + '+' + rsOptUpperContr,\n  rsDigits,\n  rsEmoji\n].join('|'), 'g');\n\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\nvar reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');\n\n/** Used to detect strings that need a more robust regexp to match words. */\nvar reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n\n/** Used to map Latin Unicode letters to basic Latin letters. */\nvar deburredLetters = {\n  // Latin-1 Supplement block.\n  '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n  '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n  '\\xc7': 'C',  '\\xe7': 'c',\n  '\\xd0': 'D',  '\\xf0': 'd',\n  '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n  '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n  '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n  '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n  '\\xd1': 'N',  '\\xf1': 'n',\n  '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n  '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n  '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n  '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n  '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n  '\\xc6': 'Ae', '\\xe6': 'ae',\n  '\\xde': 'Th', '\\xfe': 'th',\n  '\\xdf': 'ss',\n  // Latin Extended-A block.\n  '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\n  '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\n  '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\n  '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\n  '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\n  '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\n  '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\n  '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\n  '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\n  '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\n  '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\n  '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\n  '\\u0134': 'J',  '\\u0135': 'j',\n  '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\n  '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\n  '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\n  '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\n  '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\n  '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\n  '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\n  '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\n  '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\n  '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\n  '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\n  '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\n  '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\n  '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\n  '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\n  '\\u0174': 'W',  '\\u0175': 'w',\n  '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\n  '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\n  '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\n  '\\u0132': 'IJ', '\\u0133': 'ij',\n  '\\u0152': 'Oe', '\\u0153': 'oe',\n  '\\u0149': \"'n\", '\\u017f': 'ss'\n};\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof _dep_51c4f80a_js__WEBPACK_IMPORTED_MODULE_1__.A == 'object' && _dep_51c4f80a_js__WEBPACK_IMPORTED_MODULE_1__.A && _dep_51c4f80a_js__WEBPACK_IMPORTED_MODULE_1__.A.Object === Object && _dep_51c4f80a_js__WEBPACK_IMPORTED_MODULE_1__.A;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root$2 = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\n/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction asciiToArray(string) {\n  return string.split('');\n}\n\n/**\n * Splits an ASCII `string` into an array of its words.\n *\n * @private\n * @param {string} The string to inspect.\n * @returns {Array} Returns the words of `string`.\n */\nfunction asciiWords(string) {\n  return string.match(reAsciiWord) || [];\n}\n\n/**\n * The base implementation of `_.propertyOf` without support for deep paths.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyOf(object) {\n  return function(key) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n * letters to basic Latin letters.\n *\n * @private\n * @param {string} letter The matched letter to deburr.\n * @returns {string} Returns the deburred letter.\n */\nvar deburrLetter = basePropertyOf(deburredLetters);\n\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n\n/**\n * Checks if `string` contains a word composed of Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a word is found, else `false`.\n */\nfunction hasUnicodeWord(string) {\n  return reHasUnicodeWord.test(string);\n}\n\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction stringToArray(string) {\n  return hasUnicode(string)\n    ? unicodeToArray(string)\n    : asciiToArray(string);\n}\n\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction unicodeToArray(string) {\n  return string.match(reUnicode) || [];\n}\n\n/**\n * Splits a Unicode `string` into an array of its words.\n *\n * @private\n * @param {string} The string to inspect.\n * @returns {Array} Returns the words of `string`.\n */\nfunction unicodeWords(string) {\n  return string.match(reUnicodeWord) || [];\n}\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar Symbol$1 = root$2.Symbol;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `array` to a slice if it's needed.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {number} start The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the cast slice.\n */\nfunction castSlice(array, start, end) {\n  var length = array.length;\n  end = end === undefined ? length : end;\n  return (!start && end >= length) ? array : baseSlice(array, start, end);\n}\n\n/**\n * Creates a function like `_.lowerFirst`.\n *\n * @private\n * @param {string} methodName The name of the `String` case method to use.\n * @returns {Function} Returns the new case function.\n */\nfunction createCaseFirst(methodName) {\n  return function(string) {\n    string = toString(string);\n\n    var strSymbols = hasUnicode(string)\n      ? stringToArray(string)\n      : undefined;\n\n    var chr = strSymbols\n      ? strSymbols[0]\n      : string.charAt(0);\n\n    var trailing = strSymbols\n      ? castSlice(strSymbols, 1).join('')\n      : string.slice(1);\n\n    return chr[methodName]() + trailing;\n  };\n}\n\n/**\n * Creates a function like `_.camelCase`.\n *\n * @private\n * @param {Function} callback The function to combine each word.\n * @returns {Function} Returns the new compounder function.\n */\nfunction createCompounder(callback) {\n  return function(string) {\n    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\n  };\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to convert.\n * @returns {string} Returns the camel cased string.\n * @example\n *\n * _.camelCase('Foo Bar');\n * // => 'fooBar'\n *\n * _.camelCase('--foo-bar--');\n * // => 'fooBar'\n *\n * _.camelCase('__FOO_BAR__');\n * // => 'fooBar'\n */\nvar camelCase = createCompounder(function(result, word, index) {\n  word = word.toLowerCase();\n  return result + (index ? capitalize(word) : word);\n});\n\n/**\n * Converts the first character of `string` to upper case and the remaining\n * to lower case.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to capitalize.\n * @returns {string} Returns the capitalized string.\n * @example\n *\n * _.capitalize('FRED');\n * // => 'Fred'\n */\nfunction capitalize(string) {\n  return upperFirst(toString(string).toLowerCase());\n}\n\n/**\n * Deburrs `string` by converting\n * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n * letters to basic Latin letters and removing\n * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to deburr.\n * @returns {string} Returns the deburred string.\n * @example\n *\n * _.deburr('dj vu');\n * // => 'deja vu'\n */\nfunction deburr(string) {\n  string = toString(string);\n  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\n}\n\n/**\n * Converts the first character of `string` to upper case.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category String\n * @param {string} [string=''] The string to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.upperFirst('fred');\n * // => 'Fred'\n *\n * _.upperFirst('FRED');\n * // => 'FRED'\n */\nvar upperFirst = createCaseFirst('toUpperCase');\n\n/**\n * Splits `string` into an array of its words.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to inspect.\n * @param {RegExp|string} [pattern] The pattern to match words.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the words of `string`.\n * @example\n *\n * _.words('fred, barney, & pebbles');\n * // => ['fred', 'barney', 'pebbles']\n *\n * _.words('fred, barney, & pebbles', /[^, ]+/g);\n * // => ['fred', 'barney', '&', 'pebbles']\n */\nfunction words(string, pattern, guard) {\n  string = toString(string);\n  pattern = guard ? undefined : pattern;\n\n  if (pattern === undefined) {\n    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n  }\n  return string.match(pattern) || [];\n}\n\nvar lodash_camelcase = camelCase;\n\nvar wasmHash = {exports: {}};\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar hasRequiredWasmHash;\n\nfunction requireWasmHash () {\n\tif (hasRequiredWasmHash) return wasmHash.exports;\n\thasRequiredWasmHash = 1;\n\n\t// 65536 is the size of a wasm memory page\n\t// 64 is the maximum chunk size for every possible wasm hash implementation\n\t// 4 is the maximum number of bytes per char for string encoding (max is utf-8)\n\t// ~3 makes sure that it's always a block of 4 chars, so avoid partially encoded bytes for base64\n\tconst MAX_SHORT_STRING = Math.floor((65536 - 64) / 4) & ~3;\n\n\tclass WasmHash {\n\t  /**\n\t   * @param {WebAssembly.Instance} instance wasm instance\n\t   * @param {WebAssembly.Instance[]} instancesPool pool of instances\n\t   * @param {number} chunkSize size of data chunks passed to wasm\n\t   * @param {number} digestSize size of digest returned by wasm\n\t   */\n\t  constructor(instance, instancesPool, chunkSize, digestSize) {\n\t    const exports = /** @type {any} */ (instance.exports);\n\n\t    exports.init();\n\n\t    this.exports = exports;\n\t    this.mem = Buffer.from(exports.memory.buffer, 0, 65536);\n\t    this.buffered = 0;\n\t    this.instancesPool = instancesPool;\n\t    this.chunkSize = chunkSize;\n\t    this.digestSize = digestSize;\n\t  }\n\n\t  reset() {\n\t    this.buffered = 0;\n\t    this.exports.init();\n\t  }\n\n\t  /**\n\t   * @param {Buffer | string} data data\n\t   * @param {BufferEncoding=} encoding encoding\n\t   * @returns {this} itself\n\t   */\n\t  update(data, encoding) {\n\t    if (typeof data === \"string\") {\n\t      while (data.length > MAX_SHORT_STRING) {\n\t        this._updateWithShortString(data.slice(0, MAX_SHORT_STRING), encoding);\n\t        data = data.slice(MAX_SHORT_STRING);\n\t      }\n\n\t      this._updateWithShortString(data, encoding);\n\n\t      return this;\n\t    }\n\n\t    this._updateWithBuffer(data);\n\n\t    return this;\n\t  }\n\n\t  /**\n\t   * @param {string} data data\n\t   * @param {BufferEncoding=} encoding encoding\n\t   * @returns {void}\n\t   */\n\t  _updateWithShortString(data, encoding) {\n\t    const { exports, buffered, mem, chunkSize } = this;\n\n\t    let endPos;\n\n\t    if (data.length < 70) {\n\t      if (!encoding || encoding === \"utf-8\" || encoding === \"utf8\") {\n\t        endPos = buffered;\n\t        for (let i = 0; i < data.length; i++) {\n\t          const cc = data.charCodeAt(i);\n\n\t          if (cc < 0x80) {\n\t            mem[endPos++] = cc;\n\t          } else if (cc < 0x800) {\n\t            mem[endPos] = (cc >> 6) | 0xc0;\n\t            mem[endPos + 1] = (cc & 0x3f) | 0x80;\n\t            endPos += 2;\n\t          } else {\n\t            // bail-out for weird chars\n\t            endPos += mem.write(data.slice(i), endPos, encoding);\n\t            break;\n\t          }\n\t        }\n\t      } else if (encoding === \"latin1\") {\n\t        endPos = buffered;\n\n\t        for (let i = 0; i < data.length; i++) {\n\t          const cc = data.charCodeAt(i);\n\n\t          mem[endPos++] = cc;\n\t        }\n\t      } else {\n\t        endPos = buffered + mem.write(data, buffered, encoding);\n\t      }\n\t    } else {\n\t      endPos = buffered + mem.write(data, buffered, encoding);\n\t    }\n\n\t    if (endPos < chunkSize) {\n\t      this.buffered = endPos;\n\t    } else {\n\t      const l = endPos & ~(this.chunkSize - 1);\n\n\t      exports.update(l);\n\n\t      const newBuffered = endPos - l;\n\n\t      this.buffered = newBuffered;\n\n\t      if (newBuffered > 0) {\n\t        mem.copyWithin(0, l, endPos);\n\t      }\n\t    }\n\t  }\n\n\t  /**\n\t   * @param {Buffer} data data\n\t   * @returns {void}\n\t   */\n\t  _updateWithBuffer(data) {\n\t    const { exports, buffered, mem } = this;\n\t    const length = data.length;\n\n\t    if (buffered + length < this.chunkSize) {\n\t      data.copy(mem, buffered, 0, length);\n\n\t      this.buffered += length;\n\t    } else {\n\t      const l = (buffered + length) & ~(this.chunkSize - 1);\n\n\t      if (l > 65536) {\n\t        let i = 65536 - buffered;\n\n\t        data.copy(mem, buffered, 0, i);\n\t        exports.update(65536);\n\n\t        const stop = l - buffered - 65536;\n\n\t        while (i < stop) {\n\t          data.copy(mem, 0, i, i + 65536);\n\t          exports.update(65536);\n\t          i += 65536;\n\t        }\n\n\t        data.copy(mem, 0, i, l - buffered);\n\n\t        exports.update(l - buffered - i);\n\t      } else {\n\t        data.copy(mem, buffered, 0, l - buffered);\n\n\t        exports.update(l);\n\t      }\n\n\t      const newBuffered = length + buffered - l;\n\n\t      this.buffered = newBuffered;\n\n\t      if (newBuffered > 0) {\n\t        data.copy(mem, 0, length - newBuffered, length);\n\t      }\n\t    }\n\t  }\n\n\t  digest(type) {\n\t    const { exports, buffered, mem, digestSize } = this;\n\n\t    exports.final(buffered);\n\n\t    this.instancesPool.push(this);\n\n\t    const hex = mem.toString(\"latin1\", 0, digestSize);\n\n\t    if (type === \"hex\") {\n\t      return hex;\n\t    }\n\n\t    if (type === \"binary\" || !type) {\n\t      return Buffer.from(hex, \"hex\");\n\t    }\n\n\t    return Buffer.from(hex, \"hex\").toString(type);\n\t  }\n\t}\n\n\tconst create = (wasmModule, instancesPool, chunkSize, digestSize) => {\n\t  if (instancesPool.length > 0) {\n\t    const old = instancesPool.pop();\n\n\t    old.reset();\n\n\t    return old;\n\t  } else {\n\t    return new WasmHash(\n\t      new WebAssembly.Instance(wasmModule),\n\t      instancesPool,\n\t      chunkSize,\n\t      digestSize\n\t    );\n\t  }\n\t};\n\n\twasmHash.exports = create;\n\twasmHash.exports.MAX_SHORT_STRING = MAX_SHORT_STRING;\n\treturn wasmHash.exports;\n}\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar xxhash64_1;\nvar hasRequiredXxhash64;\n\nfunction requireXxhash64 () {\n\tif (hasRequiredXxhash64) return xxhash64_1;\n\thasRequiredXxhash64 = 1;\n\n\tconst create = requireWasmHash();\n\n\t//#region wasm code: xxhash64 (../../../assembly/hash/xxhash64.asm.ts) --initialMemory 1\n\tconst xxhash64 = new WebAssembly.Module(\n\t  Buffer.from(\n\t    // 1173 bytes\n\t    \"AGFzbQEAAAABCAJgAX8AYAAAAwQDAQAABQMBAAEGGgV+AUIAC34BQgALfgFCAAt+AUIAC34BQgALByIEBGluaXQAAAZ1cGRhdGUAAQVmaW5hbAACBm1lbW9yeQIACrUIAzAAQtbrgu7q/Yn14AAkAELP1tO+0ser2UIkAUIAJAJC+erQ0OfJoeThACQDQgAkBAvUAQIBfwR+IABFBEAPCyMEIACtfCQEIwAhAiMBIQMjAiEEIwMhBQNAIAIgASkDAELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiECIAMgASkDCELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEDIAQgASkDEELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEEIAUgASkDGELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEFIAAgAUEgaiIBSw0ACyACJAAgAyQBIAQkAiAFJAMLqwYCAX8EfiMEQgBSBH4jACICQgGJIwEiA0IHiXwjAiIEQgyJfCMDIgVCEol8IAJCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35CnaO16oOxjYr6AH0gA0LP1tO+0ser2UJ+Qh+JQoeVr6+Ytt6bnn9+hUKHla+vmLbem55/fkKdo7Xqg7GNivoAfSAEQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef36FQoeVr6+Ytt6bnn9+Qp2jteqDsY2K+gB9IAVCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35CnaO16oOxjYr6AH0FQsXP2bLx5brqJwsjBCAArXx8IQIDQCABQQhqIABNBEAgAiABKQMAQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef36FQhuJQoeVr6+Ytt6bnn9+Qp2jteqDsY2K+gB9IQIgAUEIaiEBDAELCyABQQRqIABNBEACfyACIAE1AgBCh5Wvr5i23puef36FQheJQs/W077Sx6vZQn5C+fPd8Zn2masWfCECIAFBBGoLIQELA0AgACABRwRAIAIgATEAAELFz9my8eW66id+hUILiUKHla+vmLbem55/fiECIAFBAWohAQwBCwtBACACIAJCIYiFQs/W077Sx6vZQn4iAiACQh2IhUL5893xmfaZqxZ+IgIgAkIgiIUiAkIgiCIDQv//A4NCIIYgA0KAgPz/D4NCEIiEIgNC/4GAgPAfg0IQhiADQoD+g4CA4D+DQgiIhCIDQo+AvIDwgcAHg0IIhiADQvCBwIeAnoD4AINCBIiEIgNChoyYsODAgYMGfEIEiEKBgoSIkKDAgAGDQid+IANCsODAgYOGjJgwhHw3AwBBCCACQv////8PgyICQv//A4NCIIYgAkKAgPz/D4NCEIiEIgJC/4GAgPAfg0IQhiACQoD+g4CA4D+DQgiIhCICQo+AvIDwgcAHg0IIhiACQvCBwIeAnoD4AINCBIiEIgJChoyYsODAgYMGfEIEiEKBgoSIkKDAgAGDQid+IAJCsODAgYOGjJgwhHw3AwAL\",\n\t    \"base64\"\n\t  )\n\t);\n\t//#endregion\n\n\txxhash64_1 = create.bind(null, xxhash64, [], 32, 16);\n\treturn xxhash64_1;\n}\n\nvar BatchedHash_1;\nvar hasRequiredBatchedHash;\n\nfunction requireBatchedHash () {\n\tif (hasRequiredBatchedHash) return BatchedHash_1;\n\thasRequiredBatchedHash = 1;\n\tconst MAX_SHORT_STRING = requireWasmHash().MAX_SHORT_STRING;\n\n\tclass BatchedHash {\n\t  constructor(hash) {\n\t    this.string = undefined;\n\t    this.encoding = undefined;\n\t    this.hash = hash;\n\t  }\n\n\t  /**\n\t   * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n\t   * @param {string|Buffer} data data\n\t   * @param {string=} inputEncoding data encoding\n\t   * @returns {this} updated hash\n\t   */\n\t  update(data, inputEncoding) {\n\t    if (this.string !== undefined) {\n\t      if (\n\t        typeof data === \"string\" &&\n\t        inputEncoding === this.encoding &&\n\t        this.string.length + data.length < MAX_SHORT_STRING\n\t      ) {\n\t        this.string += data;\n\n\t        return this;\n\t      }\n\n\t      this.hash.update(this.string, this.encoding);\n\t      this.string = undefined;\n\t    }\n\n\t    if (typeof data === \"string\") {\n\t      if (\n\t        data.length < MAX_SHORT_STRING &&\n\t        // base64 encoding is not valid since it may contain padding chars\n\t        (!inputEncoding || !inputEncoding.startsWith(\"ba\"))\n\t      ) {\n\t        this.string = data;\n\t        this.encoding = inputEncoding;\n\t      } else {\n\t        this.hash.update(data, inputEncoding);\n\t      }\n\t    } else {\n\t      this.hash.update(data);\n\t    }\n\n\t    return this;\n\t  }\n\n\t  /**\n\t   * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n\t   * @param {string=} encoding encoding of the return value\n\t   * @returns {string|Buffer} digest\n\t   */\n\t  digest(encoding) {\n\t    if (this.string !== undefined) {\n\t      this.hash.update(this.string, this.encoding);\n\t    }\n\n\t    return this.hash.digest(encoding);\n\t  }\n\t}\n\n\tBatchedHash_1 = BatchedHash;\n\treturn BatchedHash_1;\n}\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar md4_1;\nvar hasRequiredMd4;\n\nfunction requireMd4 () {\n\tif (hasRequiredMd4) return md4_1;\n\thasRequiredMd4 = 1;\n\n\tconst create = requireWasmHash();\n\n\t//#region wasm code: md4 (../../../assembly/hash/md4.asm.ts) --initialMemory 1\n\tconst md4 = new WebAssembly.Module(\n\t  Buffer.from(\n\t    // 2150 bytes\n\t    \"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\",\n\t    \"base64\"\n\t  )\n\t);\n\t//#endregion\n\n\tmd4_1 = create.bind(null, md4, [], 64, 32);\n\treturn md4_1;\n}\n\nvar BulkUpdateDecorator_1;\nvar hasRequiredBulkUpdateDecorator;\n\nfunction requireBulkUpdateDecorator () {\n\tif (hasRequiredBulkUpdateDecorator) return BulkUpdateDecorator_1;\n\thasRequiredBulkUpdateDecorator = 1;\n\tconst BULK_SIZE = 2000;\n\n\t// We are using an object instead of a Map as this will stay static during the runtime\n\t// so access to it can be optimized by v8\n\tconst digestCaches = {};\n\n\tclass BulkUpdateDecorator {\n\t  /**\n\t   * @param {Hash | function(): Hash} hashOrFactory function to create a hash\n\t   * @param {string=} hashKey key for caching\n\t   */\n\t  constructor(hashOrFactory, hashKey) {\n\t    this.hashKey = hashKey;\n\n\t    if (typeof hashOrFactory === \"function\") {\n\t      this.hashFactory = hashOrFactory;\n\t      this.hash = undefined;\n\t    } else {\n\t      this.hashFactory = undefined;\n\t      this.hash = hashOrFactory;\n\t    }\n\n\t    this.buffer = \"\";\n\t  }\n\n\t  /**\n\t   * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n\t   * @param {string|Buffer} data data\n\t   * @param {string=} inputEncoding data encoding\n\t   * @returns {this} updated hash\n\t   */\n\t  update(data, inputEncoding) {\n\t    if (\n\t      inputEncoding !== undefined ||\n\t      typeof data !== \"string\" ||\n\t      data.length > BULK_SIZE\n\t    ) {\n\t      if (this.hash === undefined) {\n\t        this.hash = this.hashFactory();\n\t      }\n\n\t      if (this.buffer.length > 0) {\n\t        this.hash.update(this.buffer);\n\t        this.buffer = \"\";\n\t      }\n\n\t      this.hash.update(data, inputEncoding);\n\t    } else {\n\t      this.buffer += data;\n\n\t      if (this.buffer.length > BULK_SIZE) {\n\t        if (this.hash === undefined) {\n\t          this.hash = this.hashFactory();\n\t        }\n\n\t        this.hash.update(this.buffer);\n\t        this.buffer = \"\";\n\t      }\n\t    }\n\n\t    return this;\n\t  }\n\n\t  /**\n\t   * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n\t   * @param {string=} encoding encoding of the return value\n\t   * @returns {string|Buffer} digest\n\t   */\n\t  digest(encoding) {\n\t    let digestCache;\n\n\t    const buffer = this.buffer;\n\n\t    if (this.hash === undefined) {\n\t      // short data for hash, we can use caching\n\t      const cacheKey = `${this.hashKey}-${encoding}`;\n\n\t      digestCache = digestCaches[cacheKey];\n\n\t      if (digestCache === undefined) {\n\t        digestCache = digestCaches[cacheKey] = new Map();\n\t      }\n\n\t      const cacheEntry = digestCache.get(buffer);\n\n\t      if (cacheEntry !== undefined) {\n\t        return cacheEntry;\n\t      }\n\n\t      this.hash = this.hashFactory();\n\t    }\n\n\t    if (buffer.length > 0) {\n\t      this.hash.update(buffer);\n\t    }\n\n\t    const digestResult = this.hash.digest(encoding);\n\n\t    if (digestCache !== undefined) {\n\t      digestCache.set(buffer, digestResult);\n\t    }\n\n\t    return digestResult;\n\t  }\n\t}\n\n\tBulkUpdateDecorator_1 = BulkUpdateDecorator;\n\treturn BulkUpdateDecorator_1;\n}\n\nconst baseEncodeTables = {\n  26: \"abcdefghijklmnopqrstuvwxyz\",\n  32: \"123456789abcdefghjkmnpqrstuvwxyz\", // no 0lio\n  36: \"0123456789abcdefghijklmnopqrstuvwxyz\",\n  49: \"abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\", // no lIO\n  52: \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n  58: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\", // no 0lIO\n  62: \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n  64: \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_\",\n};\n\n/**\n * @param {Uint32Array} uint32Array Treated as a long base-0x100000000 number, little endian\n * @param {number} divisor The divisor\n * @return {number} Modulo (remainder) of the division\n */\nfunction divmod32(uint32Array, divisor) {\n  let carry = 0;\n  for (let i = uint32Array.length - 1; i >= 0; i--) {\n    const value = carry * 0x100000000 + uint32Array[i];\n    carry = value % divisor;\n    uint32Array[i] = Math.floor(value / divisor);\n  }\n  return carry;\n}\n\nfunction encodeBufferToBase(buffer, base, length) {\n  const encodeTable = baseEncodeTables[base];\n\n  if (!encodeTable) {\n    throw new Error(\"Unknown encoding base\" + base);\n  }\n\n  // Input bits are only enough to generate this many characters\n  const limit = Math.ceil((buffer.length * 8) / Math.log2(base));\n  length = Math.min(length, limit);\n\n  // Most of the crypto digests (if not all) has length a multiple of 4 bytes.\n  // Fewer numbers in the array means faster math.\n  const uint32Array = new Uint32Array(Math.ceil(buffer.length / 4));\n\n  // Make sure the input buffer data is copied and is not mutated by reference.\n  // divmod32() would corrupt the BulkUpdateDecorator cache otherwise.\n  buffer.copy(Buffer.from(uint32Array.buffer));\n\n  let output = \"\";\n\n  for (let i = 0; i < length; i++) {\n    output = encodeTable[divmod32(uint32Array, base)] + output;\n  }\n\n  return output;\n}\n\nlet crypto = undefined;\nlet createXXHash64 = undefined;\nlet createMd4 = undefined;\nlet BatchedHash = undefined;\nlet BulkUpdateDecorator = undefined;\n\nfunction getHashDigest$1(buffer, algorithm, digestType, maxLength) {\n  algorithm = algorithm || \"xxhash64\";\n  maxLength = maxLength || 9999;\n\n  let hash;\n\n  if (algorithm === \"xxhash64\") {\n    if (createXXHash64 === undefined) {\n      createXXHash64 = requireXxhash64();\n\n      if (BatchedHash === undefined) {\n        BatchedHash = requireBatchedHash();\n      }\n    }\n\n    hash = new BatchedHash(createXXHash64());\n  } else if (algorithm === \"md4\") {\n    if (createMd4 === undefined) {\n      createMd4 = requireMd4();\n\n      if (BatchedHash === undefined) {\n        BatchedHash = requireBatchedHash();\n      }\n    }\n\n    hash = new BatchedHash(createMd4());\n  } else if (algorithm === \"native-md4\") {\n    if (typeof crypto === \"undefined\") {\n      crypto = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'crypto'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n\n      if (BulkUpdateDecorator === undefined) {\n        BulkUpdateDecorator = requireBulkUpdateDecorator();\n      }\n    }\n\n    hash = new BulkUpdateDecorator(() => crypto.createHash(\"md4\"), \"md4\");\n  } else {\n    if (typeof crypto === \"undefined\") {\n      crypto = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'crypto'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n\n      if (BulkUpdateDecorator === undefined) {\n        BulkUpdateDecorator = requireBulkUpdateDecorator();\n      }\n    }\n\n    hash = new BulkUpdateDecorator(\n      () => crypto.createHash(algorithm),\n      algorithm\n    );\n  }\n\n  hash.update(buffer);\n\n  if (\n    digestType === \"base26\" ||\n    digestType === \"base32\" ||\n    digestType === \"base36\" ||\n    digestType === \"base49\" ||\n    digestType === \"base52\" ||\n    digestType === \"base58\" ||\n    digestType === \"base62\"\n  ) {\n    return encodeBufferToBase(hash.digest(), digestType.substr(4), maxLength);\n  } else {\n    return hash.digest(digestType || \"hex\").substr(0, maxLength);\n  }\n}\n\nvar getHashDigest_1 = getHashDigest$1;\n\nconst path$1 = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nconst getHashDigest = getHashDigest_1;\n\nfunction interpolateName$1(loaderContext, name, options = {}) {\n  let filename;\n\n  const hasQuery =\n    loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1;\n\n  if (typeof name === \"function\") {\n    filename = name(\n      loaderContext.resourcePath,\n      hasQuery ? loaderContext.resourceQuery : undefined\n    );\n  } else {\n    filename = name || \"[hash].[ext]\";\n  }\n\n  const context = options.context;\n  const content = options.content;\n  const regExp = options.regExp;\n\n  let ext = \"bin\";\n  let basename = \"file\";\n  let directory = \"\";\n  let folder = \"\";\n  let query = \"\";\n\n  if (loaderContext.resourcePath) {\n    const parsed = path$1.parse(loaderContext.resourcePath);\n    let resourcePath = loaderContext.resourcePath;\n\n    if (parsed.ext) {\n      ext = parsed.ext.substr(1);\n    }\n\n    if (parsed.dir) {\n      basename = parsed.name;\n      resourcePath = parsed.dir + path$1.sep;\n    }\n\n    if (typeof context !== \"undefined\") {\n      directory = path$1\n        .relative(context, resourcePath + \"_\")\n        .replace(/\\\\/g, \"/\")\n        .replace(/\\.\\.(\\/)?/g, \"_$1\");\n      directory = directory.substr(0, directory.length - 1);\n    } else {\n      directory = resourcePath.replace(/\\\\/g, \"/\").replace(/\\.\\.(\\/)?/g, \"_$1\");\n    }\n\n    if (directory.length === 1) {\n      directory = \"\";\n    } else if (directory.length > 1) {\n      folder = path$1.basename(directory);\n    }\n  }\n\n  if (loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1) {\n    query = loaderContext.resourceQuery;\n\n    const hashIdx = query.indexOf(\"#\");\n\n    if (hashIdx >= 0) {\n      query = query.substr(0, hashIdx);\n    }\n  }\n\n  let url = filename;\n\n  if (content) {\n    // Match hash template\n    url = url\n      // `hash` and `contenthash` are same in `loader-utils` context\n      // let's keep `hash` for backward compatibility\n      .replace(\n        /\\[(?:([^:\\]]+):)?(?:hash|contenthash)(?::([a-z]+\\d*))?(?::(\\d+))?\\]/gi,\n        (all, hashType, digestType, maxLength) =>\n          getHashDigest(content, hashType, digestType, parseInt(maxLength, 10))\n      );\n  }\n\n  url = url\n    .replace(/\\[ext\\]/gi, () => ext)\n    .replace(/\\[name\\]/gi, () => basename)\n    .replace(/\\[path\\]/gi, () => directory)\n    .replace(/\\[folder\\]/gi, () => folder)\n    .replace(/\\[query\\]/gi, () => query);\n\n  if (regExp && loaderContext.resourcePath) {\n    const match = loaderContext.resourcePath.match(new RegExp(regExp));\n\n    match &&\n      match.forEach((matched, i) => {\n        url = url.replace(new RegExp(\"\\\\[\" + i + \"\\\\]\", \"ig\"), matched);\n      });\n  }\n\n  if (\n    typeof loaderContext.options === \"object\" &&\n    typeof loaderContext.options.customInterpolateName === \"function\"\n  ) {\n    url = loaderContext.options.customInterpolateName.call(\n      loaderContext,\n      url,\n      name,\n      options\n    );\n  }\n\n  return url;\n}\n\nvar interpolateName_1 = interpolateName$1;\n\nvar interpolateName = interpolateName_1;\nvar path = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n\n/**\n * @param  {string} pattern\n * @param  {object} options\n * @param  {string} options.context\n * @param  {string} options.hashPrefix\n * @return {function}\n */\nvar genericNames = function createGenerator(pattern, options) {\n  options = options || {};\n  var context =\n    options && typeof options.context === \"string\"\n      ? options.context\n      : process.cwd();\n  var hashPrefix =\n    options && typeof options.hashPrefix === \"string\" ? options.hashPrefix : \"\";\n\n  /**\n   * @param  {string} localName Usually a class name\n   * @param  {string} filepath  Absolute path\n   * @return {string}\n   */\n  return function generate(localName, filepath) {\n    var name = pattern.replace(/\\[local\\]/gi, localName);\n    var loaderContext = {\n      resourcePath: filepath,\n    };\n\n    var loaderOptions = {\n      content:\n        hashPrefix +\n        path.relative(context, filepath).replace(/\\\\/g, \"/\") +\n        \"\\x00\" +\n        localName,\n      context: context,\n    };\n\n    var genericName = interpolateName(loaderContext, name, loaderOptions);\n    return genericName\n      .replace(new RegExp(\"[^a-zA-Z0-9\\\\-_\\u00A0-\\uFFFF]\", \"g\"), \"-\")\n      .replace(/^((-?[0-9])|--)/, \"_$1\");\n  };\n};\n\nvar unquote$1 = {};\n\nObject.defineProperty(unquote$1, \"__esModule\", {\n  value: true\n});\nunquote$1.default = unquote;\n// copied from https://github.com/lakenen/node-unquote\nvar reg = /['\"]/;\n\nfunction unquote(str) {\n  if (!str) {\n    return \"\";\n  }\n\n  if (reg.test(str.charAt(0))) {\n    str = str.substr(1);\n  }\n\n  if (reg.test(str.charAt(str.length - 1))) {\n    str = str.substr(0, str.length - 1);\n  }\n\n  return str;\n}\n\nvar parser$1 = {};\n\nvar lib = {};\n\nObject.defineProperty(lib, \"__esModule\", {\n  value: true\n});\nlib.replaceAll = replaceAll;\nvar matchConstName = /[$#]?[\\w-\\.]+/g;\n\nfunction replaceAll(replacements, text) {\n  var matches = void 0;\n  while (matches = matchConstName.exec(text)) {\n    var replacement = replacements[matches[0]];\n    if (replacement) {\n      text = text.slice(0, matches.index) + replacement + text.slice(matchConstName.lastIndex);\n      matchConstName.lastIndex -= matches[0].length - replacement.length;\n    }\n  }\n  return text;\n}\n\nlib.default = function (css, translations) {\n  css.walkDecls(function (decl) {\n    return decl.value = replaceAll(translations, decl.value);\n  });\n  css.walkAtRules('media', function (atRule) {\n    return atRule.params = replaceAll(translations, atRule.params);\n  });\n};\n\nObject.defineProperty(parser$1, \"__esModule\", {\n  value: true\n});\nparser$1.default = void 0;\n\nvar _icssReplaceSymbols = _interopRequireDefault$6(lib);\n\nfunction _interopRequireDefault$6(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Copied from https://github.com/css-modules/css-modules-loader-core\nconst importRegexp = /^:import\\((.+)\\)$/;\n\nclass Parser {\n  constructor(pathFetcher, trace) {\n    this.pathFetcher = pathFetcher;\n    this.plugin = this.plugin.bind(this);\n    this.exportTokens = {};\n    this.translations = {};\n    this.trace = trace;\n  }\n\n  plugin() {\n    const parser = this;\n    return {\n      postcssPlugin: \"css-modules-parser\",\n\n      OnceExit(css) {\n        return Promise.all(parser.fetchAllImports(css)).then(() => parser.linkImportedSymbols(css)).then(() => parser.extractExports(css));\n      }\n\n    };\n  }\n\n  fetchAllImports(css) {\n    let imports = [];\n    css.each(node => {\n      if (node.type == \"rule\" && node.selector.match(importRegexp)) {\n        imports.push(this.fetchImport(node, css.source.input.from, imports.length));\n      }\n    });\n    return imports;\n  }\n\n  linkImportedSymbols(css) {\n    (0, _icssReplaceSymbols.default)(css, this.translations);\n  }\n\n  extractExports(css) {\n    css.each(node => {\n      if (node.type == \"rule\" && node.selector == \":export\") this.handleExport(node);\n    });\n  }\n\n  handleExport(exportNode) {\n    exportNode.each(decl => {\n      if (decl.type == \"decl\") {\n        Object.keys(this.translations).forEach(translation => {\n          decl.value = decl.value.replace(translation, this.translations[translation]);\n        });\n        this.exportTokens[decl.prop] = decl.value;\n      }\n    });\n    exportNode.remove();\n  }\n\n  fetchImport(importNode, relativeTo, depNr) {\n    let file = importNode.selector.match(importRegexp)[1],\n        depTrace = this.trace + String.fromCharCode(depNr);\n    return this.pathFetcher(file, relativeTo, depTrace).then(exports => {\n      importNode.each(decl => {\n        if (decl.type == \"decl\") {\n          this.translations[decl.prop] = exports[decl.value];\n        }\n      });\n      importNode.remove();\n    }, err => console.log(err));\n  }\n\n}\n\nparser$1.default = Parser;\n\nvar loader = {};\n\nObject.defineProperty(loader, \"__esModule\", {\n  value: true\n});\nloader.default = void 0;\n\nvar _postcss$1 = _interopRequireDefault$5(postcss__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\nvar _fs$1 = _interopRequireDefault$5(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar _path = _interopRequireDefault$5(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar _parser$1 = _interopRequireDefault$5(parser$1);\n\nfunction _interopRequireDefault$5(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Copied from https://github.com/css-modules/css-modules-loader-core\nclass Core {\n  constructor(plugins) {\n    this.plugins = plugins || Core.defaultPlugins;\n  }\n\n  load(sourceString, sourcePath, trace, pathFetcher) {\n    let parser = new _parser$1.default(pathFetcher, trace);\n    return (0, _postcss$1.default)(this.plugins.concat([parser.plugin()])).process(sourceString, {\n      from: sourcePath\n    }).then(result => {\n      return {\n        injectableSource: result.css,\n        exportTokens: parser.exportTokens\n      };\n    });\n  }\n\n} // Sorts dependencies in the following way:\n// AAA comes before AA and A\n// AB comes after AA and before A\n// All Bs come after all As\n// This ensures that the files are always returned in the following order:\n// - In the order they were required, except\n// - After all their dependencies\n\n\nconst traceKeySorter = (a, b) => {\n  if (a.length < b.length) {\n    return a < b.substring(0, a.length) ? -1 : 1;\n  } else if (a.length > b.length) {\n    return a.substring(0, b.length) <= b ? -1 : 1;\n  } else {\n    return a < b ? -1 : 1;\n  }\n};\n\nclass FileSystemLoader {\n  constructor(root, plugins) {\n    if (root === '/' && process.platform === \"win32\") {\n      const cwdDrive = process.cwd().slice(0, 3);\n\n      if (!/^[A-Z]:\\\\$/.test(cwdDrive)) {\n        throw new Error(`Failed to obtain root from \"${process.cwd()}\".`);\n      }\n\n      root = cwdDrive;\n    }\n\n    this.root = root;\n    this.sources = {};\n    this.traces = {};\n    this.importNr = 0;\n    this.core = new Core(plugins);\n    this.tokensByFile = {};\n  }\n\n  fetch(_newPath, relativeTo, _trace) {\n    let newPath = _newPath.replace(/^[\"']|[\"']$/g, \"\"),\n        trace = _trace || String.fromCharCode(this.importNr++);\n\n    return new Promise((resolve, reject) => {\n      let relativeDir = _path.default.dirname(relativeTo),\n          rootRelativePath = _path.default.resolve(relativeDir, newPath),\n          fileRelativePath = _path.default.resolve(_path.default.resolve(this.root, relativeDir), newPath); // if the path is not relative or absolute, try to resolve it in node_modules\n\n\n      if (newPath[0] !== \".\" && !_path.default.isAbsolute(newPath)) {\n        try {\n          fileRelativePath = require.resolve(newPath);\n        } catch (e) {// noop\n        }\n      }\n\n      const tokens = this.tokensByFile[fileRelativePath];\n\n      if (tokens) {\n        return resolve(tokens);\n      }\n\n      _fs$1.default.readFile(fileRelativePath, \"utf-8\", (err, source) => {\n        if (err) reject(err);\n        this.core.load(source, rootRelativePath, trace, this.fetch.bind(this)).then(({\n          injectableSource,\n          exportTokens\n        }) => {\n          this.sources[fileRelativePath] = injectableSource;\n          this.traces[trace] = fileRelativePath;\n          this.tokensByFile[fileRelativePath] = exportTokens;\n          resolve(exportTokens);\n        }, reject);\n      });\n    });\n  }\n\n  get finalSource() {\n    const traces = this.traces;\n    const sources = this.sources;\n    let written = new Set();\n    return Object.keys(traces).sort(traceKeySorter).map(key => {\n      const filename = traces[key];\n\n      if (written.has(filename)) {\n        return null;\n      }\n\n      written.add(filename);\n      return sources[filename];\n    }).join(\"\");\n  }\n\n}\n\nloader.default = FileSystemLoader;\n\nvar generateScopedName$1 = {};\n\nfunction hash(str) {\n  var hash = 5381,\n      i    = str.length;\n\n  while(i) {\n    hash = (hash * 33) ^ str.charCodeAt(--i);\n  }\n\n  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n   * integers. Since we want the results to be always positive, convert the\n   * signed int to an unsigned by doing an unsigned bitshift. */\n  return hash >>> 0;\n}\n\nvar stringHash = hash;\n\nObject.defineProperty(generateScopedName$1, \"__esModule\", {\n  value: true\n});\ngenerateScopedName$1.default = generateScopedName;\n\nvar _stringHash = _interopRequireDefault$4(stringHash);\n\nfunction _interopRequireDefault$4(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction generateScopedName(name, filename, css) {\n  const i = css.indexOf(`.${name}`);\n  const lineNumber = css.substr(0, i).split(/[\\r\\n]/).length;\n  const hash = (0, _stringHash.default)(css).toString(36).substr(0, 5);\n  return `_${name}_${hash}_${lineNumber}`;\n}\n\nvar saveJSON$1 = {};\n\nObject.defineProperty(saveJSON$1, \"__esModule\", {\n  value: true\n});\nsaveJSON$1.default = saveJSON;\n\nvar _fs = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n\nfunction saveJSON(cssFile, json) {\n  return new Promise((resolve, reject) => {\n    (0, _fs.writeFile)(`${cssFile}.json`, JSON.stringify(json), e => e ? reject(e) : resolve(json));\n  });\n}\n\nvar behaviours$1 = {};\n\nvar src$4 = {exports: {}};\n\nvar dist = {exports: {}};\n\nvar processor = {exports: {}};\n\nvar parser = {exports: {}};\n\nvar root$1 = {exports: {}};\n\nvar container = {exports: {}};\n\nvar node$1 = {exports: {}};\n\nvar util = {};\n\nvar unesc = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = unesc;\n\n\t// Many thanks for this post which made this migration much easier.\n\t// https://mathiasbynens.be/notes/css-escapes\n\n\t/**\n\t * \n\t * @param {string} str \n\t * @returns {[string, number]|undefined}\n\t */\n\tfunction gobbleHex(str) {\n\t  var lower = str.toLowerCase();\n\t  var hex = '';\n\t  var spaceTerminated = false;\n\n\t  for (var i = 0; i < 6 && lower[i] !== undefined; i++) {\n\t    var code = lower.charCodeAt(i); // check to see if we are dealing with a valid hex char [a-f|0-9]\n\n\t    var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57; // https://drafts.csswg.org/css-syntax/#consume-escaped-code-point\n\n\t    spaceTerminated = code === 32;\n\n\t    if (!valid) {\n\t      break;\n\t    }\n\n\t    hex += lower[i];\n\t  }\n\n\t  if (hex.length === 0) {\n\t    return undefined;\n\t  }\n\n\t  var codePoint = parseInt(hex, 16);\n\t  var isSurrogate = codePoint >= 0xD800 && codePoint <= 0xDFFF; // Add special case for\n\t  // \"If this number is zero, or is for a surrogate, or is greater than the maximum allowed code point\"\n\t  // https://drafts.csswg.org/css-syntax/#maximum-allowed-code-point\n\n\t  if (isSurrogate || codePoint === 0x0000 || codePoint > 0x10FFFF) {\n\t    return [\"\\uFFFD\", hex.length + (spaceTerminated ? 1 : 0)];\n\t  }\n\n\t  return [String.fromCodePoint(codePoint), hex.length + (spaceTerminated ? 1 : 0)];\n\t}\n\n\tvar CONTAINS_ESCAPE = /\\\\/;\n\n\tfunction unesc(str) {\n\t  var needToProcess = CONTAINS_ESCAPE.test(str);\n\n\t  if (!needToProcess) {\n\t    return str;\n\t  }\n\n\t  var ret = \"\";\n\n\t  for (var i = 0; i < str.length; i++) {\n\t    if (str[i] === \"\\\\\") {\n\t      var gobbled = gobbleHex(str.slice(i + 1, i + 7));\n\n\t      if (gobbled !== undefined) {\n\t        ret += gobbled[0];\n\t        i += gobbled[1];\n\t        continue;\n\t      } // Retain a pair of \\\\ if double escaped `\\\\\\\\`\n\t      // https://github.com/postcss/postcss-selector-parser/commit/268c9a7656fb53f543dc620aa5b73a30ec3ff20e\n\n\n\t      if (str[i + 1] === \"\\\\\") {\n\t        ret += \"\\\\\";\n\t        i++;\n\t        continue;\n\t      } // if \\\\ is at the end of the string retain it\n\t      // https://github.com/postcss/postcss-selector-parser/commit/01a6b346e3612ce1ab20219acc26abdc259ccefb\n\n\n\t      if (str.length === i + 1) {\n\t        ret += str[i];\n\t      }\n\n\t      continue;\n\t    }\n\n\t    ret += str[i];\n\t  }\n\n\t  return ret;\n\t}\n\n\tmodule.exports = exports.default;\n} (unesc, unesc.exports));\n\nvar getProp = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = getProp;\n\n\tfunction getProp(obj) {\n\t  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t    props[_key - 1] = arguments[_key];\n\t  }\n\n\t  while (props.length > 0) {\n\t    var prop = props.shift();\n\n\t    if (!obj[prop]) {\n\t      return undefined;\n\t    }\n\n\t    obj = obj[prop];\n\t  }\n\n\t  return obj;\n\t}\n\n\tmodule.exports = exports.default;\n} (getProp, getProp.exports));\n\nvar ensureObject = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = ensureObject;\n\n\tfunction ensureObject(obj) {\n\t  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t    props[_key - 1] = arguments[_key];\n\t  }\n\n\t  while (props.length > 0) {\n\t    var prop = props.shift();\n\n\t    if (!obj[prop]) {\n\t      obj[prop] = {};\n\t    }\n\n\t    obj = obj[prop];\n\t  }\n\t}\n\n\tmodule.exports = exports.default;\n} (ensureObject, ensureObject.exports));\n\nvar stripComments = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = stripComments;\n\n\tfunction stripComments(str) {\n\t  var s = \"\";\n\t  var commentStart = str.indexOf(\"/*\");\n\t  var lastEnd = 0;\n\n\t  while (commentStart >= 0) {\n\t    s = s + str.slice(lastEnd, commentStart);\n\t    var commentEnd = str.indexOf(\"*/\", commentStart + 2);\n\n\t    if (commentEnd < 0) {\n\t      return s;\n\t    }\n\n\t    lastEnd = commentEnd + 2;\n\t    commentStart = str.indexOf(\"/*\", lastEnd);\n\t  }\n\n\t  s = s + str.slice(lastEnd);\n\t  return s;\n\t}\n\n\tmodule.exports = exports.default;\n} (stripComments, stripComments.exports));\n\nutil.__esModule = true;\nutil.stripComments = util.ensureObject = util.getProp = util.unesc = void 0;\n\nvar _unesc = _interopRequireDefault$3(unesc.exports);\n\nutil.unesc = _unesc[\"default\"];\n\nvar _getProp = _interopRequireDefault$3(getProp.exports);\n\nutil.getProp = _getProp[\"default\"];\n\nvar _ensureObject = _interopRequireDefault$3(ensureObject.exports);\n\nutil.ensureObject = _ensureObject[\"default\"];\n\nvar _stripComments = _interopRequireDefault$3(stripComments.exports);\n\nutil.stripComments = _stripComments[\"default\"];\n\nfunction _interopRequireDefault$3(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\n\tvar _util = util;\n\n\tfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\n\tfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\tvar cloneNode = function cloneNode(obj, parent) {\n\t  if (typeof obj !== 'object' || obj === null) {\n\t    return obj;\n\t  }\n\n\t  var cloned = new obj.constructor();\n\n\t  for (var i in obj) {\n\t    if (!obj.hasOwnProperty(i)) {\n\t      continue;\n\t    }\n\n\t    var value = obj[i];\n\t    var type = typeof value;\n\n\t    if (i === 'parent' && type === 'object') {\n\t      if (parent) {\n\t        cloned[i] = parent;\n\t      }\n\t    } else if (value instanceof Array) {\n\t      cloned[i] = value.map(function (j) {\n\t        return cloneNode(j, cloned);\n\t      });\n\t    } else {\n\t      cloned[i] = cloneNode(value, cloned);\n\t    }\n\t  }\n\n\t  return cloned;\n\t};\n\n\tvar Node = /*#__PURE__*/function () {\n\t  function Node(opts) {\n\t    if (opts === void 0) {\n\t      opts = {};\n\t    }\n\n\t    Object.assign(this, opts);\n\t    this.spaces = this.spaces || {};\n\t    this.spaces.before = this.spaces.before || '';\n\t    this.spaces.after = this.spaces.after || '';\n\t  }\n\n\t  var _proto = Node.prototype;\n\n\t  _proto.remove = function remove() {\n\t    if (this.parent) {\n\t      this.parent.removeChild(this);\n\t    }\n\n\t    this.parent = undefined;\n\t    return this;\n\t  };\n\n\t  _proto.replaceWith = function replaceWith() {\n\t    if (this.parent) {\n\t      for (var index in arguments) {\n\t        this.parent.insertBefore(this, arguments[index]);\n\t      }\n\n\t      this.remove();\n\t    }\n\n\t    return this;\n\t  };\n\n\t  _proto.next = function next() {\n\t    return this.parent.at(this.parent.index(this) + 1);\n\t  };\n\n\t  _proto.prev = function prev() {\n\t    return this.parent.at(this.parent.index(this) - 1);\n\t  };\n\n\t  _proto.clone = function clone(overrides) {\n\t    if (overrides === void 0) {\n\t      overrides = {};\n\t    }\n\n\t    var cloned = cloneNode(this);\n\n\t    for (var name in overrides) {\n\t      cloned[name] = overrides[name];\n\t    }\n\n\t    return cloned;\n\t  }\n\t  /**\n\t   * Some non-standard syntax doesn't follow normal escaping rules for css.\n\t   * This allows non standard syntax to be appended to an existing property\n\t   * by specifying the escaped value. By specifying the escaped value,\n\t   * illegal characters are allowed to be directly inserted into css output.\n\t   * @param {string} name the property to set\n\t   * @param {any} value the unescaped value of the property\n\t   * @param {string} valueEscaped optional. the escaped value of the property.\n\t   */\n\t  ;\n\n\t  _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value, valueEscaped) {\n\t    if (!this.raws) {\n\t      this.raws = {};\n\t    }\n\n\t    var originalValue = this[name];\n\t    var originalEscaped = this.raws[name];\n\t    this[name] = originalValue + value; // this may trigger a setter that updates raws, so it has to be set first.\n\n\t    if (originalEscaped || valueEscaped !== value) {\n\t      this.raws[name] = (originalEscaped || originalValue) + valueEscaped;\n\t    } else {\n\t      delete this.raws[name]; // delete any escaped value that was created by the setter.\n\t    }\n\t  }\n\t  /**\n\t   * Some non-standard syntax doesn't follow normal escaping rules for css.\n\t   * This allows the escaped value to be specified directly, allowing illegal\n\t   * characters to be directly inserted into css output.\n\t   * @param {string} name the property to set\n\t   * @param {any} value the unescaped value of the property\n\t   * @param {string} valueEscaped the escaped value of the property.\n\t   */\n\t  ;\n\n\t  _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value, valueEscaped) {\n\t    if (!this.raws) {\n\t      this.raws = {};\n\t    }\n\n\t    this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.\n\n\t    this.raws[name] = valueEscaped;\n\t  }\n\t  /**\n\t   * When you want a value to passed through to CSS directly. This method\n\t   * deletes the corresponding raw value causing the stringifier to fallback\n\t   * to the unescaped value.\n\t   * @param {string} name the property to set.\n\t   * @param {any} value The value that is both escaped and unescaped.\n\t   */\n\t  ;\n\n\t  _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value) {\n\t    this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.\n\n\t    if (this.raws) {\n\t      delete this.raws[name];\n\t    }\n\t  }\n\t  /**\n\t   *\n\t   * @param {number} line The number (starting with 1)\n\t   * @param {number} column The column number (starting with 1)\n\t   */\n\t  ;\n\n\t  _proto.isAtPosition = function isAtPosition(line, column) {\n\t    if (this.source && this.source.start && this.source.end) {\n\t      if (this.source.start.line > line) {\n\t        return false;\n\t      }\n\n\t      if (this.source.end.line < line) {\n\t        return false;\n\t      }\n\n\t      if (this.source.start.line === line && this.source.start.column > column) {\n\t        return false;\n\t      }\n\n\t      if (this.source.end.line === line && this.source.end.column < column) {\n\t        return false;\n\t      }\n\n\t      return true;\n\t    }\n\n\t    return undefined;\n\t  };\n\n\t  _proto.stringifyProperty = function stringifyProperty(name) {\n\t    return this.raws && this.raws[name] || this[name];\n\t  };\n\n\t  _proto.valueToString = function valueToString() {\n\t    return String(this.stringifyProperty(\"value\"));\n\t  };\n\n\t  _proto.toString = function toString() {\n\t    return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join('');\n\t  };\n\n\t  _createClass(Node, [{\n\t    key: \"rawSpaceBefore\",\n\t    get: function get() {\n\t      var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;\n\n\t      if (rawSpace === undefined) {\n\t        rawSpace = this.spaces && this.spaces.before;\n\t      }\n\n\t      return rawSpace || \"\";\n\t    },\n\t    set: function set(raw) {\n\t      (0, _util.ensureObject)(this, \"raws\", \"spaces\");\n\t      this.raws.spaces.before = raw;\n\t    }\n\t  }, {\n\t    key: \"rawSpaceAfter\",\n\t    get: function get() {\n\t      var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;\n\n\t      if (rawSpace === undefined) {\n\t        rawSpace = this.spaces.after;\n\t      }\n\n\t      return rawSpace || \"\";\n\t    },\n\t    set: function set(raw) {\n\t      (0, _util.ensureObject)(this, \"raws\", \"spaces\");\n\t      this.raws.spaces.after = raw;\n\t    }\n\t  }]);\n\n\t  return Node;\n\t}();\n\n\texports[\"default\"] = Node;\n\tmodule.exports = exports.default;\n} (node$1, node$1.exports));\n\nvar types = {};\n\ntypes.__esModule = true;\ntypes.UNIVERSAL = types.ATTRIBUTE = types.CLASS = types.COMBINATOR = types.COMMENT = types.ID = types.NESTING = types.PSEUDO = types.ROOT = types.SELECTOR = types.STRING = types.TAG = void 0;\nvar TAG = 'tag';\ntypes.TAG = TAG;\nvar STRING = 'string';\ntypes.STRING = STRING;\nvar SELECTOR = 'selector';\ntypes.SELECTOR = SELECTOR;\nvar ROOT = 'root';\ntypes.ROOT = ROOT;\nvar PSEUDO = 'pseudo';\ntypes.PSEUDO = PSEUDO;\nvar NESTING = 'nesting';\ntypes.NESTING = NESTING;\nvar ID = 'id';\ntypes.ID = ID;\nvar COMMENT = 'comment';\ntypes.COMMENT = COMMENT;\nvar COMBINATOR = 'combinator';\ntypes.COMBINATOR = COMBINATOR;\nvar CLASS = 'class';\ntypes.CLASS = CLASS;\nvar ATTRIBUTE = 'attribute';\ntypes.ATTRIBUTE = ATTRIBUTE;\nvar UNIVERSAL = 'universal';\ntypes.UNIVERSAL = UNIVERSAL;\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\n\tvar _node = _interopRequireDefault(node$1.exports);\n\n\tvar types$1 = _interopRequireWildcard(types);\n\n\tfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n\tfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\n\tfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\n\tfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n\tfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\n\tfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\tvar Container = /*#__PURE__*/function (_Node) {\n\t  _inheritsLoose(Container, _Node);\n\n\t  function Container(opts) {\n\t    var _this;\n\n\t    _this = _Node.call(this, opts) || this;\n\n\t    if (!_this.nodes) {\n\t      _this.nodes = [];\n\t    }\n\n\t    return _this;\n\t  }\n\n\t  var _proto = Container.prototype;\n\n\t  _proto.append = function append(selector) {\n\t    selector.parent = this;\n\t    this.nodes.push(selector);\n\t    return this;\n\t  };\n\n\t  _proto.prepend = function prepend(selector) {\n\t    selector.parent = this;\n\t    this.nodes.unshift(selector);\n\t    return this;\n\t  };\n\n\t  _proto.at = function at(index) {\n\t    return this.nodes[index];\n\t  };\n\n\t  _proto.index = function index(child) {\n\t    if (typeof child === 'number') {\n\t      return child;\n\t    }\n\n\t    return this.nodes.indexOf(child);\n\t  };\n\n\t  _proto.removeChild = function removeChild(child) {\n\t    child = this.index(child);\n\t    this.at(child).parent = undefined;\n\t    this.nodes.splice(child, 1);\n\t    var index;\n\n\t    for (var id in this.indexes) {\n\t      index = this.indexes[id];\n\n\t      if (index >= child) {\n\t        this.indexes[id] = index - 1;\n\t      }\n\t    }\n\n\t    return this;\n\t  };\n\n\t  _proto.removeAll = function removeAll() {\n\t    for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done;) {\n\t      var node = _step.value;\n\t      node.parent = undefined;\n\t    }\n\n\t    this.nodes = [];\n\t    return this;\n\t  };\n\n\t  _proto.empty = function empty() {\n\t    return this.removeAll();\n\t  };\n\n\t  _proto.insertAfter = function insertAfter(oldNode, newNode) {\n\t    newNode.parent = this;\n\t    var oldIndex = this.index(oldNode);\n\t    this.nodes.splice(oldIndex + 1, 0, newNode);\n\t    newNode.parent = this;\n\t    var index;\n\n\t    for (var id in this.indexes) {\n\t      index = this.indexes[id];\n\n\t      if (oldIndex <= index) {\n\t        this.indexes[id] = index + 1;\n\t      }\n\t    }\n\n\t    return this;\n\t  };\n\n\t  _proto.insertBefore = function insertBefore(oldNode, newNode) {\n\t    newNode.parent = this;\n\t    var oldIndex = this.index(oldNode);\n\t    this.nodes.splice(oldIndex, 0, newNode);\n\t    newNode.parent = this;\n\t    var index;\n\n\t    for (var id in this.indexes) {\n\t      index = this.indexes[id];\n\n\t      if (index <= oldIndex) {\n\t        this.indexes[id] = index + 1;\n\t      }\n\t    }\n\n\t    return this;\n\t  };\n\n\t  _proto._findChildAtPosition = function _findChildAtPosition(line, col) {\n\t    var found = undefined;\n\t    this.each(function (node) {\n\t      if (node.atPosition) {\n\t        var foundChild = node.atPosition(line, col);\n\n\t        if (foundChild) {\n\t          found = foundChild;\n\t          return false;\n\t        }\n\t      } else if (node.isAtPosition(line, col)) {\n\t        found = node;\n\t        return false;\n\t      }\n\t    });\n\t    return found;\n\t  }\n\t  /**\n\t   * Return the most specific node at the line and column number given.\n\t   * The source location is based on the original parsed location, locations aren't\n\t   * updated as selector nodes are mutated.\n\t   * \n\t   * Note that this location is relative to the location of the first character\n\t   * of the selector, and not the location of the selector in the overall document\n\t   * when used in conjunction with postcss.\n\t   *\n\t   * If not found, returns undefined.\n\t   * @param {number} line The line number of the node to find. (1-based index)\n\t   * @param {number} col  The column number of the node to find. (1-based index)\n\t   */\n\t  ;\n\n\t  _proto.atPosition = function atPosition(line, col) {\n\t    if (this.isAtPosition(line, col)) {\n\t      return this._findChildAtPosition(line, col) || this;\n\t    } else {\n\t      return undefined;\n\t    }\n\t  };\n\n\t  _proto._inferEndPosition = function _inferEndPosition() {\n\t    if (this.last && this.last.source && this.last.source.end) {\n\t      this.source = this.source || {};\n\t      this.source.end = this.source.end || {};\n\t      Object.assign(this.source.end, this.last.source.end);\n\t    }\n\t  };\n\n\t  _proto.each = function each(callback) {\n\t    if (!this.lastEach) {\n\t      this.lastEach = 0;\n\t    }\n\n\t    if (!this.indexes) {\n\t      this.indexes = {};\n\t    }\n\n\t    this.lastEach++;\n\t    var id = this.lastEach;\n\t    this.indexes[id] = 0;\n\n\t    if (!this.length) {\n\t      return undefined;\n\t    }\n\n\t    var index, result;\n\n\t    while (this.indexes[id] < this.length) {\n\t      index = this.indexes[id];\n\t      result = callback(this.at(index), index);\n\n\t      if (result === false) {\n\t        break;\n\t      }\n\n\t      this.indexes[id] += 1;\n\t    }\n\n\t    delete this.indexes[id];\n\n\t    if (result === false) {\n\t      return false;\n\t    }\n\t  };\n\n\t  _proto.walk = function walk(callback) {\n\t    return this.each(function (node, i) {\n\t      var result = callback(node, i);\n\n\t      if (result !== false && node.length) {\n\t        result = node.walk(callback);\n\t      }\n\n\t      if (result === false) {\n\t        return false;\n\t      }\n\t    });\n\t  };\n\n\t  _proto.walkAttributes = function walkAttributes(callback) {\n\t    var _this2 = this;\n\n\t    return this.walk(function (selector) {\n\t      if (selector.type === types$1.ATTRIBUTE) {\n\t        return callback.call(_this2, selector);\n\t      }\n\t    });\n\t  };\n\n\t  _proto.walkClasses = function walkClasses(callback) {\n\t    var _this3 = this;\n\n\t    return this.walk(function (selector) {\n\t      if (selector.type === types$1.CLASS) {\n\t        return callback.call(_this3, selector);\n\t      }\n\t    });\n\t  };\n\n\t  _proto.walkCombinators = function walkCombinators(callback) {\n\t    var _this4 = this;\n\n\t    return this.walk(function (selector) {\n\t      if (selector.type === types$1.COMBINATOR) {\n\t        return callback.call(_this4, selector);\n\t      }\n\t    });\n\t  };\n\n\t  _proto.walkComments = function walkComments(callback) {\n\t    var _this5 = this;\n\n\t    return this.walk(function (selector) {\n\t      if (selector.type === types$1.COMMENT) {\n\t        return callback.call(_this5, selector);\n\t      }\n\t    });\n\t  };\n\n\t  _proto.walkIds = function walkIds(callback) {\n\t    var _this6 = this;\n\n\t    return this.walk(function (selector) {\n\t      if (selector.type === types$1.ID) {\n\t        return callback.call(_this6, selector);\n\t      }\n\t    });\n\t  };\n\n\t  _proto.walkNesting = function walkNesting(callback) {\n\t    var _this7 = this;\n\n\t    return this.walk(function (selector) {\n\t      if (selector.type === types$1.NESTING) {\n\t        return callback.call(_this7, selector);\n\t      }\n\t    });\n\t  };\n\n\t  _proto.walkPseudos = function walkPseudos(callback) {\n\t    var _this8 = this;\n\n\t    return this.walk(function (selector) {\n\t      if (selector.type === types$1.PSEUDO) {\n\t        return callback.call(_this8, selector);\n\t      }\n\t    });\n\t  };\n\n\t  _proto.walkTags = function walkTags(callback) {\n\t    var _this9 = this;\n\n\t    return this.walk(function (selector) {\n\t      if (selector.type === types$1.TAG) {\n\t        return callback.call(_this9, selector);\n\t      }\n\t    });\n\t  };\n\n\t  _proto.walkUniversals = function walkUniversals(callback) {\n\t    var _this10 = this;\n\n\t    return this.walk(function (selector) {\n\t      if (selector.type === types$1.UNIVERSAL) {\n\t        return callback.call(_this10, selector);\n\t      }\n\t    });\n\t  };\n\n\t  _proto.split = function split(callback) {\n\t    var _this11 = this;\n\n\t    var current = [];\n\t    return this.reduce(function (memo, node, index) {\n\t      var split = callback.call(_this11, node);\n\t      current.push(node);\n\n\t      if (split) {\n\t        memo.push(current);\n\t        current = [];\n\t      } else if (index === _this11.length - 1) {\n\t        memo.push(current);\n\t      }\n\n\t      return memo;\n\t    }, []);\n\t  };\n\n\t  _proto.map = function map(callback) {\n\t    return this.nodes.map(callback);\n\t  };\n\n\t  _proto.reduce = function reduce(callback, memo) {\n\t    return this.nodes.reduce(callback, memo);\n\t  };\n\n\t  _proto.every = function every(callback) {\n\t    return this.nodes.every(callback);\n\t  };\n\n\t  _proto.some = function some(callback) {\n\t    return this.nodes.some(callback);\n\t  };\n\n\t  _proto.filter = function filter(callback) {\n\t    return this.nodes.filter(callback);\n\t  };\n\n\t  _proto.sort = function sort(callback) {\n\t    return this.nodes.sort(callback);\n\t  };\n\n\t  _proto.toString = function toString() {\n\t    return this.map(String).join('');\n\t  };\n\n\t  _createClass(Container, [{\n\t    key: \"first\",\n\t    get: function get() {\n\t      return this.at(0);\n\t    }\n\t  }, {\n\t    key: \"last\",\n\t    get: function get() {\n\t      return this.at(this.length - 1);\n\t    }\n\t  }, {\n\t    key: \"length\",\n\t    get: function get() {\n\t      return this.nodes.length;\n\t    }\n\t  }]);\n\n\t  return Container;\n\t}(_node[\"default\"]);\n\n\texports[\"default\"] = Container;\n\tmodule.exports = exports.default;\n} (container, container.exports));\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\n\tvar _container = _interopRequireDefault(container.exports);\n\n\tvar _types = types;\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n\tfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\n\tfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\tvar Root = /*#__PURE__*/function (_Container) {\n\t  _inheritsLoose(Root, _Container);\n\n\t  function Root(opts) {\n\t    var _this;\n\n\t    _this = _Container.call(this, opts) || this;\n\t    _this.type = _types.ROOT;\n\t    return _this;\n\t  }\n\n\t  var _proto = Root.prototype;\n\n\t  _proto.toString = function toString() {\n\t    var str = this.reduce(function (memo, selector) {\n\t      memo.push(String(selector));\n\t      return memo;\n\t    }, []).join(',');\n\t    return this.trailingComma ? str + ',' : str;\n\t  };\n\n\t  _proto.error = function error(message, options) {\n\t    if (this._error) {\n\t      return this._error(message, options);\n\t    } else {\n\t      return new Error(message);\n\t    }\n\t  };\n\n\t  _createClass(Root, [{\n\t    key: \"errorGenerator\",\n\t    set: function set(handler) {\n\t      this._error = handler;\n\t    }\n\t  }]);\n\n\t  return Root;\n\t}(_container[\"default\"]);\n\n\texports[\"default\"] = Root;\n\tmodule.exports = exports.default;\n} (root$1, root$1.exports));\n\nvar selector$1 = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\n\tvar _container = _interopRequireDefault(container.exports);\n\n\tvar _types = types;\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\tvar Selector = /*#__PURE__*/function (_Container) {\n\t  _inheritsLoose(Selector, _Container);\n\n\t  function Selector(opts) {\n\t    var _this;\n\n\t    _this = _Container.call(this, opts) || this;\n\t    _this.type = _types.SELECTOR;\n\t    return _this;\n\t  }\n\n\t  return Selector;\n\t}(_container[\"default\"]);\n\n\texports[\"default\"] = Selector;\n\tmodule.exports = exports.default;\n} (selector$1, selector$1.exports));\n\nvar className$1 = {exports: {}};\n\n/*! https://mths.be/cssesc v3.0.0 by @mathias */\n\nvar object = {};\nvar hasOwnProperty$1 = object.hasOwnProperty;\nvar merge = function merge(options, defaults) {\n\tif (!options) {\n\t\treturn defaults;\n\t}\n\tvar result = {};\n\tfor (var key in defaults) {\n\t\t// `if (defaults.hasOwnProperty(key) {  }` is not needed here, since\n\t\t// only recognized option names are used.\n\t\tresult[key] = hasOwnProperty$1.call(options, key) ? options[key] : defaults[key];\n\t}\n\treturn result;\n};\n\nvar regexAnySingleEscape = /[ -,\\.\\/:-@\\[-\\^`\\{-~]/;\nvar regexSingleEscape = /[ -,\\.\\/:-@\\[\\]\\^`\\{-~]/;\nvar regexExcessiveSpaces = /(^|\\\\+)?(\\\\[A-F0-9]{1,6})\\x20(?![a-fA-F0-9\\x20])/g;\n\n// https://mathiasbynens.be/notes/css-escapes#css\nvar cssesc = function cssesc(string, options) {\n\toptions = merge(options, cssesc.options);\n\tif (options.quotes != 'single' && options.quotes != 'double') {\n\t\toptions.quotes = 'single';\n\t}\n\tvar quote = options.quotes == 'double' ? '\"' : '\\'';\n\tvar isIdentifier = options.isIdentifier;\n\n\tvar firstChar = string.charAt(0);\n\tvar output = '';\n\tvar counter = 0;\n\tvar length = string.length;\n\twhile (counter < length) {\n\t\tvar character = string.charAt(counter++);\n\t\tvar codePoint = character.charCodeAt();\n\t\tvar value = void 0;\n\t\t// If its not a printable ASCII character\n\t\tif (codePoint < 0x20 || codePoint > 0x7E) {\n\t\t\tif (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {\n\t\t\t\t// Its a high surrogate, and there is a next character.\n\t\t\t\tvar extra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) {\n\t\t\t\t\t// next character is low surrogate\n\t\t\t\t\tcodePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;\n\t\t\t\t} else {\n\t\t\t\t\t// Its an unmatched surrogate; only append this code unit, in case\n\t\t\t\t\t// the next code unit is the high surrogate of a surrogate pair.\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t} else {\n\t\t\tif (options.escapeEverything) {\n\t\t\t\tif (regexAnySingleEscape.test(character)) {\n\t\t\t\t\tvalue = '\\\\' + character;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t\t}\n\t\t\t} else if (/[\\t\\n\\f\\r\\x0B]/.test(character)) {\n\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t} else if (character == '\\\\' || !isIdentifier && (character == '\"' && quote == character || character == '\\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {\n\t\t\t\tvalue = '\\\\' + character;\n\t\t\t} else {\n\t\t\t\tvalue = character;\n\t\t\t}\n\t\t}\n\t\toutput += value;\n\t}\n\n\tif (isIdentifier) {\n\t\tif (/^-[-\\d]/.test(output)) {\n\t\t\toutput = '\\\\-' + output.slice(1);\n\t\t} else if (/\\d/.test(firstChar)) {\n\t\t\toutput = '\\\\3' + firstChar + ' ' + output.slice(1);\n\t\t}\n\t}\n\n\t// Remove spaces after `\\HEX` escapes that are not followed by a hex digit,\n\t// since theyre redundant. Note that this is only possible if the escape\n\t// sequence isnt preceded by an odd number of backslashes.\n\toutput = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {\n\t\tif ($1 && $1.length % 2) {\n\t\t\t// Its not safe to remove the space, so dont.\n\t\t\treturn $0;\n\t\t}\n\t\t// Strip the space.\n\t\treturn ($1 || '') + $2;\n\t});\n\n\tif (!isIdentifier && options.wrap) {\n\t\treturn quote + output + quote;\n\t}\n\treturn output;\n};\n\n// Expose default options (so they can be overridden globally).\ncssesc.options = {\n\t'escapeEverything': false,\n\t'isIdentifier': false,\n\t'quotes': 'single',\n\t'wrap': false\n};\n\ncssesc.version = '3.0.0';\n\nvar cssesc_1 = cssesc;\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\n\tvar _cssesc = _interopRequireDefault(cssesc_1);\n\n\tvar _util = util;\n\n\tvar _node = _interopRequireDefault(node$1.exports);\n\n\tvar _types = types;\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n\tfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\n\tfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\tvar ClassName = /*#__PURE__*/function (_Node) {\n\t  _inheritsLoose(ClassName, _Node);\n\n\t  function ClassName(opts) {\n\t    var _this;\n\n\t    _this = _Node.call(this, opts) || this;\n\t    _this.type = _types.CLASS;\n\t    _this._constructed = true;\n\t    return _this;\n\t  }\n\n\t  var _proto = ClassName.prototype;\n\n\t  _proto.valueToString = function valueToString() {\n\t    return '.' + _Node.prototype.valueToString.call(this);\n\t  };\n\n\t  _createClass(ClassName, [{\n\t    key: \"value\",\n\t    get: function get() {\n\t      return this._value;\n\t    },\n\t    set: function set(v) {\n\t      if (this._constructed) {\n\t        var escaped = (0, _cssesc[\"default\"])(v, {\n\t          isIdentifier: true\n\t        });\n\n\t        if (escaped !== v) {\n\t          (0, _util.ensureObject)(this, \"raws\");\n\t          this.raws.value = escaped;\n\t        } else if (this.raws) {\n\t          delete this.raws.value;\n\t        }\n\t      }\n\n\t      this._value = v;\n\t    }\n\t  }]);\n\n\t  return ClassName;\n\t}(_node[\"default\"]);\n\n\texports[\"default\"] = ClassName;\n\tmodule.exports = exports.default;\n} (className$1, className$1.exports));\n\nvar comment$2 = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\n\tvar _node = _interopRequireDefault(node$1.exports);\n\n\tvar _types = types;\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\tvar Comment = /*#__PURE__*/function (_Node) {\n\t  _inheritsLoose(Comment, _Node);\n\n\t  function Comment(opts) {\n\t    var _this;\n\n\t    _this = _Node.call(this, opts) || this;\n\t    _this.type = _types.COMMENT;\n\t    return _this;\n\t  }\n\n\t  return Comment;\n\t}(_node[\"default\"]);\n\n\texports[\"default\"] = Comment;\n\tmodule.exports = exports.default;\n} (comment$2, comment$2.exports));\n\nvar id$1 = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\n\tvar _node = _interopRequireDefault(node$1.exports);\n\n\tvar _types = types;\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\tvar ID = /*#__PURE__*/function (_Node) {\n\t  _inheritsLoose(ID, _Node);\n\n\t  function ID(opts) {\n\t    var _this;\n\n\t    _this = _Node.call(this, opts) || this;\n\t    _this.type = _types.ID;\n\t    return _this;\n\t  }\n\n\t  var _proto = ID.prototype;\n\n\t  _proto.valueToString = function valueToString() {\n\t    return '#' + _Node.prototype.valueToString.call(this);\n\t  };\n\n\t  return ID;\n\t}(_node[\"default\"]);\n\n\texports[\"default\"] = ID;\n\tmodule.exports = exports.default;\n} (id$1, id$1.exports));\n\nvar tag$1 = {exports: {}};\n\nvar namespace = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\n\tvar _cssesc = _interopRequireDefault(cssesc_1);\n\n\tvar _util = util;\n\n\tvar _node = _interopRequireDefault(node$1.exports);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n\tfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\n\tfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\tvar Namespace = /*#__PURE__*/function (_Node) {\n\t  _inheritsLoose(Namespace, _Node);\n\n\t  function Namespace() {\n\t    return _Node.apply(this, arguments) || this;\n\t  }\n\n\t  var _proto = Namespace.prototype;\n\n\t  _proto.qualifiedName = function qualifiedName(value) {\n\t    if (this.namespace) {\n\t      return this.namespaceString + \"|\" + value;\n\t    } else {\n\t      return value;\n\t    }\n\t  };\n\n\t  _proto.valueToString = function valueToString() {\n\t    return this.qualifiedName(_Node.prototype.valueToString.call(this));\n\t  };\n\n\t  _createClass(Namespace, [{\n\t    key: \"namespace\",\n\t    get: function get() {\n\t      return this._namespace;\n\t    },\n\t    set: function set(namespace) {\n\t      if (namespace === true || namespace === \"*\" || namespace === \"&\") {\n\t        this._namespace = namespace;\n\n\t        if (this.raws) {\n\t          delete this.raws.namespace;\n\t        }\n\n\t        return;\n\t      }\n\n\t      var escaped = (0, _cssesc[\"default\"])(namespace, {\n\t        isIdentifier: true\n\t      });\n\t      this._namespace = namespace;\n\n\t      if (escaped !== namespace) {\n\t        (0, _util.ensureObject)(this, \"raws\");\n\t        this.raws.namespace = escaped;\n\t      } else if (this.raws) {\n\t        delete this.raws.namespace;\n\t      }\n\t    }\n\t  }, {\n\t    key: \"ns\",\n\t    get: function get() {\n\t      return this._namespace;\n\t    },\n\t    set: function set(namespace) {\n\t      this.namespace = namespace;\n\t    }\n\t  }, {\n\t    key: \"namespaceString\",\n\t    get: function get() {\n\t      if (this.namespace) {\n\t        var ns = this.stringifyProperty(\"namespace\");\n\n\t        if (ns === true) {\n\t          return '';\n\t        } else {\n\t          return ns;\n\t        }\n\t      } else {\n\t        return '';\n\t      }\n\t    }\n\t  }]);\n\n\t  return Namespace;\n\t}(_node[\"default\"]);\n\n\texports[\"default\"] = Namespace;\n\tmodule.exports = exports.default;\n} (namespace, namespace.exports));\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\n\tvar _namespace = _interopRequireDefault(namespace.exports);\n\n\tvar _types = types;\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\tvar Tag = /*#__PURE__*/function (_Namespace) {\n\t  _inheritsLoose(Tag, _Namespace);\n\n\t  function Tag(opts) {\n\t    var _this;\n\n\t    _this = _Namespace.call(this, opts) || this;\n\t    _this.type = _types.TAG;\n\t    return _this;\n\t  }\n\n\t  return Tag;\n\t}(_namespace[\"default\"]);\n\n\texports[\"default\"] = Tag;\n\tmodule.exports = exports.default;\n} (tag$1, tag$1.exports));\n\nvar string$1 = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\n\tvar _node = _interopRequireDefault(node$1.exports);\n\n\tvar _types = types;\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\tvar String = /*#__PURE__*/function (_Node) {\n\t  _inheritsLoose(String, _Node);\n\n\t  function String(opts) {\n\t    var _this;\n\n\t    _this = _Node.call(this, opts) || this;\n\t    _this.type = _types.STRING;\n\t    return _this;\n\t  }\n\n\t  return String;\n\t}(_node[\"default\"]);\n\n\texports[\"default\"] = String;\n\tmodule.exports = exports.default;\n} (string$1, string$1.exports));\n\nvar pseudo$1 = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\n\tvar _container = _interopRequireDefault(container.exports);\n\n\tvar _types = types;\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\tvar Pseudo = /*#__PURE__*/function (_Container) {\n\t  _inheritsLoose(Pseudo, _Container);\n\n\t  function Pseudo(opts) {\n\t    var _this;\n\n\t    _this = _Container.call(this, opts) || this;\n\t    _this.type = _types.PSEUDO;\n\t    return _this;\n\t  }\n\n\t  var _proto = Pseudo.prototype;\n\n\t  _proto.toString = function toString() {\n\t    var params = this.length ? '(' + this.map(String).join(',') + ')' : '';\n\t    return [this.rawSpaceBefore, this.stringifyProperty(\"value\"), params, this.rawSpaceAfter].join('');\n\t  };\n\n\t  return Pseudo;\n\t}(_container[\"default\"]);\n\n\texports[\"default\"] = Pseudo;\n\tmodule.exports = exports.default;\n} (pseudo$1, pseudo$1.exports));\n\nvar attribute$1 = {};\n\n/**\n * For Node.js, simply re-export the core `util.deprecate` function.\n */\n\nvar node = util__WEBPACK_IMPORTED_MODULE_3__.deprecate;\n\n(function (exports) {\n\n\texports.__esModule = true;\n\texports.unescapeValue = unescapeValue;\n\texports[\"default\"] = void 0;\n\n\tvar _cssesc = _interopRequireDefault(cssesc_1);\n\n\tvar _unesc = _interopRequireDefault(unesc.exports);\n\n\tvar _namespace = _interopRequireDefault(namespace.exports);\n\n\tvar _types = types;\n\n\tvar _CSSESC_QUOTE_OPTIONS;\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n\tfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\n\tfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\tvar deprecate = node;\n\n\tvar WRAPPED_IN_QUOTES = /^('|\")([^]*)\\1$/;\n\tvar warnOfDeprecatedValueAssignment = deprecate(function () {}, \"Assigning an attribute a value containing characters that might need to be escaped is deprecated. \" + \"Call attribute.setValue() instead.\");\n\tvar warnOfDeprecatedQuotedAssignment = deprecate(function () {}, \"Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.\");\n\tvar warnOfDeprecatedConstructor = deprecate(function () {}, \"Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.\");\n\n\tfunction unescapeValue(value) {\n\t  var deprecatedUsage = false;\n\t  var quoteMark = null;\n\t  var unescaped = value;\n\t  var m = unescaped.match(WRAPPED_IN_QUOTES);\n\n\t  if (m) {\n\t    quoteMark = m[1];\n\t    unescaped = m[2];\n\t  }\n\n\t  unescaped = (0, _unesc[\"default\"])(unescaped);\n\n\t  if (unescaped !== value) {\n\t    deprecatedUsage = true;\n\t  }\n\n\t  return {\n\t    deprecatedUsage: deprecatedUsage,\n\t    unescaped: unescaped,\n\t    quoteMark: quoteMark\n\t  };\n\t}\n\n\tfunction handleDeprecatedContructorOpts(opts) {\n\t  if (opts.quoteMark !== undefined) {\n\t    return opts;\n\t  }\n\n\t  if (opts.value === undefined) {\n\t    return opts;\n\t  }\n\n\t  warnOfDeprecatedConstructor();\n\n\t  var _unescapeValue = unescapeValue(opts.value),\n\t      quoteMark = _unescapeValue.quoteMark,\n\t      unescaped = _unescapeValue.unescaped;\n\n\t  if (!opts.raws) {\n\t    opts.raws = {};\n\t  }\n\n\t  if (opts.raws.value === undefined) {\n\t    opts.raws.value = opts.value;\n\t  }\n\n\t  opts.value = unescaped;\n\t  opts.quoteMark = quoteMark;\n\t  return opts;\n\t}\n\n\tvar Attribute = /*#__PURE__*/function (_Namespace) {\n\t  _inheritsLoose(Attribute, _Namespace);\n\n\t  function Attribute(opts) {\n\t    var _this;\n\n\t    if (opts === void 0) {\n\t      opts = {};\n\t    }\n\n\t    _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;\n\t    _this.type = _types.ATTRIBUTE;\n\t    _this.raws = _this.raws || {};\n\t    Object.defineProperty(_this.raws, 'unquoted', {\n\t      get: deprecate(function () {\n\t        return _this.value;\n\t      }, \"attr.raws.unquoted is deprecated. Call attr.value instead.\"),\n\t      set: deprecate(function () {\n\t        return _this.value;\n\t      }, \"Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.\")\n\t    });\n\t    _this._constructed = true;\n\t    return _this;\n\t  }\n\t  /**\n\t   * Returns the Attribute's value quoted such that it would be legal to use\n\t   * in the value of a css file. The original value's quotation setting\n\t   * used for stringification is left unchanged. See `setValue(value, options)`\n\t   * if you want to control the quote settings of a new value for the attribute.\n\t   *\n\t   * You can also change the quotation used for the current value by setting quoteMark.\n\t   *\n\t   * Options:\n\t   *   * quoteMark {'\"' | \"'\" | null} - Use this value to quote the value. If this\n\t   *     option is not set, the original value for quoteMark will be used. If\n\t   *     indeterminate, a double quote is used. The legal values are:\n\t   *     * `null` - the value will be unquoted and characters will be escaped as necessary.\n\t   *     * `'` - the value will be quoted with a single quote and single quotes are escaped.\n\t   *     * `\"` - the value will be quoted with a double quote and double quotes are escaped.\n\t   *   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark\n\t   *     over the quoteMark option value.\n\t   *   * smart {boolean} - if true, will select a quote mark based on the value\n\t   *     and the other options specified here. See the `smartQuoteMark()`\n\t   *     method.\n\t   **/\n\n\n\t  var _proto = Attribute.prototype;\n\n\t  _proto.getQuotedValue = function getQuotedValue(options) {\n\t    if (options === void 0) {\n\t      options = {};\n\t    }\n\n\t    var quoteMark = this._determineQuoteMark(options);\n\n\t    var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];\n\t    var escaped = (0, _cssesc[\"default\"])(this._value, cssescopts);\n\t    return escaped;\n\t  };\n\n\t  _proto._determineQuoteMark = function _determineQuoteMark(options) {\n\t    return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);\n\t  }\n\t  /**\n\t   * Set the unescaped value with the specified quotation options. The value\n\t   * provided must not include any wrapping quote marks -- those quotes will\n\t   * be interpreted as part of the value and escaped accordingly.\n\t   */\n\t  ;\n\n\t  _proto.setValue = function setValue(value, options) {\n\t    if (options === void 0) {\n\t      options = {};\n\t    }\n\n\t    this._value = value;\n\t    this._quoteMark = this._determineQuoteMark(options);\n\n\t    this._syncRawValue();\n\t  }\n\t  /**\n\t   * Intelligently select a quoteMark value based on the value's contents. If\n\t   * the value is a legal CSS ident, it will not be quoted. Otherwise a quote\n\t   * mark will be picked that minimizes the number of escapes.\n\t   *\n\t   * If there's no clear winner, the quote mark from these options is used,\n\t   * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is\n\t   * true). If the quoteMark is unspecified, a double quote is used.\n\t   *\n\t   * @param options This takes the quoteMark and preferCurrentQuoteMark options\n\t   * from the quoteValue method.\n\t   */\n\t  ;\n\n\t  _proto.smartQuoteMark = function smartQuoteMark(options) {\n\t    var v = this.value;\n\t    var numSingleQuotes = v.replace(/[^']/g, '').length;\n\t    var numDoubleQuotes = v.replace(/[^\"]/g, '').length;\n\n\t    if (numSingleQuotes + numDoubleQuotes === 0) {\n\t      var escaped = (0, _cssesc[\"default\"])(v, {\n\t        isIdentifier: true\n\t      });\n\n\t      if (escaped === v) {\n\t        return Attribute.NO_QUOTE;\n\t      } else {\n\t        var pref = this.preferredQuoteMark(options);\n\n\t        if (pref === Attribute.NO_QUOTE) {\n\t          // pick a quote mark that isn't none and see if it's smaller\n\t          var quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE;\n\t          var opts = CSSESC_QUOTE_OPTIONS[quote];\n\t          var quoteValue = (0, _cssesc[\"default\"])(v, opts);\n\n\t          if (quoteValue.length < escaped.length) {\n\t            return quote;\n\t          }\n\t        }\n\n\t        return pref;\n\t      }\n\t    } else if (numDoubleQuotes === numSingleQuotes) {\n\t      return this.preferredQuoteMark(options);\n\t    } else if (numDoubleQuotes < numSingleQuotes) {\n\t      return Attribute.DOUBLE_QUOTE;\n\t    } else {\n\t      return Attribute.SINGLE_QUOTE;\n\t    }\n\t  }\n\t  /**\n\t   * Selects the preferred quote mark based on the options and the current quote mark value.\n\t   * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`\n\t   * instead.\n\t   */\n\t  ;\n\n\t  _proto.preferredQuoteMark = function preferredQuoteMark(options) {\n\t    var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;\n\n\t    if (quoteMark === undefined) {\n\t      quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;\n\t    }\n\n\t    if (quoteMark === undefined) {\n\t      quoteMark = Attribute.DOUBLE_QUOTE;\n\t    }\n\n\t    return quoteMark;\n\t  };\n\n\t  _proto._syncRawValue = function _syncRawValue() {\n\t    var rawValue = (0, _cssesc[\"default\"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);\n\n\t    if (rawValue === this._value) {\n\t      if (this.raws) {\n\t        delete this.raws.value;\n\t      }\n\t    } else {\n\t      this.raws.value = rawValue;\n\t    }\n\t  };\n\n\t  _proto._handleEscapes = function _handleEscapes(prop, value) {\n\t    if (this._constructed) {\n\t      var escaped = (0, _cssesc[\"default\"])(value, {\n\t        isIdentifier: true\n\t      });\n\n\t      if (escaped !== value) {\n\t        this.raws[prop] = escaped;\n\t      } else {\n\t        delete this.raws[prop];\n\t      }\n\t    }\n\t  };\n\n\t  _proto._spacesFor = function _spacesFor(name) {\n\t    var attrSpaces = {\n\t      before: '',\n\t      after: ''\n\t    };\n\t    var spaces = this.spaces[name] || {};\n\t    var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};\n\t    return Object.assign(attrSpaces, spaces, rawSpaces);\n\t  };\n\n\t  _proto._stringFor = function _stringFor(name, spaceName, concat) {\n\t    if (spaceName === void 0) {\n\t      spaceName = name;\n\t    }\n\n\t    if (concat === void 0) {\n\t      concat = defaultAttrConcat;\n\t    }\n\n\t    var attrSpaces = this._spacesFor(spaceName);\n\n\t    return concat(this.stringifyProperty(name), attrSpaces);\n\t  }\n\t  /**\n\t   * returns the offset of the attribute part specified relative to the\n\t   * start of the node of the output string.\n\t   *\n\t   * * \"ns\" - alias for \"namespace\"\n\t   * * \"namespace\" - the namespace if it exists.\n\t   * * \"attribute\" - the attribute name\n\t   * * \"attributeNS\" - the start of the attribute or its namespace\n\t   * * \"operator\" - the match operator of the attribute\n\t   * * \"value\" - The value (string or identifier)\n\t   * * \"insensitive\" - the case insensitivity flag;\n\t   * @param part One of the possible values inside an attribute.\n\t   * @returns -1 if the name is invalid or the value doesn't exist in this attribute.\n\t   */\n\t  ;\n\n\t  _proto.offsetOf = function offsetOf(name) {\n\t    var count = 1;\n\n\t    var attributeSpaces = this._spacesFor(\"attribute\");\n\n\t    count += attributeSpaces.before.length;\n\n\t    if (name === \"namespace\" || name === \"ns\") {\n\t      return this.namespace ? count : -1;\n\t    }\n\n\t    if (name === \"attributeNS\") {\n\t      return count;\n\t    }\n\n\t    count += this.namespaceString.length;\n\n\t    if (this.namespace) {\n\t      count += 1;\n\t    }\n\n\t    if (name === \"attribute\") {\n\t      return count;\n\t    }\n\n\t    count += this.stringifyProperty(\"attribute\").length;\n\t    count += attributeSpaces.after.length;\n\n\t    var operatorSpaces = this._spacesFor(\"operator\");\n\n\t    count += operatorSpaces.before.length;\n\t    var operator = this.stringifyProperty(\"operator\");\n\n\t    if (name === \"operator\") {\n\t      return operator ? count : -1;\n\t    }\n\n\t    count += operator.length;\n\t    count += operatorSpaces.after.length;\n\n\t    var valueSpaces = this._spacesFor(\"value\");\n\n\t    count += valueSpaces.before.length;\n\t    var value = this.stringifyProperty(\"value\");\n\n\t    if (name === \"value\") {\n\t      return value ? count : -1;\n\t    }\n\n\t    count += value.length;\n\t    count += valueSpaces.after.length;\n\n\t    var insensitiveSpaces = this._spacesFor(\"insensitive\");\n\n\t    count += insensitiveSpaces.before.length;\n\n\t    if (name === \"insensitive\") {\n\t      return this.insensitive ? count : -1;\n\t    }\n\n\t    return -1;\n\t  };\n\n\t  _proto.toString = function toString() {\n\t    var _this2 = this;\n\n\t    var selector = [this.rawSpaceBefore, '['];\n\t    selector.push(this._stringFor('qualifiedAttribute', 'attribute'));\n\n\t    if (this.operator && (this.value || this.value === '')) {\n\t      selector.push(this._stringFor('operator'));\n\t      selector.push(this._stringFor('value'));\n\t      selector.push(this._stringFor('insensitiveFlag', 'insensitive', function (attrValue, attrSpaces) {\n\t        if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {\n\t          attrSpaces.before = \" \";\n\t        }\n\n\t        return defaultAttrConcat(attrValue, attrSpaces);\n\t      }));\n\t    }\n\n\t    selector.push(']');\n\t    selector.push(this.rawSpaceAfter);\n\t    return selector.join('');\n\t  };\n\n\t  _createClass(Attribute, [{\n\t    key: \"quoted\",\n\t    get: function get() {\n\t      var qm = this.quoteMark;\n\t      return qm === \"'\" || qm === '\"';\n\t    },\n\t    set: function set(value) {\n\t      warnOfDeprecatedQuotedAssignment();\n\t    }\n\t    /**\n\t     * returns a single (`'`) or double (`\"`) quote character if the value is quoted.\n\t     * returns `null` if the value is not quoted.\n\t     * returns `undefined` if the quotation state is unknown (this can happen when\n\t     * the attribute is constructed without specifying a quote mark.)\n\t     */\n\n\t  }, {\n\t    key: \"quoteMark\",\n\t    get: function get() {\n\t      return this._quoteMark;\n\t    }\n\t    /**\n\t     * Set the quote mark to be used by this attribute's value.\n\t     * If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute\n\t     * value is updated accordingly.\n\t     *\n\t     * @param {\"'\" | '\"' | null} quoteMark The quote mark or `null` if the value should be unquoted.\n\t     */\n\t    ,\n\t    set: function set(quoteMark) {\n\t      if (!this._constructed) {\n\t        this._quoteMark = quoteMark;\n\t        return;\n\t      }\n\n\t      if (this._quoteMark !== quoteMark) {\n\t        this._quoteMark = quoteMark;\n\n\t        this._syncRawValue();\n\t      }\n\t    }\n\t  }, {\n\t    key: \"qualifiedAttribute\",\n\t    get: function get() {\n\t      return this.qualifiedName(this.raws.attribute || this.attribute);\n\t    }\n\t  }, {\n\t    key: \"insensitiveFlag\",\n\t    get: function get() {\n\t      return this.insensitive ? 'i' : '';\n\t    }\n\t  }, {\n\t    key: \"value\",\n\t    get: function get() {\n\t      return this._value;\n\t    }\n\t    /**\n\t     * Before 3.0, the value had to be set to an escaped value including any wrapped\n\t     * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value\n\t     * is unescaped during parsing and any quote marks are removed.\n\t     *\n\t     * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,\n\t     * a deprecation warning is raised when the new value contains any characters that would\n\t     * require escaping (including if it contains wrapped quotes).\n\t     *\n\t     * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe\n\t     * how the new value is quoted.\n\t     */\n\t    ,\n\t    set: function set(v) {\n\t      if (this._constructed) {\n\t        var _unescapeValue2 = unescapeValue(v),\n\t            deprecatedUsage = _unescapeValue2.deprecatedUsage,\n\t            unescaped = _unescapeValue2.unescaped,\n\t            quoteMark = _unescapeValue2.quoteMark;\n\n\t        if (deprecatedUsage) {\n\t          warnOfDeprecatedValueAssignment();\n\t        }\n\n\t        if (unescaped === this._value && quoteMark === this._quoteMark) {\n\t          return;\n\t        }\n\n\t        this._value = unescaped;\n\t        this._quoteMark = quoteMark;\n\n\t        this._syncRawValue();\n\t      } else {\n\t        this._value = v;\n\t      }\n\t    }\n\t  }, {\n\t    key: \"attribute\",\n\t    get: function get() {\n\t      return this._attribute;\n\t    },\n\t    set: function set(name) {\n\t      this._handleEscapes(\"attribute\", name);\n\n\t      this._attribute = name;\n\t    }\n\t  }]);\n\n\t  return Attribute;\n\t}(_namespace[\"default\"]);\n\n\texports[\"default\"] = Attribute;\n\tAttribute.NO_QUOTE = null;\n\tAttribute.SINGLE_QUOTE = \"'\";\n\tAttribute.DOUBLE_QUOTE = '\"';\n\tvar CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {\n\t  \"'\": {\n\t    quotes: 'single',\n\t    wrap: true\n\t  },\n\t  '\"': {\n\t    quotes: 'double',\n\t    wrap: true\n\t  }\n\t}, _CSSESC_QUOTE_OPTIONS[null] = {\n\t  isIdentifier: true\n\t}, _CSSESC_QUOTE_OPTIONS);\n\n\tfunction defaultAttrConcat(attrValue, attrSpaces) {\n\t  return \"\" + attrSpaces.before + attrValue + attrSpaces.after;\n\t}\n} (attribute$1));\n\nvar universal$1 = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\n\tvar _namespace = _interopRequireDefault(namespace.exports);\n\n\tvar _types = types;\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\tvar Universal = /*#__PURE__*/function (_Namespace) {\n\t  _inheritsLoose(Universal, _Namespace);\n\n\t  function Universal(opts) {\n\t    var _this;\n\n\t    _this = _Namespace.call(this, opts) || this;\n\t    _this.type = _types.UNIVERSAL;\n\t    _this.value = '*';\n\t    return _this;\n\t  }\n\n\t  return Universal;\n\t}(_namespace[\"default\"]);\n\n\texports[\"default\"] = Universal;\n\tmodule.exports = exports.default;\n} (universal$1, universal$1.exports));\n\nvar combinator$2 = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\n\tvar _node = _interopRequireDefault(node$1.exports);\n\n\tvar _types = types;\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\tvar Combinator = /*#__PURE__*/function (_Node) {\n\t  _inheritsLoose(Combinator, _Node);\n\n\t  function Combinator(opts) {\n\t    var _this;\n\n\t    _this = _Node.call(this, opts) || this;\n\t    _this.type = _types.COMBINATOR;\n\t    return _this;\n\t  }\n\n\t  return Combinator;\n\t}(_node[\"default\"]);\n\n\texports[\"default\"] = Combinator;\n\tmodule.exports = exports.default;\n} (combinator$2, combinator$2.exports));\n\nvar nesting$1 = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\n\tvar _node = _interopRequireDefault(node$1.exports);\n\n\tvar _types = types;\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\tvar Nesting = /*#__PURE__*/function (_Node) {\n\t  _inheritsLoose(Nesting, _Node);\n\n\t  function Nesting(opts) {\n\t    var _this;\n\n\t    _this = _Node.call(this, opts) || this;\n\t    _this.type = _types.NESTING;\n\t    _this.value = '&';\n\t    return _this;\n\t  }\n\n\t  return Nesting;\n\t}(_node[\"default\"]);\n\n\texports[\"default\"] = Nesting;\n\tmodule.exports = exports.default;\n} (nesting$1, nesting$1.exports));\n\nvar sortAscending = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = sortAscending;\n\n\tfunction sortAscending(list) {\n\t  return list.sort(function (a, b) {\n\t    return a - b;\n\t  });\n\t}\n\tmodule.exports = exports.default;\n} (sortAscending, sortAscending.exports));\n\nvar tokenize = {};\n\nvar tokenTypes = {};\n\ntokenTypes.__esModule = true;\ntokenTypes.combinator = tokenTypes.word = tokenTypes.comment = tokenTypes.str = tokenTypes.tab = tokenTypes.newline = tokenTypes.feed = tokenTypes.cr = tokenTypes.backslash = tokenTypes.bang = tokenTypes.slash = tokenTypes.doubleQuote = tokenTypes.singleQuote = tokenTypes.space = tokenTypes.greaterThan = tokenTypes.pipe = tokenTypes.equals = tokenTypes.plus = tokenTypes.caret = tokenTypes.tilde = tokenTypes.dollar = tokenTypes.closeSquare = tokenTypes.openSquare = tokenTypes.closeParenthesis = tokenTypes.openParenthesis = tokenTypes.semicolon = tokenTypes.colon = tokenTypes.comma = tokenTypes.at = tokenTypes.asterisk = tokenTypes.ampersand = void 0;\nvar ampersand = 38; // `&`.charCodeAt(0);\n\ntokenTypes.ampersand = ampersand;\nvar asterisk = 42; // `*`.charCodeAt(0);\n\ntokenTypes.asterisk = asterisk;\nvar at = 64; // `@`.charCodeAt(0);\n\ntokenTypes.at = at;\nvar comma = 44; // `,`.charCodeAt(0);\n\ntokenTypes.comma = comma;\nvar colon = 58; // `:`.charCodeAt(0);\n\ntokenTypes.colon = colon;\nvar semicolon = 59; // `;`.charCodeAt(0);\n\ntokenTypes.semicolon = semicolon;\nvar openParenthesis = 40; // `(`.charCodeAt(0);\n\ntokenTypes.openParenthesis = openParenthesis;\nvar closeParenthesis = 41; // `)`.charCodeAt(0);\n\ntokenTypes.closeParenthesis = closeParenthesis;\nvar openSquare = 91; // `[`.charCodeAt(0);\n\ntokenTypes.openSquare = openSquare;\nvar closeSquare = 93; // `]`.charCodeAt(0);\n\ntokenTypes.closeSquare = closeSquare;\nvar dollar = 36; // `$`.charCodeAt(0);\n\ntokenTypes.dollar = dollar;\nvar tilde = 126; // `~`.charCodeAt(0);\n\ntokenTypes.tilde = tilde;\nvar caret = 94; // `^`.charCodeAt(0);\n\ntokenTypes.caret = caret;\nvar plus = 43; // `+`.charCodeAt(0);\n\ntokenTypes.plus = plus;\nvar equals = 61; // `=`.charCodeAt(0);\n\ntokenTypes.equals = equals;\nvar pipe = 124; // `|`.charCodeAt(0);\n\ntokenTypes.pipe = pipe;\nvar greaterThan = 62; // `>`.charCodeAt(0);\n\ntokenTypes.greaterThan = greaterThan;\nvar space = 32; // ` `.charCodeAt(0);\n\ntokenTypes.space = space;\nvar singleQuote = 39; // `'`.charCodeAt(0);\n\ntokenTypes.singleQuote = singleQuote;\nvar doubleQuote = 34; // `\"`.charCodeAt(0);\n\ntokenTypes.doubleQuote = doubleQuote;\nvar slash = 47; // `/`.charCodeAt(0);\n\ntokenTypes.slash = slash;\nvar bang = 33; // `!`.charCodeAt(0);\n\ntokenTypes.bang = bang;\nvar backslash = 92; // '\\\\'.charCodeAt(0);\n\ntokenTypes.backslash = backslash;\nvar cr = 13; // '\\r'.charCodeAt(0);\n\ntokenTypes.cr = cr;\nvar feed = 12; // '\\f'.charCodeAt(0);\n\ntokenTypes.feed = feed;\nvar newline = 10; // '\\n'.charCodeAt(0);\n\ntokenTypes.newline = newline;\nvar tab = 9; // '\\t'.charCodeAt(0);\n// Expose aliases primarily for readability.\n\ntokenTypes.tab = tab;\nvar str = singleQuote; // No good single character representation!\n\ntokenTypes.str = str;\nvar comment$1 = -1;\ntokenTypes.comment = comment$1;\nvar word = -2;\ntokenTypes.word = word;\nvar combinator$1 = -3;\ntokenTypes.combinator = combinator$1;\n\n(function (exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = tokenize;\n\texports.FIELDS = void 0;\n\n\tvar t = _interopRequireWildcard(tokenTypes);\n\n\tvar _unescapable, _wordDelimiters;\n\n\tfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n\tvar unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);\n\tvar wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);\n\tvar hex = {};\n\tvar hexChars = \"0123456789abcdefABCDEF\";\n\n\tfor (var i = 0; i < hexChars.length; i++) {\n\t  hex[hexChars.charCodeAt(i)] = true;\n\t}\n\t/**\n\t *  Returns the last index of the bar css word\n\t * @param {string} css The string in which the word begins\n\t * @param {number} start The index into the string where word's first letter occurs\n\t */\n\n\n\tfunction consumeWord(css, start) {\n\t  var next = start;\n\t  var code;\n\n\t  do {\n\t    code = css.charCodeAt(next);\n\n\t    if (wordDelimiters[code]) {\n\t      return next - 1;\n\t    } else if (code === t.backslash) {\n\t      next = consumeEscape(css, next) + 1;\n\t    } else {\n\t      // All other characters are part of the word\n\t      next++;\n\t    }\n\t  } while (next < css.length);\n\n\t  return next - 1;\n\t}\n\t/**\n\t *  Returns the last index of the escape sequence\n\t * @param {string} css The string in which the sequence begins\n\t * @param {number} start The index into the string where escape character (`\\`) occurs.\n\t */\n\n\n\tfunction consumeEscape(css, start) {\n\t  var next = start;\n\t  var code = css.charCodeAt(next + 1);\n\n\t  if (unescapable[code]) ; else if (hex[code]) {\n\t    var hexDigits = 0; // consume up to 6 hex chars\n\n\t    do {\n\t      next++;\n\t      hexDigits++;\n\t      code = css.charCodeAt(next + 1);\n\t    } while (hex[code] && hexDigits < 6); // if fewer than 6 hex chars, a trailing space ends the escape\n\n\n\t    if (hexDigits < 6 && code === t.space) {\n\t      next++;\n\t    }\n\t  } else {\n\t    // the next char is part of the current word\n\t    next++;\n\t  }\n\n\t  return next;\n\t}\n\n\tvar FIELDS = {\n\t  TYPE: 0,\n\t  START_LINE: 1,\n\t  START_COL: 2,\n\t  END_LINE: 3,\n\t  END_COL: 4,\n\t  START_POS: 5,\n\t  END_POS: 6\n\t};\n\texports.FIELDS = FIELDS;\n\n\tfunction tokenize(input) {\n\t  var tokens = [];\n\t  var css = input.css.valueOf();\n\t  var _css = css,\n\t      length = _css.length;\n\t  var offset = -1;\n\t  var line = 1;\n\t  var start = 0;\n\t  var end = 0;\n\t  var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;\n\n\t  function unclosed(what, fix) {\n\t    if (input.safe) {\n\t      // fyi: this is never set to true.\n\t      css += fix;\n\t      next = css.length - 1;\n\t    } else {\n\t      throw input.error('Unclosed ' + what, line, start - offset, start);\n\t    }\n\t  }\n\n\t  while (start < length) {\n\t    code = css.charCodeAt(start);\n\n\t    if (code === t.newline) {\n\t      offset = start;\n\t      line += 1;\n\t    }\n\n\t    switch (code) {\n\t      case t.space:\n\t      case t.tab:\n\t      case t.newline:\n\t      case t.cr:\n\t      case t.feed:\n\t        next = start;\n\n\t        do {\n\t          next += 1;\n\t          code = css.charCodeAt(next);\n\n\t          if (code === t.newline) {\n\t            offset = next;\n\t            line += 1;\n\t          }\n\t        } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);\n\n\t        tokenType = t.space;\n\t        endLine = line;\n\t        endColumn = next - offset - 1;\n\t        end = next;\n\t        break;\n\n\t      case t.plus:\n\t      case t.greaterThan:\n\t      case t.tilde:\n\t      case t.pipe:\n\t        next = start;\n\n\t        do {\n\t          next += 1;\n\t          code = css.charCodeAt(next);\n\t        } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);\n\n\t        tokenType = t.combinator;\n\t        endLine = line;\n\t        endColumn = start - offset;\n\t        end = next;\n\t        break;\n\t      // Consume these characters as single tokens.\n\n\t      case t.asterisk:\n\t      case t.ampersand:\n\t      case t.bang:\n\t      case t.comma:\n\t      case t.equals:\n\t      case t.dollar:\n\t      case t.caret:\n\t      case t.openSquare:\n\t      case t.closeSquare:\n\t      case t.colon:\n\t      case t.semicolon:\n\t      case t.openParenthesis:\n\t      case t.closeParenthesis:\n\t        next = start;\n\t        tokenType = code;\n\t        endLine = line;\n\t        endColumn = start - offset;\n\t        end = next + 1;\n\t        break;\n\n\t      case t.singleQuote:\n\t      case t.doubleQuote:\n\t        quote = code === t.singleQuote ? \"'\" : '\"';\n\t        next = start;\n\n\t        do {\n\t          escaped = false;\n\t          next = css.indexOf(quote, next + 1);\n\n\t          if (next === -1) {\n\t            unclosed('quote', quote);\n\t          }\n\n\t          escapePos = next;\n\n\t          while (css.charCodeAt(escapePos - 1) === t.backslash) {\n\t            escapePos -= 1;\n\t            escaped = !escaped;\n\t          }\n\t        } while (escaped);\n\n\t        tokenType = t.str;\n\t        endLine = line;\n\t        endColumn = start - offset;\n\t        end = next + 1;\n\t        break;\n\n\t      default:\n\t        if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {\n\t          next = css.indexOf('*/', start + 2) + 1;\n\n\t          if (next === 0) {\n\t            unclosed('comment', '*/');\n\t          }\n\n\t          content = css.slice(start, next + 1);\n\t          lines = content.split('\\n');\n\t          last = lines.length - 1;\n\n\t          if (last > 0) {\n\t            nextLine = line + last;\n\t            nextOffset = next - lines[last].length;\n\t          } else {\n\t            nextLine = line;\n\t            nextOffset = offset;\n\t          }\n\n\t          tokenType = t.comment;\n\t          line = nextLine;\n\t          endLine = nextLine;\n\t          endColumn = next - nextOffset;\n\t        } else if (code === t.slash) {\n\t          next = start;\n\t          tokenType = code;\n\t          endLine = line;\n\t          endColumn = start - offset;\n\t          end = next + 1;\n\t        } else {\n\t          next = consumeWord(css, start);\n\t          tokenType = t.word;\n\t          endLine = line;\n\t          endColumn = next - offset;\n\t        }\n\n\t        end = next + 1;\n\t        break;\n\t    } // Ensure that the token structure remains consistent\n\n\n\t    tokens.push([tokenType, // [0] Token type\n\t    line, // [1] Starting line\n\t    start - offset, // [2] Starting column\n\t    endLine, // [3] Ending line\n\t    endColumn, // [4] Ending column\n\t    start, // [5] Start position / Source index\n\t    end // [6] End position\n\t    ]); // Reset offset for the next token\n\n\t    if (nextOffset) {\n\t      offset = nextOffset;\n\t      nextOffset = null;\n\t    }\n\n\t    start = end;\n\t  }\n\n\t  return tokens;\n\t}\n} (tokenize));\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\n\tvar _root = _interopRequireDefault(root$1.exports);\n\n\tvar _selector = _interopRequireDefault(selector$1.exports);\n\n\tvar _className = _interopRequireDefault(className$1.exports);\n\n\tvar _comment = _interopRequireDefault(comment$2.exports);\n\n\tvar _id = _interopRequireDefault(id$1.exports);\n\n\tvar _tag = _interopRequireDefault(tag$1.exports);\n\n\tvar _string = _interopRequireDefault(string$1.exports);\n\n\tvar _pseudo = _interopRequireDefault(pseudo$1.exports);\n\n\tvar _attribute = _interopRequireWildcard(attribute$1);\n\n\tvar _universal = _interopRequireDefault(universal$1.exports);\n\n\tvar _combinator = _interopRequireDefault(combinator$2.exports);\n\n\tvar _nesting = _interopRequireDefault(nesting$1.exports);\n\n\tvar _sortAscending = _interopRequireDefault(sortAscending.exports);\n\n\tvar _tokenize = _interopRequireWildcard(tokenize);\n\n\tvar tokens = _interopRequireWildcard(tokenTypes);\n\n\tvar types$1 = _interopRequireWildcard(types);\n\n\tvar _util = util;\n\n\tvar _WHITESPACE_TOKENS, _Object$assign;\n\n\tfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n\tfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\n\tfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\tvar WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);\n\tvar WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));\n\n\tfunction tokenStart(token) {\n\t  return {\n\t    line: token[_tokenize.FIELDS.START_LINE],\n\t    column: token[_tokenize.FIELDS.START_COL]\n\t  };\n\t}\n\n\tfunction tokenEnd(token) {\n\t  return {\n\t    line: token[_tokenize.FIELDS.END_LINE],\n\t    column: token[_tokenize.FIELDS.END_COL]\n\t  };\n\t}\n\n\tfunction getSource(startLine, startColumn, endLine, endColumn) {\n\t  return {\n\t    start: {\n\t      line: startLine,\n\t      column: startColumn\n\t    },\n\t    end: {\n\t      line: endLine,\n\t      column: endColumn\n\t    }\n\t  };\n\t}\n\n\tfunction getTokenSource(token) {\n\t  return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);\n\t}\n\n\tfunction getTokenSourceSpan(startToken, endToken) {\n\t  if (!startToken) {\n\t    return undefined;\n\t  }\n\n\t  return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);\n\t}\n\n\tfunction unescapeProp(node, prop) {\n\t  var value = node[prop];\n\n\t  if (typeof value !== \"string\") {\n\t    return;\n\t  }\n\n\t  if (value.indexOf(\"\\\\\") !== -1) {\n\t    (0, _util.ensureObject)(node, 'raws');\n\t    node[prop] = (0, _util.unesc)(value);\n\n\t    if (node.raws[prop] === undefined) {\n\t      node.raws[prop] = value;\n\t    }\n\t  }\n\n\t  return node;\n\t}\n\n\tfunction indexesOf(array, item) {\n\t  var i = -1;\n\t  var indexes = [];\n\n\t  while ((i = array.indexOf(item, i + 1)) !== -1) {\n\t    indexes.push(i);\n\t  }\n\n\t  return indexes;\n\t}\n\n\tfunction uniqs() {\n\t  var list = Array.prototype.concat.apply([], arguments);\n\t  return list.filter(function (item, i) {\n\t    return i === list.indexOf(item);\n\t  });\n\t}\n\n\tvar Parser = /*#__PURE__*/function () {\n\t  function Parser(rule, options) {\n\t    if (options === void 0) {\n\t      options = {};\n\t    }\n\n\t    this.rule = rule;\n\t    this.options = Object.assign({\n\t      lossy: false,\n\t      safe: false\n\t    }, options);\n\t    this.position = 0;\n\t    this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;\n\t    this.tokens = (0, _tokenize[\"default\"])({\n\t      css: this.css,\n\t      error: this._errorGenerator(),\n\t      safe: this.options.safe\n\t    });\n\t    var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);\n\t    this.root = new _root[\"default\"]({\n\t      source: rootSource\n\t    });\n\t    this.root.errorGenerator = this._errorGenerator();\n\t    var selector = new _selector[\"default\"]({\n\t      source: {\n\t        start: {\n\t          line: 1,\n\t          column: 1\n\t        }\n\t      }\n\t    });\n\t    this.root.append(selector);\n\t    this.current = selector;\n\t    this.loop();\n\t  }\n\n\t  var _proto = Parser.prototype;\n\n\t  _proto._errorGenerator = function _errorGenerator() {\n\t    var _this = this;\n\n\t    return function (message, errorOptions) {\n\t      if (typeof _this.rule === 'string') {\n\t        return new Error(message);\n\t      }\n\n\t      return _this.rule.error(message, errorOptions);\n\t    };\n\t  };\n\n\t  _proto.attribute = function attribute() {\n\t    var attr = [];\n\t    var startingToken = this.currToken;\n\t    this.position++;\n\n\t    while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n\t      attr.push(this.currToken);\n\t      this.position++;\n\t    }\n\n\t    if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n\t      return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n\t    }\n\n\t    var len = attr.length;\n\t    var node = {\n\t      source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),\n\t      sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n\t    };\n\n\t    if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {\n\t      return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);\n\t    }\n\n\t    var pos = 0;\n\t    var spaceBefore = '';\n\t    var commentBefore = '';\n\t    var lastAdded = null;\n\t    var spaceAfterMeaningfulToken = false;\n\n\t    while (pos < len) {\n\t      var token = attr[pos];\n\t      var content = this.content(token);\n\t      var next = attr[pos + 1];\n\n\t      switch (token[_tokenize.FIELDS.TYPE]) {\n\t        case tokens.space:\n\t          // if (\n\t          //     len === 1 ||\n\t          //     pos === 0 && this.content(next) === '|'\n\t          // ) {\n\t          //     return this.expected('attribute', token[TOKEN.START_POS], content);\n\t          // }\n\t          spaceAfterMeaningfulToken = true;\n\n\t          if (this.options.lossy) {\n\t            break;\n\t          }\n\n\t          if (lastAdded) {\n\t            (0, _util.ensureObject)(node, 'spaces', lastAdded);\n\t            var prevContent = node.spaces[lastAdded].after || '';\n\t            node.spaces[lastAdded].after = prevContent + content;\n\t            var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;\n\n\t            if (existingComment) {\n\t              node.raws.spaces[lastAdded].after = existingComment + content;\n\t            }\n\t          } else {\n\t            spaceBefore = spaceBefore + content;\n\t            commentBefore = commentBefore + content;\n\t          }\n\n\t          break;\n\n\t        case tokens.asterisk:\n\t          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n\t            node.operator = content;\n\t            lastAdded = 'operator';\n\t          } else if ((!node.namespace || lastAdded === \"namespace\" && !spaceAfterMeaningfulToken) && next) {\n\t            if (spaceBefore) {\n\t              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n\t              node.spaces.attribute.before = spaceBefore;\n\t              spaceBefore = '';\n\t            }\n\n\t            if (commentBefore) {\n\t              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n\t              node.raws.spaces.attribute.before = spaceBefore;\n\t              commentBefore = '';\n\t            }\n\n\t            node.namespace = (node.namespace || \"\") + content;\n\t            var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;\n\n\t            if (rawValue) {\n\t              node.raws.namespace += content;\n\t            }\n\n\t            lastAdded = 'namespace';\n\t          }\n\n\t          spaceAfterMeaningfulToken = false;\n\t          break;\n\n\t        case tokens.dollar:\n\t          if (lastAdded === \"value\") {\n\t            var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');\n\t            node.value += \"$\";\n\n\t            if (oldRawValue) {\n\t              node.raws.value = oldRawValue + \"$\";\n\t            }\n\n\t            break;\n\t          }\n\n\t        // Falls through\n\n\t        case tokens.caret:\n\t          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n\t            node.operator = content;\n\t            lastAdded = 'operator';\n\t          }\n\n\t          spaceAfterMeaningfulToken = false;\n\t          break;\n\n\t        case tokens.combinator:\n\t          if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n\t            node.operator = content;\n\t            lastAdded = 'operator';\n\t          }\n\n\t          if (content !== '|') {\n\t            spaceAfterMeaningfulToken = false;\n\t            break;\n\t          }\n\n\t          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n\t            node.operator = content;\n\t            lastAdded = 'operator';\n\t          } else if (!node.namespace && !node.attribute) {\n\t            node.namespace = true;\n\t          }\n\n\t          spaceAfterMeaningfulToken = false;\n\t          break;\n\n\t        case tokens.word:\n\t          if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.\n\t          !node.operator && !node.namespace) {\n\t            node.namespace = content;\n\t            lastAdded = 'namespace';\n\t          } else if (!node.attribute || lastAdded === \"attribute\" && !spaceAfterMeaningfulToken) {\n\t            if (spaceBefore) {\n\t              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n\t              node.spaces.attribute.before = spaceBefore;\n\t              spaceBefore = '';\n\t            }\n\n\t            if (commentBefore) {\n\t              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n\t              node.raws.spaces.attribute.before = commentBefore;\n\t              commentBefore = '';\n\t            }\n\n\t            node.attribute = (node.attribute || \"\") + content;\n\n\t            var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;\n\n\t            if (_rawValue) {\n\t              node.raws.attribute += content;\n\t            }\n\n\t            lastAdded = 'attribute';\n\t          } else if (!node.value && node.value !== \"\" || lastAdded === \"value\" && !spaceAfterMeaningfulToken) {\n\t            var _unescaped = (0, _util.unesc)(content);\n\n\t            var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';\n\n\t            var oldValue = node.value || '';\n\t            node.value = oldValue + _unescaped;\n\t            node.quoteMark = null;\n\n\t            if (_unescaped !== content || _oldRawValue) {\n\t              (0, _util.ensureObject)(node, 'raws');\n\t              node.raws.value = (_oldRawValue || oldValue) + content;\n\t            }\n\n\t            lastAdded = 'value';\n\t          } else {\n\t            var insensitive = content === 'i' || content === \"I\";\n\n\t            if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {\n\t              node.insensitive = insensitive;\n\n\t              if (!insensitive || content === \"I\") {\n\t                (0, _util.ensureObject)(node, 'raws');\n\t                node.raws.insensitiveFlag = content;\n\t              }\n\n\t              lastAdded = 'insensitive';\n\n\t              if (spaceBefore) {\n\t                (0, _util.ensureObject)(node, 'spaces', 'insensitive');\n\t                node.spaces.insensitive.before = spaceBefore;\n\t                spaceBefore = '';\n\t              }\n\n\t              if (commentBefore) {\n\t                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');\n\t                node.raws.spaces.insensitive.before = commentBefore;\n\t                commentBefore = '';\n\t              }\n\t            } else if (node.value || node.value === '') {\n\t              lastAdded = 'value';\n\t              node.value += content;\n\n\t              if (node.raws.value) {\n\t                node.raws.value += content;\n\t              }\n\t            }\n\t          }\n\n\t          spaceAfterMeaningfulToken = false;\n\t          break;\n\n\t        case tokens.str:\n\t          if (!node.attribute || !node.operator) {\n\t            return this.error(\"Expected an attribute followed by an operator preceding the string.\", {\n\t              index: token[_tokenize.FIELDS.START_POS]\n\t            });\n\t          }\n\n\t          var _unescapeValue = (0, _attribute.unescapeValue)(content),\n\t              unescaped = _unescapeValue.unescaped,\n\t              quoteMark = _unescapeValue.quoteMark;\n\n\t          node.value = unescaped;\n\t          node.quoteMark = quoteMark;\n\t          lastAdded = 'value';\n\t          (0, _util.ensureObject)(node, 'raws');\n\t          node.raws.value = content;\n\t          spaceAfterMeaningfulToken = false;\n\t          break;\n\n\t        case tokens.equals:\n\t          if (!node.attribute) {\n\t            return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);\n\t          }\n\n\t          if (node.value) {\n\t            return this.error('Unexpected \"=\" found; an operator was already defined.', {\n\t              index: token[_tokenize.FIELDS.START_POS]\n\t            });\n\t          }\n\n\t          node.operator = node.operator ? node.operator + content : content;\n\t          lastAdded = 'operator';\n\t          spaceAfterMeaningfulToken = false;\n\t          break;\n\n\t        case tokens.comment:\n\t          if (lastAdded) {\n\t            if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {\n\t              var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';\n\t              var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;\n\t              (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);\n\t              node.raws.spaces[lastAdded].after = rawLastComment + content;\n\t            } else {\n\t              var lastValue = node[lastAdded] || '';\n\t              var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;\n\t              (0, _util.ensureObject)(node, 'raws');\n\t              node.raws[lastAdded] = rawLastValue + content;\n\t            }\n\t          } else {\n\t            commentBefore = commentBefore + content;\n\t          }\n\n\t          break;\n\n\t        default:\n\t          return this.error(\"Unexpected \\\"\" + content + \"\\\" found.\", {\n\t            index: token[_tokenize.FIELDS.START_POS]\n\t          });\n\t      }\n\n\t      pos++;\n\t    }\n\n\t    unescapeProp(node, \"attribute\");\n\t    unescapeProp(node, \"namespace\");\n\t    this.newNode(new _attribute[\"default\"](node));\n\t    this.position++;\n\t  }\n\t  /**\n\t   * return a node containing meaningless garbage up to (but not including) the specified token position.\n\t   * if the token position is negative, all remaining tokens are consumed.\n\t   *\n\t   * This returns an array containing a single string node if all whitespace,\n\t   * otherwise an array of comment nodes with space before and after.\n\t   *\n\t   * These tokens are not added to the current selector, the caller can add them or use them to amend\n\t   * a previous node's space metadata.\n\t   *\n\t   * In lossy mode, this returns only comments.\n\t   */\n\t  ;\n\n\t  _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {\n\t    if (stopPosition < 0) {\n\t      stopPosition = this.tokens.length;\n\t    }\n\n\t    var startPosition = this.position;\n\t    var nodes = [];\n\t    var space = \"\";\n\t    var lastComment = undefined;\n\n\t    do {\n\t      if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {\n\t        if (!this.options.lossy) {\n\t          space += this.content();\n\t        }\n\t      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {\n\t        var spaces = {};\n\n\t        if (space) {\n\t          spaces.before = space;\n\t          space = \"\";\n\t        }\n\n\t        lastComment = new _comment[\"default\"]({\n\t          value: this.content(),\n\t          source: getTokenSource(this.currToken),\n\t          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n\t          spaces: spaces\n\t        });\n\t        nodes.push(lastComment);\n\t      }\n\t    } while (++this.position < stopPosition);\n\n\t    if (space) {\n\t      if (lastComment) {\n\t        lastComment.spaces.after = space;\n\t      } else if (!this.options.lossy) {\n\t        var firstToken = this.tokens[startPosition];\n\t        var lastToken = this.tokens[this.position - 1];\n\t        nodes.push(new _string[\"default\"]({\n\t          value: '',\n\t          source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),\n\t          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n\t          spaces: {\n\t            before: space,\n\t            after: ''\n\t          }\n\t        }));\n\t      }\n\t    }\n\n\t    return nodes;\n\t  }\n\t  /**\n\t   * \n\t   * @param {*} nodes \n\t   */\n\t  ;\n\n\t  _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {\n\t    var _this2 = this;\n\n\t    if (requiredSpace === void 0) {\n\t      requiredSpace = false;\n\t    }\n\n\t    var space = \"\";\n\t    var rawSpace = \"\";\n\t    nodes.forEach(function (n) {\n\t      var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);\n\n\t      var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);\n\n\t      space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);\n\t      rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);\n\t    });\n\n\t    if (rawSpace === space) {\n\t      rawSpace = undefined;\n\t    }\n\n\t    var result = {\n\t      space: space,\n\t      rawSpace: rawSpace\n\t    };\n\t    return result;\n\t  };\n\n\t  _proto.isNamedCombinator = function isNamedCombinator(position) {\n\t    if (position === void 0) {\n\t      position = this.position;\n\t    }\n\n\t    return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;\n\t  };\n\n\t  _proto.namedCombinator = function namedCombinator() {\n\t    if (this.isNamedCombinator()) {\n\t      var nameRaw = this.content(this.tokens[this.position + 1]);\n\t      var name = (0, _util.unesc)(nameRaw).toLowerCase();\n\t      var raws = {};\n\n\t      if (name !== nameRaw) {\n\t        raws.value = \"/\" + nameRaw + \"/\";\n\t      }\n\n\t      var node = new _combinator[\"default\"]({\n\t        value: \"/\" + name + \"/\",\n\t        source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),\n\t        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n\t        raws: raws\n\t      });\n\t      this.position = this.position + 3;\n\t      return node;\n\t    } else {\n\t      this.unexpected();\n\t    }\n\t  };\n\n\t  _proto.combinator = function combinator() {\n\t    var _this3 = this;\n\n\t    if (this.content() === '|') {\n\t      return this.namespace();\n\t    } // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.\n\n\n\t    var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);\n\n\t    if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {\n\t      var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n\n\t      if (nodes.length > 0) {\n\t        var last = this.current.last;\n\n\t        if (last) {\n\t          var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes),\n\t              space = _this$convertWhitespa.space,\n\t              rawSpace = _this$convertWhitespa.rawSpace;\n\n\t          if (rawSpace !== undefined) {\n\t            last.rawSpaceAfter += rawSpace;\n\t          }\n\n\t          last.spaces.after += space;\n\t        } else {\n\t          nodes.forEach(function (n) {\n\t            return _this3.newNode(n);\n\t          });\n\t        }\n\t      }\n\n\t      return;\n\t    }\n\n\t    var firstToken = this.currToken;\n\t    var spaceOrDescendantSelectorNodes = undefined;\n\n\t    if (nextSigTokenPos > this.position) {\n\t      spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n\t    }\n\n\t    var node;\n\n\t    if (this.isNamedCombinator()) {\n\t      node = this.namedCombinator();\n\t    } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {\n\t      node = new _combinator[\"default\"]({\n\t        value: this.content(),\n\t        source: getTokenSource(this.currToken),\n\t        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]\n\t      });\n\t      this.position++;\n\t    } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) ; else if (!spaceOrDescendantSelectorNodes) {\n\t      this.unexpected();\n\t    }\n\n\t    if (node) {\n\t      if (spaceOrDescendantSelectorNodes) {\n\t        var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),\n\t            _space = _this$convertWhitespa2.space,\n\t            _rawSpace = _this$convertWhitespa2.rawSpace;\n\n\t        node.spaces.before = _space;\n\t        node.rawSpaceBefore = _rawSpace;\n\t      }\n\t    } else {\n\t      // descendant combinator\n\t      var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),\n\t          _space2 = _this$convertWhitespa3.space,\n\t          _rawSpace2 = _this$convertWhitespa3.rawSpace;\n\n\t      if (!_rawSpace2) {\n\t        _rawSpace2 = _space2;\n\t      }\n\n\t      var spaces = {};\n\t      var raws = {\n\t        spaces: {}\n\t      };\n\n\t      if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {\n\t        spaces.before = _space2.slice(0, _space2.length - 1);\n\t        raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);\n\t      } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {\n\t        spaces.after = _space2.slice(1);\n\t        raws.spaces.after = _rawSpace2.slice(1);\n\t      } else {\n\t        raws.value = _rawSpace2;\n\t      }\n\n\t      node = new _combinator[\"default\"]({\n\t        value: ' ',\n\t        source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),\n\t        sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n\t        spaces: spaces,\n\t        raws: raws\n\t      });\n\t    }\n\n\t    if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {\n\t      node.spaces.after = this.optionalSpace(this.content());\n\t      this.position++;\n\t    }\n\n\t    return this.newNode(node);\n\t  };\n\n\t  _proto.comma = function comma() {\n\t    if (this.position === this.tokens.length - 1) {\n\t      this.root.trailingComma = true;\n\t      this.position++;\n\t      return;\n\t    }\n\n\t    this.current._inferEndPosition();\n\n\t    var selector = new _selector[\"default\"]({\n\t      source: {\n\t        start: tokenStart(this.tokens[this.position + 1])\n\t      }\n\t    });\n\t    this.current.parent.append(selector);\n\t    this.current = selector;\n\t    this.position++;\n\t  };\n\n\t  _proto.comment = function comment() {\n\t    var current = this.currToken;\n\t    this.newNode(new _comment[\"default\"]({\n\t      value: this.content(),\n\t      source: getTokenSource(current),\n\t      sourceIndex: current[_tokenize.FIELDS.START_POS]\n\t    }));\n\t    this.position++;\n\t  };\n\n\t  _proto.error = function error(message, opts) {\n\t    throw this.root.error(message, opts);\n\t  };\n\n\t  _proto.missingBackslash = function missingBackslash() {\n\t    return this.error('Expected a backslash preceding the semicolon.', {\n\t      index: this.currToken[_tokenize.FIELDS.START_POS]\n\t    });\n\t  };\n\n\t  _proto.missingParenthesis = function missingParenthesis() {\n\t    return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n\t  };\n\n\t  _proto.missingSquareBracket = function missingSquareBracket() {\n\t    return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n\t  };\n\n\t  _proto.unexpected = function unexpected() {\n\t    return this.error(\"Unexpected '\" + this.content() + \"'. Escaping special characters with \\\\ may help.\", this.currToken[_tokenize.FIELDS.START_POS]);\n\t  };\n\n\t  _proto.namespace = function namespace() {\n\t    var before = this.prevToken && this.content(this.prevToken) || true;\n\n\t    if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n\t      this.position++;\n\t      return this.word(before);\n\t    } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {\n\t      this.position++;\n\t      return this.universal(before);\n\t    }\n\t  };\n\n\t  _proto.nesting = function nesting() {\n\t    if (this.nextToken) {\n\t      var nextContent = this.content(this.nextToken);\n\n\t      if (nextContent === \"|\") {\n\t        this.position++;\n\t        return;\n\t      }\n\t    }\n\n\t    var current = this.currToken;\n\t    this.newNode(new _nesting[\"default\"]({\n\t      value: this.content(),\n\t      source: getTokenSource(current),\n\t      sourceIndex: current[_tokenize.FIELDS.START_POS]\n\t    }));\n\t    this.position++;\n\t  };\n\n\t  _proto.parentheses = function parentheses() {\n\t    var last = this.current.last;\n\t    var unbalanced = 1;\n\t    this.position++;\n\n\t    if (last && last.type === types$1.PSEUDO) {\n\t      var selector = new _selector[\"default\"]({\n\t        source: {\n\t          start: tokenStart(this.tokens[this.position - 1])\n\t        }\n\t      });\n\t      var cache = this.current;\n\t      last.append(selector);\n\t      this.current = selector;\n\n\t      while (this.position < this.tokens.length && unbalanced) {\n\t        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n\t          unbalanced++;\n\t        }\n\n\t        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n\t          unbalanced--;\n\t        }\n\n\t        if (unbalanced) {\n\t          this.parse();\n\t        } else {\n\t          this.current.source.end = tokenEnd(this.currToken);\n\t          this.current.parent.source.end = tokenEnd(this.currToken);\n\t          this.position++;\n\t        }\n\t      }\n\n\t      this.current = cache;\n\t    } else {\n\t      // I think this case should be an error. It's used to implement a basic parse of media queries\n\t      // but I don't think it's a good idea.\n\t      var parenStart = this.currToken;\n\t      var parenValue = \"(\";\n\t      var parenEnd;\n\n\t      while (this.position < this.tokens.length && unbalanced) {\n\t        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n\t          unbalanced++;\n\t        }\n\n\t        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n\t          unbalanced--;\n\t        }\n\n\t        parenEnd = this.currToken;\n\t        parenValue += this.parseParenthesisToken(this.currToken);\n\t        this.position++;\n\t      }\n\n\t      if (last) {\n\t        last.appendToPropertyAndEscape(\"value\", parenValue, parenValue);\n\t      } else {\n\t        this.newNode(new _string[\"default\"]({\n\t          value: parenValue,\n\t          source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),\n\t          sourceIndex: parenStart[_tokenize.FIELDS.START_POS]\n\t        }));\n\t      }\n\t    }\n\n\t    if (unbalanced) {\n\t      return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n\t    }\n\t  };\n\n\t  _proto.pseudo = function pseudo() {\n\t    var _this4 = this;\n\n\t    var pseudoStr = '';\n\t    var startingToken = this.currToken;\n\n\t    while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {\n\t      pseudoStr += this.content();\n\t      this.position++;\n\t    }\n\n\t    if (!this.currToken) {\n\t      return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);\n\t    }\n\n\t    if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n\t      this.splitWord(false, function (first, length) {\n\t        pseudoStr += first;\n\n\t        _this4.newNode(new _pseudo[\"default\"]({\n\t          value: pseudoStr,\n\t          source: getTokenSourceSpan(startingToken, _this4.currToken),\n\t          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n\t        }));\n\n\t        if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n\t          _this4.error('Misplaced parenthesis.', {\n\t            index: _this4.nextToken[_tokenize.FIELDS.START_POS]\n\t          });\n\t        }\n\t      });\n\t    } else {\n\t      return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);\n\t    }\n\t  };\n\n\t  _proto.space = function space() {\n\t    var content = this.content(); // Handle space before and after the selector\n\n\t    if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function (node) {\n\t      return node.type === 'comment';\n\t    })) {\n\t      this.spaces = this.optionalSpace(content);\n\t      this.position++;\n\t    } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n\t      this.current.last.spaces.after = this.optionalSpace(content);\n\t      this.position++;\n\t    } else {\n\t      this.combinator();\n\t    }\n\t  };\n\n\t  _proto.string = function string() {\n\t    var current = this.currToken;\n\t    this.newNode(new _string[\"default\"]({\n\t      value: this.content(),\n\t      source: getTokenSource(current),\n\t      sourceIndex: current[_tokenize.FIELDS.START_POS]\n\t    }));\n\t    this.position++;\n\t  };\n\n\t  _proto.universal = function universal(namespace) {\n\t    var nextToken = this.nextToken;\n\n\t    if (nextToken && this.content(nextToken) === '|') {\n\t      this.position++;\n\t      return this.namespace();\n\t    }\n\n\t    var current = this.currToken;\n\t    this.newNode(new _universal[\"default\"]({\n\t      value: this.content(),\n\t      source: getTokenSource(current),\n\t      sourceIndex: current[_tokenize.FIELDS.START_POS]\n\t    }), namespace);\n\t    this.position++;\n\t  };\n\n\t  _proto.splitWord = function splitWord(namespace, firstCallback) {\n\t    var _this5 = this;\n\n\t    var nextToken = this.nextToken;\n\t    var word = this.content();\n\n\t    while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {\n\t      this.position++;\n\t      var current = this.content();\n\t      word += current;\n\n\t      if (current.lastIndexOf('\\\\') === current.length - 1) {\n\t        var next = this.nextToken;\n\n\t        if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {\n\t          word += this.requiredSpace(this.content(next));\n\t          this.position++;\n\t        }\n\t      }\n\n\t      nextToken = this.nextToken;\n\t    }\n\n\t    var hasClass = indexesOf(word, '.').filter(function (i) {\n\t      // Allow escaped dot within class name\n\t      var escapedDot = word[i - 1] === '\\\\'; // Allow decimal numbers percent in @keyframes\n\n\t      var isKeyframesPercent = /^\\d+\\.\\d+%$/.test(word);\n\t      return !escapedDot && !isKeyframesPercent;\n\t    });\n\t    var hasId = indexesOf(word, '#').filter(function (i) {\n\t      return word[i - 1] !== '\\\\';\n\t    }); // Eliminate Sass interpolations from the list of id indexes\n\n\t    var interpolations = indexesOf(word, '#{');\n\n\t    if (interpolations.length) {\n\t      hasId = hasId.filter(function (hashIndex) {\n\t        return !~interpolations.indexOf(hashIndex);\n\t      });\n\t    }\n\n\t    var indices = (0, _sortAscending[\"default\"])(uniqs([0].concat(hasClass, hasId)));\n\t    indices.forEach(function (ind, i) {\n\t      var index = indices[i + 1] || word.length;\n\t      var value = word.slice(ind, index);\n\n\t      if (i === 0 && firstCallback) {\n\t        return firstCallback.call(_this5, value, indices.length);\n\t      }\n\n\t      var node;\n\t      var current = _this5.currToken;\n\t      var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];\n\t      var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));\n\n\t      if (~hasClass.indexOf(ind)) {\n\t        var classNameOpts = {\n\t          value: value.slice(1),\n\t          source: source,\n\t          sourceIndex: sourceIndex\n\t        };\n\t        node = new _className[\"default\"](unescapeProp(classNameOpts, \"value\"));\n\t      } else if (~hasId.indexOf(ind)) {\n\t        var idOpts = {\n\t          value: value.slice(1),\n\t          source: source,\n\t          sourceIndex: sourceIndex\n\t        };\n\t        node = new _id[\"default\"](unescapeProp(idOpts, \"value\"));\n\t      } else {\n\t        var tagOpts = {\n\t          value: value,\n\t          source: source,\n\t          sourceIndex: sourceIndex\n\t        };\n\t        unescapeProp(tagOpts, \"value\");\n\t        node = new _tag[\"default\"](tagOpts);\n\t      }\n\n\t      _this5.newNode(node, namespace); // Ensure that the namespace is used only once\n\n\n\t      namespace = null;\n\t    });\n\t    this.position++;\n\t  };\n\n\t  _proto.word = function word(namespace) {\n\t    var nextToken = this.nextToken;\n\n\t    if (nextToken && this.content(nextToken) === '|') {\n\t      this.position++;\n\t      return this.namespace();\n\t    }\n\n\t    return this.splitWord(namespace);\n\t  };\n\n\t  _proto.loop = function loop() {\n\t    while (this.position < this.tokens.length) {\n\t      this.parse(true);\n\t    }\n\n\t    this.current._inferEndPosition();\n\n\t    return this.root;\n\t  };\n\n\t  _proto.parse = function parse(throwOnParenthesis) {\n\t    switch (this.currToken[_tokenize.FIELDS.TYPE]) {\n\t      case tokens.space:\n\t        this.space();\n\t        break;\n\n\t      case tokens.comment:\n\t        this.comment();\n\t        break;\n\n\t      case tokens.openParenthesis:\n\t        this.parentheses();\n\t        break;\n\n\t      case tokens.closeParenthesis:\n\t        if (throwOnParenthesis) {\n\t          this.missingParenthesis();\n\t        }\n\n\t        break;\n\n\t      case tokens.openSquare:\n\t        this.attribute();\n\t        break;\n\n\t      case tokens.dollar:\n\t      case tokens.caret:\n\t      case tokens.equals:\n\t      case tokens.word:\n\t        this.word();\n\t        break;\n\n\t      case tokens.colon:\n\t        this.pseudo();\n\t        break;\n\n\t      case tokens.comma:\n\t        this.comma();\n\t        break;\n\n\t      case tokens.asterisk:\n\t        this.universal();\n\t        break;\n\n\t      case tokens.ampersand:\n\t        this.nesting();\n\t        break;\n\n\t      case tokens.slash:\n\t      case tokens.combinator:\n\t        this.combinator();\n\t        break;\n\n\t      case tokens.str:\n\t        this.string();\n\t        break;\n\t      // These cases throw; no break needed.\n\n\t      case tokens.closeSquare:\n\t        this.missingSquareBracket();\n\n\t      case tokens.semicolon:\n\t        this.missingBackslash();\n\n\t      default:\n\t        this.unexpected();\n\t    }\n\t  }\n\t  /**\n\t   * Helpers\n\t   */\n\t  ;\n\n\t  _proto.expected = function expected(description, index, found) {\n\t    if (Array.isArray(description)) {\n\t      var last = description.pop();\n\t      description = description.join(', ') + \" or \" + last;\n\t    }\n\n\t    var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';\n\n\t    if (!found) {\n\t      return this.error(\"Expected \" + an + \" \" + description + \".\", {\n\t        index: index\n\t      });\n\t    }\n\n\t    return this.error(\"Expected \" + an + \" \" + description + \", found \\\"\" + found + \"\\\" instead.\", {\n\t      index: index\n\t    });\n\t  };\n\n\t  _proto.requiredSpace = function requiredSpace(space) {\n\t    return this.options.lossy ? ' ' : space;\n\t  };\n\n\t  _proto.optionalSpace = function optionalSpace(space) {\n\t    return this.options.lossy ? '' : space;\n\t  };\n\n\t  _proto.lossySpace = function lossySpace(space, required) {\n\t    if (this.options.lossy) {\n\t      return required ? ' ' : '';\n\t    } else {\n\t      return space;\n\t    }\n\t  };\n\n\t  _proto.parseParenthesisToken = function parseParenthesisToken(token) {\n\t    var content = this.content(token);\n\n\t    if (token[_tokenize.FIELDS.TYPE] === tokens.space) {\n\t      return this.requiredSpace(content);\n\t    } else {\n\t      return content;\n\t    }\n\t  };\n\n\t  _proto.newNode = function newNode(node, namespace) {\n\t    if (namespace) {\n\t      if (/^ +$/.test(namespace)) {\n\t        if (!this.options.lossy) {\n\t          this.spaces = (this.spaces || '') + namespace;\n\t        }\n\n\t        namespace = true;\n\t      }\n\n\t      node.namespace = namespace;\n\t      unescapeProp(node, \"namespace\");\n\t    }\n\n\t    if (this.spaces) {\n\t      node.spaces.before = this.spaces;\n\t      this.spaces = '';\n\t    }\n\n\t    return this.current.append(node);\n\t  };\n\n\t  _proto.content = function content(token) {\n\t    if (token === void 0) {\n\t      token = this.currToken;\n\t    }\n\n\t    return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);\n\t  };\n\n\t  /**\n\t   * returns the index of the next non-whitespace, non-comment token.\n\t   * returns -1 if no meaningful token is found.\n\t   */\n\t  _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {\n\t    if (startPosition === void 0) {\n\t      startPosition = this.position + 1;\n\t    }\n\n\t    var searchPosition = startPosition;\n\n\t    while (searchPosition < this.tokens.length) {\n\t      if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {\n\t        searchPosition++;\n\t        continue;\n\t      } else {\n\t        return searchPosition;\n\t      }\n\t    }\n\n\t    return -1;\n\t  };\n\n\t  _createClass(Parser, [{\n\t    key: \"currToken\",\n\t    get: function get() {\n\t      return this.tokens[this.position];\n\t    }\n\t  }, {\n\t    key: \"nextToken\",\n\t    get: function get() {\n\t      return this.tokens[this.position + 1];\n\t    }\n\t  }, {\n\t    key: \"prevToken\",\n\t    get: function get() {\n\t      return this.tokens[this.position - 1];\n\t    }\n\t  }]);\n\n\t  return Parser;\n\t}();\n\n\texports[\"default\"] = Parser;\n\tmodule.exports = exports.default;\n} (parser, parser.exports));\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\n\tvar _parser = _interopRequireDefault(parser.exports);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n\tvar Processor = /*#__PURE__*/function () {\n\t  function Processor(func, options) {\n\t    this.func = func || function noop() {};\n\n\t    this.funcRes = null;\n\t    this.options = options;\n\t  }\n\n\t  var _proto = Processor.prototype;\n\n\t  _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule, options) {\n\t    if (options === void 0) {\n\t      options = {};\n\t    }\n\n\t    var merged = Object.assign({}, this.options, options);\n\n\t    if (merged.updateSelector === false) {\n\t      return false;\n\t    } else {\n\t      return typeof rule !== \"string\";\n\t    }\n\t  };\n\n\t  _proto._isLossy = function _isLossy(options) {\n\t    if (options === void 0) {\n\t      options = {};\n\t    }\n\n\t    var merged = Object.assign({}, this.options, options);\n\n\t    if (merged.lossless === false) {\n\t      return true;\n\t    } else {\n\t      return false;\n\t    }\n\t  };\n\n\t  _proto._root = function _root(rule, options) {\n\t    if (options === void 0) {\n\t      options = {};\n\t    }\n\n\t    var parser = new _parser[\"default\"](rule, this._parseOptions(options));\n\t    return parser.root;\n\t  };\n\n\t  _proto._parseOptions = function _parseOptions(options) {\n\t    return {\n\t      lossy: this._isLossy(options)\n\t    };\n\t  };\n\n\t  _proto._run = function _run(rule, options) {\n\t    var _this = this;\n\n\t    if (options === void 0) {\n\t      options = {};\n\t    }\n\n\t    return new Promise(function (resolve, reject) {\n\t      try {\n\t        var root = _this._root(rule, options);\n\n\t        Promise.resolve(_this.func(root)).then(function (transform) {\n\t          var string = undefined;\n\n\t          if (_this._shouldUpdateSelector(rule, options)) {\n\t            string = root.toString();\n\t            rule.selector = string;\n\t          }\n\n\t          return {\n\t            transform: transform,\n\t            root: root,\n\t            string: string\n\t          };\n\t        }).then(resolve, reject);\n\t      } catch (e) {\n\t        reject(e);\n\t        return;\n\t      }\n\t    });\n\t  };\n\n\t  _proto._runSync = function _runSync(rule, options) {\n\t    if (options === void 0) {\n\t      options = {};\n\t    }\n\n\t    var root = this._root(rule, options);\n\n\t    var transform = this.func(root);\n\n\t    if (transform && typeof transform.then === \"function\") {\n\t      throw new Error(\"Selector processor returned a promise to a synchronous call.\");\n\t    }\n\n\t    var string = undefined;\n\n\t    if (options.updateSelector && typeof rule !== \"string\") {\n\t      string = root.toString();\n\t      rule.selector = string;\n\t    }\n\n\t    return {\n\t      transform: transform,\n\t      root: root,\n\t      string: string\n\t    };\n\t  }\n\t  /**\n\t   * Process rule into a selector AST.\n\t   *\n\t   * @param rule {postcss.Rule | string} The css selector to be processed\n\t   * @param options The options for processing\n\t   * @returns {Promise<parser.Root>} The AST of the selector after processing it.\n\t   */\n\t  ;\n\n\t  _proto.ast = function ast(rule, options) {\n\t    return this._run(rule, options).then(function (result) {\n\t      return result.root;\n\t    });\n\t  }\n\t  /**\n\t   * Process rule into a selector AST synchronously.\n\t   *\n\t   * @param rule {postcss.Rule | string} The css selector to be processed\n\t   * @param options The options for processing\n\t   * @returns {parser.Root} The AST of the selector after processing it.\n\t   */\n\t  ;\n\n\t  _proto.astSync = function astSync(rule, options) {\n\t    return this._runSync(rule, options).root;\n\t  }\n\t  /**\n\t   * Process a selector into a transformed value asynchronously\n\t   *\n\t   * @param rule {postcss.Rule | string} The css selector to be processed\n\t   * @param options The options for processing\n\t   * @returns {Promise<any>} The value returned by the processor.\n\t   */\n\t  ;\n\n\t  _proto.transform = function transform(rule, options) {\n\t    return this._run(rule, options).then(function (result) {\n\t      return result.transform;\n\t    });\n\t  }\n\t  /**\n\t   * Process a selector into a transformed value synchronously.\n\t   *\n\t   * @param rule {postcss.Rule | string} The css selector to be processed\n\t   * @param options The options for processing\n\t   * @returns {any} The value returned by the processor.\n\t   */\n\t  ;\n\n\t  _proto.transformSync = function transformSync(rule, options) {\n\t    return this._runSync(rule, options).transform;\n\t  }\n\t  /**\n\t   * Process a selector into a new selector string asynchronously.\n\t   *\n\t   * @param rule {postcss.Rule | string} The css selector to be processed\n\t   * @param options The options for processing\n\t   * @returns {string} the selector after processing.\n\t   */\n\t  ;\n\n\t  _proto.process = function process(rule, options) {\n\t    return this._run(rule, options).then(function (result) {\n\t      return result.string || result.root.toString();\n\t    });\n\t  }\n\t  /**\n\t   * Process a selector into a new selector string synchronously.\n\t   *\n\t   * @param rule {postcss.Rule | string} The css selector to be processed\n\t   * @param options The options for processing\n\t   * @returns {string} the selector after processing.\n\t   */\n\t  ;\n\n\t  _proto.processSync = function processSync(rule, options) {\n\t    var result = this._runSync(rule, options);\n\n\t    return result.string || result.root.toString();\n\t  };\n\n\t  return Processor;\n\t}();\n\n\texports[\"default\"] = Processor;\n\tmodule.exports = exports.default;\n} (processor, processor.exports));\n\nvar selectors = {};\n\nvar constructors = {};\n\nconstructors.__esModule = true;\nconstructors.universal = constructors.tag = constructors.string = constructors.selector = constructors.root = constructors.pseudo = constructors.nesting = constructors.id = constructors.comment = constructors.combinator = constructors.className = constructors.attribute = void 0;\n\nvar _attribute = _interopRequireDefault$2(attribute$1);\n\nvar _className = _interopRequireDefault$2(className$1.exports);\n\nvar _combinator = _interopRequireDefault$2(combinator$2.exports);\n\nvar _comment = _interopRequireDefault$2(comment$2.exports);\n\nvar _id = _interopRequireDefault$2(id$1.exports);\n\nvar _nesting = _interopRequireDefault$2(nesting$1.exports);\n\nvar _pseudo = _interopRequireDefault$2(pseudo$1.exports);\n\nvar _root = _interopRequireDefault$2(root$1.exports);\n\nvar _selector = _interopRequireDefault$2(selector$1.exports);\n\nvar _string = _interopRequireDefault$2(string$1.exports);\n\nvar _tag = _interopRequireDefault$2(tag$1.exports);\n\nvar _universal = _interopRequireDefault$2(universal$1.exports);\n\nfunction _interopRequireDefault$2(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar attribute = function attribute(opts) {\n  return new _attribute[\"default\"](opts);\n};\n\nconstructors.attribute = attribute;\n\nvar className = function className(opts) {\n  return new _className[\"default\"](opts);\n};\n\nconstructors.className = className;\n\nvar combinator = function combinator(opts) {\n  return new _combinator[\"default\"](opts);\n};\n\nconstructors.combinator = combinator;\n\nvar comment = function comment(opts) {\n  return new _comment[\"default\"](opts);\n};\n\nconstructors.comment = comment;\n\nvar id = function id(opts) {\n  return new _id[\"default\"](opts);\n};\n\nconstructors.id = id;\n\nvar nesting = function nesting(opts) {\n  return new _nesting[\"default\"](opts);\n};\n\nconstructors.nesting = nesting;\n\nvar pseudo = function pseudo(opts) {\n  return new _pseudo[\"default\"](opts);\n};\n\nconstructors.pseudo = pseudo;\n\nvar root = function root(opts) {\n  return new _root[\"default\"](opts);\n};\n\nconstructors.root = root;\n\nvar selector = function selector(opts) {\n  return new _selector[\"default\"](opts);\n};\n\nconstructors.selector = selector;\n\nvar string = function string(opts) {\n  return new _string[\"default\"](opts);\n};\n\nconstructors.string = string;\n\nvar tag = function tag(opts) {\n  return new _tag[\"default\"](opts);\n};\n\nconstructors.tag = tag;\n\nvar universal = function universal(opts) {\n  return new _universal[\"default\"](opts);\n};\n\nconstructors.universal = universal;\n\nvar guards = {};\n\nguards.__esModule = true;\nguards.isNode = isNode;\nguards.isPseudoElement = isPseudoElement;\nguards.isPseudoClass = isPseudoClass;\nguards.isContainer = isContainer;\nguards.isNamespace = isNamespace;\nguards.isUniversal = guards.isTag = guards.isString = guards.isSelector = guards.isRoot = guards.isPseudo = guards.isNesting = guards.isIdentifier = guards.isComment = guards.isCombinator = guards.isClassName = guards.isAttribute = void 0;\n\nvar _types = types;\n\nvar _IS_TYPE;\n\nvar IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);\n\nfunction isNode(node) {\n  return typeof node === \"object\" && IS_TYPE[node.type];\n}\n\nfunction isNodeType(type, node) {\n  return isNode(node) && node.type === type;\n}\n\nvar isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);\nguards.isAttribute = isAttribute;\nvar isClassName = isNodeType.bind(null, _types.CLASS);\nguards.isClassName = isClassName;\nvar isCombinator = isNodeType.bind(null, _types.COMBINATOR);\nguards.isCombinator = isCombinator;\nvar isComment = isNodeType.bind(null, _types.COMMENT);\nguards.isComment = isComment;\nvar isIdentifier = isNodeType.bind(null, _types.ID);\nguards.isIdentifier = isIdentifier;\nvar isNesting = isNodeType.bind(null, _types.NESTING);\nguards.isNesting = isNesting;\nvar isPseudo = isNodeType.bind(null, _types.PSEUDO);\nguards.isPseudo = isPseudo;\nvar isRoot = isNodeType.bind(null, _types.ROOT);\nguards.isRoot = isRoot;\nvar isSelector = isNodeType.bind(null, _types.SELECTOR);\nguards.isSelector = isSelector;\nvar isString = isNodeType.bind(null, _types.STRING);\nguards.isString = isString;\nvar isTag = isNodeType.bind(null, _types.TAG);\nguards.isTag = isTag;\nvar isUniversal = isNodeType.bind(null, _types.UNIVERSAL);\nguards.isUniversal = isUniversal;\n\nfunction isPseudoElement(node) {\n  return isPseudo(node) && node.value && (node.value.startsWith(\"::\") || node.value.toLowerCase() === \":before\" || node.value.toLowerCase() === \":after\" || node.value.toLowerCase() === \":first-letter\" || node.value.toLowerCase() === \":first-line\");\n}\n\nfunction isPseudoClass(node) {\n  return isPseudo(node) && !isPseudoElement(node);\n}\n\nfunction isContainer(node) {\n  return !!(isNode(node) && node.walk);\n}\n\nfunction isNamespace(node) {\n  return isAttribute(node) || isTag(node);\n}\n\n(function (exports) {\n\n\texports.__esModule = true;\n\n\tvar _types = types;\n\n\tObject.keys(_types).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  if (key in exports && exports[key] === _types[key]) return;\n\t  exports[key] = _types[key];\n\t});\n\n\tvar _constructors = constructors;\n\n\tObject.keys(_constructors).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  if (key in exports && exports[key] === _constructors[key]) return;\n\t  exports[key] = _constructors[key];\n\t});\n\n\tvar _guards = guards;\n\n\tObject.keys(_guards).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  if (key in exports && exports[key] === _guards[key]) return;\n\t  exports[key] = _guards[key];\n\t});\n} (selectors));\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\n\tvar _processor = _interopRequireDefault(processor.exports);\n\n\tvar selectors$1 = _interopRequireWildcard(selectors);\n\n\tfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n\tvar parser = function parser(processor) {\n\t  return new _processor[\"default\"](processor);\n\t};\n\n\tObject.assign(parser, selectors$1);\n\tdelete parser.__esModule;\n\tvar _default = parser;\n\texports[\"default\"] = _default;\n\tmodule.exports = exports.default;\n} (dist, dist.exports));\n\nconst matchValueName = /[$]?[\\w-]+/g;\n\nconst replaceValueSymbols$2 = (value, replacements) => {\n  let matches;\n\n  while ((matches = matchValueName.exec(value))) {\n    const replacement = replacements[matches[0]];\n\n    if (replacement) {\n      value =\n        value.slice(0, matches.index) +\n        replacement +\n        value.slice(matchValueName.lastIndex);\n\n      matchValueName.lastIndex -= matches[0].length - replacement.length;\n    }\n  }\n\n  return value;\n};\n\nvar replaceValueSymbols_1 = replaceValueSymbols$2;\n\nconst replaceValueSymbols$1 = replaceValueSymbols_1;\n\nconst replaceSymbols$1 = (css, replacements) => {\n  css.walk((node) => {\n    if (node.type === \"decl\" && node.value) {\n      node.value = replaceValueSymbols$1(node.value.toString(), replacements);\n    } else if (node.type === \"rule\" && node.selector) {\n      node.selector = replaceValueSymbols$1(\n        node.selector.toString(),\n        replacements\n      );\n    } else if (node.type === \"atrule\" && node.params) {\n      node.params = replaceValueSymbols$1(node.params.toString(), replacements);\n    }\n  });\n};\n\nvar replaceSymbols_1 = replaceSymbols$1;\n\nconst importPattern = /^:import\\((\"[^\"]*\"|'[^']*'|[^\"']+)\\)$/;\nconst balancedQuotes = /^(\"[^\"]*\"|'[^']*'|[^\"']+)$/;\n\nconst getDeclsObject = (rule) => {\n  const object = {};\n\n  rule.walkDecls((decl) => {\n    const before = decl.raws.before ? decl.raws.before.trim() : \"\";\n\n    object[before + decl.prop] = decl.value;\n  });\n\n  return object;\n};\n/**\n *\n * @param {string} css\n * @param {boolean} removeRules\n * @param {'auto' | 'rule' | 'at-rule'} mode\n */\nconst extractICSS$2 = (css, removeRules = true, mode = \"auto\") => {\n  const icssImports = {};\n  const icssExports = {};\n\n  function addImports(node, path) {\n    const unquoted = path.replace(/'|\"/g, \"\");\n    icssImports[unquoted] = Object.assign(\n      icssImports[unquoted] || {},\n      getDeclsObject(node)\n    );\n\n    if (removeRules) {\n      node.remove();\n    }\n  }\n\n  function addExports(node) {\n    Object.assign(icssExports, getDeclsObject(node));\n    if (removeRules) {\n      node.remove();\n    }\n  }\n\n  css.each((node) => {\n    if (node.type === \"rule\" && mode !== \"at-rule\") {\n      if (node.selector.slice(0, 7) === \":import\") {\n        const matches = importPattern.exec(node.selector);\n\n        if (matches) {\n          addImports(node, matches[1]);\n        }\n      }\n\n      if (node.selector === \":export\") {\n        addExports(node);\n      }\n    }\n\n    if (node.type === \"atrule\" && mode !== \"rule\") {\n      if (node.name === \"icss-import\") {\n        const matches = balancedQuotes.exec(node.params);\n\n        if (matches) {\n          addImports(node, matches[1]);\n        }\n      }\n      if (node.name === \"icss-export\") {\n        addExports(node);\n      }\n    }\n  });\n\n  return { icssImports, icssExports };\n};\n\nvar extractICSS_1 = extractICSS$2;\n\nconst createImports = (imports, postcss, mode = \"rule\") => {\n  return Object.keys(imports).map((path) => {\n    const aliases = imports[path];\n    const declarations = Object.keys(aliases).map((key) =>\n      postcss.decl({\n        prop: key,\n        value: aliases[key],\n        raws: { before: \"\\n  \" },\n      })\n    );\n\n    const hasDeclarations = declarations.length > 0;\n\n    const rule =\n      mode === \"rule\"\n        ? postcss.rule({\n            selector: `:import('${path}')`,\n            raws: { after: hasDeclarations ? \"\\n\" : \"\" },\n          })\n        : postcss.atRule({\n            name: \"icss-import\",\n            params: `'${path}'`,\n            raws: { after: hasDeclarations ? \"\\n\" : \"\" },\n          });\n\n    if (hasDeclarations) {\n      rule.append(declarations);\n    }\n\n    return rule;\n  });\n};\n\nconst createExports = (exports, postcss, mode = \"rule\") => {\n  const declarations = Object.keys(exports).map((key) =>\n    postcss.decl({\n      prop: key,\n      value: exports[key],\n      raws: { before: \"\\n  \" },\n    })\n  );\n\n  if (declarations.length === 0) {\n    return [];\n  }\n  const rule =\n    mode === \"rule\"\n      ? postcss.rule({\n          selector: `:export`,\n          raws: { after: \"\\n\" },\n        })\n      : postcss.atRule({\n          name: \"icss-export\",\n          raws: { after: \"\\n\" },\n        });\n\n  rule.append(declarations);\n\n  return [rule];\n};\n\nconst createICSSRules$1 = (imports, exports, postcss, mode) => [\n  ...createImports(imports, postcss, mode),\n  ...createExports(exports, postcss, mode),\n];\n\nvar createICSSRules_1 = createICSSRules$1;\n\nconst replaceValueSymbols = replaceValueSymbols_1;\nconst replaceSymbols = replaceSymbols_1;\nconst extractICSS$1 = extractICSS_1;\nconst createICSSRules = createICSSRules_1;\n\nvar src$3 = {\n  replaceValueSymbols,\n  replaceSymbols,\n  extractICSS: extractICSS$1,\n  createICSSRules,\n};\n\nconst selectorParser$1 = dist.exports;\nconst valueParser = _dep_07a79996_js__WEBPACK_IMPORTED_MODULE_4__.l;\nconst { extractICSS } = src$3;\n\nconst isSpacing = (node) => node.type === \"combinator\" && node.value === \" \";\n\nfunction normalizeNodeArray(nodes) {\n  const array = [];\n\n  nodes.forEach((x) => {\n    if (Array.isArray(x)) {\n      normalizeNodeArray(x).forEach((item) => {\n        array.push(item);\n      });\n    } else if (x) {\n      array.push(x);\n    }\n  });\n\n  if (array.length > 0 && isSpacing(array[array.length - 1])) {\n    array.pop();\n  }\n  return array;\n}\n\nfunction localizeNode(rule, mode, localAliasMap) {\n  const transform = (node, context) => {\n    if (context.ignoreNextSpacing && !isSpacing(node)) {\n      throw new Error(\"Missing whitespace after \" + context.ignoreNextSpacing);\n    }\n\n    if (context.enforceNoSpacing && isSpacing(node)) {\n      throw new Error(\"Missing whitespace before \" + context.enforceNoSpacing);\n    }\n\n    let newNodes;\n\n    switch (node.type) {\n      case \"root\": {\n        let resultingGlobal;\n\n        context.hasPureGlobals = false;\n\n        newNodes = node.nodes.map((n) => {\n          const nContext = {\n            global: context.global,\n            lastWasSpacing: true,\n            hasLocals: false,\n            explicit: false,\n          };\n\n          n = transform(n, nContext);\n\n          if (typeof resultingGlobal === \"undefined\") {\n            resultingGlobal = nContext.global;\n          } else if (resultingGlobal !== nContext.global) {\n            throw new Error(\n              'Inconsistent rule global/local result in rule \"' +\n                node +\n                '\" (multiple selectors must result in the same mode for the rule)'\n            );\n          }\n\n          if (!nContext.hasLocals) {\n            context.hasPureGlobals = true;\n          }\n\n          return n;\n        });\n\n        context.global = resultingGlobal;\n\n        node.nodes = normalizeNodeArray(newNodes);\n        break;\n      }\n      case \"selector\": {\n        newNodes = node.map((childNode) => transform(childNode, context));\n\n        node = node.clone();\n        node.nodes = normalizeNodeArray(newNodes);\n        break;\n      }\n      case \"combinator\": {\n        if (isSpacing(node)) {\n          if (context.ignoreNextSpacing) {\n            context.ignoreNextSpacing = false;\n            context.lastWasSpacing = false;\n            context.enforceNoSpacing = false;\n            return null;\n          }\n          context.lastWasSpacing = true;\n          return node;\n        }\n        break;\n      }\n      case \"pseudo\": {\n        let childContext;\n        const isNested = !!node.length;\n        const isScoped = node.value === \":local\" || node.value === \":global\";\n        const isImportExport =\n          node.value === \":import\" || node.value === \":export\";\n\n        if (isImportExport) {\n          context.hasLocals = true;\n          // :local(.foo)\n        } else if (isNested) {\n          if (isScoped) {\n            if (node.nodes.length === 0) {\n              throw new Error(`${node.value}() can't be empty`);\n            }\n\n            if (context.inside) {\n              throw new Error(\n                `A ${node.value} is not allowed inside of a ${context.inside}(...)`\n              );\n            }\n\n            childContext = {\n              global: node.value === \":global\",\n              inside: node.value,\n              hasLocals: false,\n              explicit: true,\n            };\n\n            newNodes = node\n              .map((childNode) => transform(childNode, childContext))\n              .reduce((acc, next) => acc.concat(next.nodes), []);\n\n            if (newNodes.length) {\n              const { before, after } = node.spaces;\n\n              const first = newNodes[0];\n              const last = newNodes[newNodes.length - 1];\n\n              first.spaces = { before, after: first.spaces.after };\n              last.spaces = { before: last.spaces.before, after };\n            }\n\n            node = newNodes;\n\n            break;\n          } else {\n            childContext = {\n              global: context.global,\n              inside: context.inside,\n              lastWasSpacing: true,\n              hasLocals: false,\n              explicit: context.explicit,\n            };\n            newNodes = node.map((childNode) =>\n              transform(childNode, childContext)\n            );\n\n            node = node.clone();\n            node.nodes = normalizeNodeArray(newNodes);\n\n            if (childContext.hasLocals) {\n              context.hasLocals = true;\n            }\n          }\n          break;\n\n          //:local .foo .bar\n        } else if (isScoped) {\n          if (context.inside) {\n            throw new Error(\n              `A ${node.value} is not allowed inside of a ${context.inside}(...)`\n            );\n          }\n\n          const addBackSpacing = !!node.spaces.before;\n\n          context.ignoreNextSpacing = context.lastWasSpacing\n            ? node.value\n            : false;\n\n          context.enforceNoSpacing = context.lastWasSpacing\n            ? false\n            : node.value;\n\n          context.global = node.value === \":global\";\n          context.explicit = true;\n\n          // because this node has spacing that is lost when we remove it\n          // we make up for it by adding an extra combinator in since adding\n          // spacing on the parent selector doesn't work\n          return addBackSpacing\n            ? selectorParser$1.combinator({ value: \" \" })\n            : null;\n        }\n        break;\n      }\n      case \"id\":\n      case \"class\": {\n        if (!node.value) {\n          throw new Error(\"Invalid class or id selector syntax\");\n        }\n\n        if (context.global) {\n          break;\n        }\n\n        const isImportedValue = localAliasMap.has(node.value);\n        const isImportedWithExplicitScope = isImportedValue && context.explicit;\n\n        if (!isImportedValue || isImportedWithExplicitScope) {\n          const innerNode = node.clone();\n          innerNode.spaces = { before: \"\", after: \"\" };\n\n          node = selectorParser$1.pseudo({\n            value: \":local\",\n            nodes: [innerNode],\n            spaces: node.spaces,\n          });\n\n          context.hasLocals = true;\n        }\n\n        break;\n      }\n    }\n\n    context.lastWasSpacing = false;\n    context.ignoreNextSpacing = false;\n    context.enforceNoSpacing = false;\n\n    return node;\n  };\n\n  const rootContext = {\n    global: mode === \"global\",\n    hasPureGlobals: false,\n  };\n\n  rootContext.selector = selectorParser$1((root) => {\n    transform(root, rootContext);\n  }).processSync(rule, { updateSelector: false, lossless: true });\n\n  return rootContext;\n}\n\nfunction localizeDeclNode(node, context) {\n  switch (node.type) {\n    case \"word\":\n      if (context.localizeNextItem) {\n        if (!context.localAliasMap.has(node.value)) {\n          node.value = \":local(\" + node.value + \")\";\n          context.localizeNextItem = false;\n        }\n      }\n      break;\n\n    case \"function\":\n      if (\n        context.options &&\n        context.options.rewriteUrl &&\n        node.value.toLowerCase() === \"url\"\n      ) {\n        node.nodes.map((nestedNode) => {\n          if (nestedNode.type !== \"string\" && nestedNode.type !== \"word\") {\n            return;\n          }\n\n          let newUrl = context.options.rewriteUrl(\n            context.global,\n            nestedNode.value\n          );\n\n          switch (nestedNode.type) {\n            case \"string\":\n              if (nestedNode.quote === \"'\") {\n                newUrl = newUrl.replace(/(\\\\)/g, \"\\\\$1\").replace(/'/g, \"\\\\'\");\n              }\n\n              if (nestedNode.quote === '\"') {\n                newUrl = newUrl.replace(/(\\\\)/g, \"\\\\$1\").replace(/\"/g, '\\\\\"');\n              }\n\n              break;\n            case \"word\":\n              newUrl = newUrl.replace(/(\"|'|\\)|\\\\)/g, \"\\\\$1\");\n              break;\n          }\n\n          nestedNode.value = newUrl;\n        });\n      }\n      break;\n  }\n  return node;\n}\n\nfunction isWordAFunctionArgument(wordNode, functionNode) {\n  return functionNode\n    ? functionNode.nodes.some(\n        (functionNodeChild) =>\n          functionNodeChild.sourceIndex === wordNode.sourceIndex\n      )\n    : false;\n}\n\nfunction localizeDeclarationValues(localize, declaration, context) {\n  const valueNodes = valueParser(declaration.value);\n\n  valueNodes.walk((node, index, nodes) => {\n    const subContext = {\n      options: context.options,\n      global: context.global,\n      localizeNextItem: localize && !context.global,\n      localAliasMap: context.localAliasMap,\n    };\n    nodes[index] = localizeDeclNode(node, subContext);\n  });\n\n  declaration.value = valueNodes.toString();\n}\n\nfunction localizeDeclaration(declaration, context) {\n  const isAnimation = /animation$/i.test(declaration.prop);\n\n  if (isAnimation) {\n    const validIdent = /^-?[_a-z][_a-z0-9-]*$/i;\n\n    /*\n    The spec defines some keywords that you can use to describe properties such as the timing\n    function. These are still valid animation names, so as long as there is a property that accepts\n    a keyword, it is given priority. Only when all the properties that can take a keyword are\n    exhausted can the animation name be set to the keyword. I.e.\n  \n    animation: infinite infinite;\n  \n    The animation will repeat an infinite number of times from the first argument, and will have an\n    animation name of infinite from the second.\n    */\n    const animationKeywords = {\n      $alternate: 1,\n      \"$alternate-reverse\": 1,\n      $backwards: 1,\n      $both: 1,\n      $ease: 1,\n      \"$ease-in\": 1,\n      \"$ease-in-out\": 1,\n      \"$ease-out\": 1,\n      $forwards: 1,\n      $infinite: 1,\n      $linear: 1,\n      $none: Infinity, // No matter how many times you write none, it will never be an animation name\n      $normal: 1,\n      $paused: 1,\n      $reverse: 1,\n      $running: 1,\n      \"$step-end\": 1,\n      \"$step-start\": 1,\n      $initial: Infinity,\n      $inherit: Infinity,\n      $unset: Infinity,\n    };\n    let parsedAnimationKeywords = {};\n    let stepsFunctionNode = null;\n    const valueNodes = valueParser(declaration.value).walk((node) => {\n      /* If div-token appeared (represents as comma ','), a possibility of an animation-keywords should be reflesh. */\n      if (node.type === \"div\") {\n        parsedAnimationKeywords = {};\n      }\n      if (node.type === \"function\" && node.value.toLowerCase() === \"steps\") {\n        stepsFunctionNode = node;\n      }\n      const value =\n        node.type === \"word\" &&\n        !isWordAFunctionArgument(node, stepsFunctionNode)\n          ? node.value.toLowerCase()\n          : null;\n\n      let shouldParseAnimationName = false;\n\n      if (value && validIdent.test(value)) {\n        if (\"$\" + value in animationKeywords) {\n          parsedAnimationKeywords[\"$\" + value] =\n            \"$\" + value in parsedAnimationKeywords\n              ? parsedAnimationKeywords[\"$\" + value] + 1\n              : 0;\n\n          shouldParseAnimationName =\n            parsedAnimationKeywords[\"$\" + value] >=\n            animationKeywords[\"$\" + value];\n        } else {\n          shouldParseAnimationName = true;\n        }\n      }\n\n      const subContext = {\n        options: context.options,\n        global: context.global,\n        localizeNextItem: shouldParseAnimationName && !context.global,\n        localAliasMap: context.localAliasMap,\n      };\n      return localizeDeclNode(node, subContext);\n    });\n\n    declaration.value = valueNodes.toString();\n\n    return;\n  }\n\n  const isAnimationName = /animation(-name)?$/i.test(declaration.prop);\n\n  if (isAnimationName) {\n    return localizeDeclarationValues(true, declaration, context);\n  }\n\n  const hasUrl = /url\\(/i.test(declaration.value);\n\n  if (hasUrl) {\n    return localizeDeclarationValues(false, declaration, context);\n  }\n}\n\nsrc$4.exports = (options = {}) => {\n  if (\n    options &&\n    options.mode &&\n    options.mode !== \"global\" &&\n    options.mode !== \"local\" &&\n    options.mode !== \"pure\"\n  ) {\n    throw new Error(\n      'options.mode must be either \"global\", \"local\" or \"pure\" (default \"local\")'\n    );\n  }\n\n  const pureMode = options && options.mode === \"pure\";\n  const globalMode = options && options.mode === \"global\";\n\n  return {\n    postcssPlugin: \"postcss-modules-local-by-default\",\n    prepare() {\n      const localAliasMap = new Map();\n\n      return {\n        Once(root) {\n          const { icssImports } = extractICSS(root, false);\n\n          Object.keys(icssImports).forEach((key) => {\n            Object.keys(icssImports[key]).forEach((prop) => {\n              localAliasMap.set(prop, icssImports[key][prop]);\n            });\n          });\n\n          root.walkAtRules((atRule) => {\n            if (/keyframes$/i.test(atRule.name)) {\n              const globalMatch = /^\\s*:global\\s*\\((.+)\\)\\s*$/.exec(\n                atRule.params\n              );\n              const localMatch = /^\\s*:local\\s*\\((.+)\\)\\s*$/.exec(\n                atRule.params\n              );\n\n              let globalKeyframes = globalMode;\n\n              if (globalMatch) {\n                if (pureMode) {\n                  throw atRule.error(\n                    \"@keyframes :global(...) is not allowed in pure mode\"\n                  );\n                }\n                atRule.params = globalMatch[1];\n                globalKeyframes = true;\n              } else if (localMatch) {\n                atRule.params = localMatch[0];\n                globalKeyframes = false;\n              } else if (!globalMode) {\n                if (atRule.params && !localAliasMap.has(atRule.params)) {\n                  atRule.params = \":local(\" + atRule.params + \")\";\n                }\n              }\n\n              atRule.walkDecls((declaration) => {\n                localizeDeclaration(declaration, {\n                  localAliasMap,\n                  options: options,\n                  global: globalKeyframes,\n                });\n              });\n            } else if (atRule.nodes) {\n              atRule.nodes.forEach((declaration) => {\n                if (declaration.type === \"decl\") {\n                  localizeDeclaration(declaration, {\n                    localAliasMap,\n                    options: options,\n                    global: globalMode,\n                  });\n                }\n              });\n            }\n          });\n\n          root.walkRules((rule) => {\n            if (\n              rule.parent &&\n              rule.parent.type === \"atrule\" &&\n              /keyframes$/i.test(rule.parent.name)\n            ) {\n              // ignore keyframe rules\n              return;\n            }\n\n            const context = localizeNode(rule, options.mode, localAliasMap);\n\n            context.options = options;\n            context.localAliasMap = localAliasMap;\n\n            if (pureMode && context.hasPureGlobals) {\n              throw rule.error(\n                'Selector \"' +\n                  rule.selector +\n                  '\" is not pure ' +\n                  \"(pure selectors must contain at least one local class or id)\"\n              );\n            }\n\n            rule.selector = context.selector;\n\n            // Less-syntax mixins parse as rules with no nodes\n            if (rule.nodes) {\n              rule.nodes.forEach((declaration) =>\n                localizeDeclaration(declaration, context)\n              );\n            }\n          });\n        },\n      };\n    },\n  };\n};\nsrc$4.exports.postcss = true;\n\nvar src$2 = {exports: {}};\n\nconst PERMANENT_MARKER = 2;\nconst TEMPORARY_MARKER = 1;\n\nfunction createError(node, graph) {\n  const er = new Error(\"Nondeterministic import's order\");\n\n  const related = graph[node];\n  const relatedNode = related.find(\n    (relatedNode) => graph[relatedNode].indexOf(node) > -1\n  );\n\n  er.nodes = [node, relatedNode];\n\n  return er;\n}\n\nfunction walkGraph(node, graph, state, result, strict) {\n  if (state[node] === PERMANENT_MARKER) {\n    return;\n  }\n\n  if (state[node] === TEMPORARY_MARKER) {\n    if (strict) {\n      return createError(node, graph);\n    }\n\n    return;\n  }\n\n  state[node] = TEMPORARY_MARKER;\n\n  const children = graph[node];\n  const length = children.length;\n\n  for (let i = 0; i < length; ++i) {\n    const error = walkGraph(children[i], graph, state, result, strict);\n\n    if (error instanceof Error) {\n      return error;\n    }\n  }\n\n  state[node] = PERMANENT_MARKER;\n\n  result.push(node);\n}\n\nfunction topologicalSort$1(graph, strict) {\n  const result = [];\n  const state = {};\n\n  const nodes = Object.keys(graph);\n  const length = nodes.length;\n\n  for (let i = 0; i < length; ++i) {\n    const er = walkGraph(nodes[i], graph, state, result, strict);\n\n    if (er instanceof Error) {\n      return er;\n    }\n  }\n\n  return result;\n}\n\nvar topologicalSort_1 = topologicalSort$1;\n\nconst topologicalSort = topologicalSort_1;\n\nconst matchImports$1 = /^(.+?)\\s+from\\s+(?:\"([^\"]+)\"|'([^']+)'|(global))$/;\nconst icssImport = /^:import\\((?:\"([^\"]+)\"|'([^']+)')\\)/;\n\nconst VISITED_MARKER = 1;\n\n/**\n * :import('G') {}\n *\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'B'\n\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'A'\n *   composes: ... from 'C'\n *\n * Results in:\n *\n * graph: {\n *   G: [],\n *   A: [],\n *   B: ['A'],\n *   C: ['A'],\n * }\n */\nfunction addImportToGraph(importId, parentId, graph, visited) {\n  const siblingsId = parentId + \"_\" + \"siblings\";\n  const visitedId = parentId + \"_\" + importId;\n\n  if (visited[visitedId] !== VISITED_MARKER) {\n    if (!Array.isArray(visited[siblingsId])) {\n      visited[siblingsId] = [];\n    }\n\n    const siblings = visited[siblingsId];\n\n    if (Array.isArray(graph[importId])) {\n      graph[importId] = graph[importId].concat(siblings);\n    } else {\n      graph[importId] = siblings.slice();\n    }\n\n    visited[visitedId] = VISITED_MARKER;\n\n    siblings.push(importId);\n  }\n}\n\nsrc$2.exports = (options = {}) => {\n  let importIndex = 0;\n  const createImportedName =\n    typeof options.createImportedName !== \"function\"\n      ? (importName /*, path*/) =>\n          `i__imported_${importName.replace(/\\W/g, \"_\")}_${importIndex++}`\n      : options.createImportedName;\n  const failOnWrongOrder = options.failOnWrongOrder;\n\n  return {\n    postcssPlugin: \"postcss-modules-extract-imports\",\n    prepare() {\n      const graph = {};\n      const visited = {};\n      const existingImports = {};\n      const importDecls = {};\n      const imports = {};\n\n      return {\n        Once(root, postcss) {\n          // Check the existing imports order and save refs\n          root.walkRules((rule) => {\n            const matches = icssImport.exec(rule.selector);\n\n            if (matches) {\n              const [, /*match*/ doubleQuotePath, singleQuotePath] = matches;\n              const importPath = doubleQuotePath || singleQuotePath;\n\n              addImportToGraph(importPath, \"root\", graph, visited);\n\n              existingImports[importPath] = rule;\n            }\n          });\n\n          root.walkDecls(/^composes$/, (declaration) => {\n            const matches = declaration.value.match(matchImports$1);\n\n            if (!matches) {\n              return;\n            }\n\n            let tmpSymbols;\n            let [\n              ,\n              /*match*/ symbols,\n              doubleQuotePath,\n              singleQuotePath,\n              global,\n            ] = matches;\n\n            if (global) {\n              // Composing globals simply means changing these classes to wrap them in global(name)\n              tmpSymbols = symbols.split(/\\s+/).map((s) => `global(${s})`);\n            } else {\n              const importPath = doubleQuotePath || singleQuotePath;\n\n              let parent = declaration.parent;\n              let parentIndexes = \"\";\n\n              while (parent.type !== \"root\") {\n                parentIndexes =\n                  parent.parent.index(parent) + \"_\" + parentIndexes;\n                parent = parent.parent;\n              }\n\n              const { selector } = declaration.parent;\n              const parentRule = `_${parentIndexes}${selector}`;\n\n              addImportToGraph(importPath, parentRule, graph, visited);\n\n              importDecls[importPath] = declaration;\n              imports[importPath] = imports[importPath] || {};\n\n              tmpSymbols = symbols.split(/\\s+/).map((s) => {\n                if (!imports[importPath][s]) {\n                  imports[importPath][s] = createImportedName(s, importPath);\n                }\n\n                return imports[importPath][s];\n              });\n            }\n\n            declaration.value = tmpSymbols.join(\" \");\n          });\n\n          const importsOrder = topologicalSort(graph, failOnWrongOrder);\n\n          if (importsOrder instanceof Error) {\n            const importPath = importsOrder.nodes.find((importPath) =>\n              // eslint-disable-next-line no-prototype-builtins\n              importDecls.hasOwnProperty(importPath)\n            );\n            const decl = importDecls[importPath];\n\n            throw decl.error(\n              \"Failed to resolve order of composed modules \" +\n                importsOrder.nodes\n                  .map((importPath) => \"`\" + importPath + \"`\")\n                  .join(\", \") +\n                \".\",\n              {\n                plugin: \"postcss-modules-extract-imports\",\n                word: \"composes\",\n              }\n            );\n          }\n\n          let lastImportRule;\n\n          importsOrder.forEach((path) => {\n            const importedSymbols = imports[path];\n            let rule = existingImports[path];\n\n            if (!rule && importedSymbols) {\n              rule = postcss.rule({\n                selector: `:import(\"${path}\")`,\n                raws: { after: \"\\n\" },\n              });\n\n              if (lastImportRule) {\n                root.insertAfter(lastImportRule, rule);\n              } else {\n                root.prepend(rule);\n              }\n            }\n\n            lastImportRule = rule;\n\n            if (!importedSymbols) {\n              return;\n            }\n\n            Object.keys(importedSymbols).forEach((importedSymbol) => {\n              rule.append(\n                postcss.decl({\n                  value: importedSymbol,\n                  prop: importedSymbols[importedSymbol],\n                  raws: { before: \"\\n  \" },\n                })\n              );\n            });\n          });\n        },\n      };\n    },\n  };\n};\n\nsrc$2.exports.postcss = true;\n\nconst selectorParser = dist.exports;\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction getSingleLocalNamesForComposes(root) {\n  return root.nodes.map((node) => {\n    if (node.type !== \"selector\" || node.nodes.length !== 1) {\n      throw new Error(\n        `composition is only allowed when selector is single :local class name not in \"${root}\"`\n      );\n    }\n\n    node = node.nodes[0];\n\n    if (\n      node.type !== \"pseudo\" ||\n      node.value !== \":local\" ||\n      node.nodes.length !== 1\n    ) {\n      throw new Error(\n        'composition is only allowed when selector is single :local class name not in \"' +\n          root +\n          '\", \"' +\n          node +\n          '\" is weird'\n      );\n    }\n\n    node = node.first;\n\n    if (node.type !== \"selector\" || node.length !== 1) {\n      throw new Error(\n        'composition is only allowed when selector is single :local class name not in \"' +\n          root +\n          '\", \"' +\n          node +\n          '\" is weird'\n      );\n    }\n\n    node = node.first;\n\n    if (node.type !== \"class\") {\n      // 'id' is not possible, because you can't compose ids\n      throw new Error(\n        'composition is only allowed when selector is single :local class name not in \"' +\n          root +\n          '\", \"' +\n          node +\n          '\" is weird'\n      );\n    }\n\n    return node.value;\n  });\n}\n\nconst whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\";\nconst unescapeRegExp = new RegExp(\n  \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\",\n  \"ig\"\n);\n\nfunction unescape(str) {\n  return str.replace(unescapeRegExp, (_, escaped, escapedWhitespace) => {\n    const high = \"0x\" + escaped - 0x10000;\n\n    // NaN means non-codepoint\n    // Workaround erroneous numeric interpretation of +\"0x\"\n    return high !== high || escapedWhitespace\n      ? escaped\n      : high < 0\n      ? // BMP codepoint\n        String.fromCharCode(high + 0x10000)\n      : // Supplemental Plane codepoint (surrogate pair)\n        String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);\n  });\n}\n\nconst plugin = (options = {}) => {\n  const generateScopedName =\n    (options && options.generateScopedName) || plugin.generateScopedName;\n  const generateExportEntry =\n    (options && options.generateExportEntry) || plugin.generateExportEntry;\n  const exportGlobals = options && options.exportGlobals;\n\n  return {\n    postcssPlugin: \"postcss-modules-scope\",\n    Once(root, { rule }) {\n      const exports = Object.create(null);\n\n      function exportScopedName(name, rawName) {\n        const scopedName = generateScopedName(\n          rawName ? rawName : name,\n          root.source.input.from,\n          root.source.input.css\n        );\n        const exportEntry = generateExportEntry(\n          rawName ? rawName : name,\n          scopedName,\n          root.source.input.from,\n          root.source.input.css\n        );\n        const { key, value } = exportEntry;\n\n        exports[key] = exports[key] || [];\n\n        if (exports[key].indexOf(value) < 0) {\n          exports[key].push(value);\n        }\n\n        return scopedName;\n      }\n\n      function localizeNode(node) {\n        switch (node.type) {\n          case \"selector\":\n            node.nodes = node.map(localizeNode);\n            return node;\n          case \"class\":\n            return selectorParser.className({\n              value: exportScopedName(\n                node.value,\n                node.raws && node.raws.value ? node.raws.value : null\n              ),\n            });\n          case \"id\": {\n            return selectorParser.id({\n              value: exportScopedName(\n                node.value,\n                node.raws && node.raws.value ? node.raws.value : null\n              ),\n            });\n          }\n        }\n\n        throw new Error(\n          `${node.type} (\"${node}\") is not allowed in a :local block`\n        );\n      }\n\n      function traverseNode(node) {\n        switch (node.type) {\n          case \"pseudo\":\n            if (node.value === \":local\") {\n              if (node.nodes.length !== 1) {\n                throw new Error('Unexpected comma (\",\") in :local block');\n              }\n\n              const selector = localizeNode(node.first);\n              // move the spaces that were around the psuedo selector to the first\n              // non-container node\n              selector.first.spaces = node.spaces;\n\n              const nextNode = node.next();\n\n              if (\n                nextNode &&\n                nextNode.type === \"combinator\" &&\n                nextNode.value === \" \" &&\n                /\\\\[A-F0-9]{1,6}$/.test(selector.last.value)\n              ) {\n                selector.last.spaces.after = \" \";\n              }\n\n              node.replaceWith(selector);\n\n              return;\n            }\n          /* falls through */\n          case \"root\":\n          case \"selector\": {\n            node.each(traverseNode);\n            break;\n          }\n          case \"id\":\n          case \"class\":\n            if (exportGlobals) {\n              exports[node.value] = [node.value];\n            }\n            break;\n        }\n        return node;\n      }\n\n      // Find any :import and remember imported names\n      const importedNames = {};\n\n      root.walkRules(/^:import\\(.+\\)$/, (rule) => {\n        rule.walkDecls((decl) => {\n          importedNames[decl.prop] = true;\n        });\n      });\n\n      // Find any :local selectors\n      root.walkRules((rule) => {\n        let parsedSelector = selectorParser().astSync(rule);\n\n        rule.selector = traverseNode(parsedSelector.clone()).toString();\n\n        rule.walkDecls(/composes|compose-with/i, (decl) => {\n          const localNames = getSingleLocalNamesForComposes(parsedSelector);\n          const classes = decl.value.split(/\\s+/);\n\n          classes.forEach((className) => {\n            const global = /^global\\(([^)]+)\\)$/.exec(className);\n\n            if (global) {\n              localNames.forEach((exportedName) => {\n                exports[exportedName].push(global[1]);\n              });\n            } else if (hasOwnProperty.call(importedNames, className)) {\n              localNames.forEach((exportedName) => {\n                exports[exportedName].push(className);\n              });\n            } else if (hasOwnProperty.call(exports, className)) {\n              localNames.forEach((exportedName) => {\n                exports[className].forEach((item) => {\n                  exports[exportedName].push(item);\n                });\n              });\n            } else {\n              throw decl.error(\n                `referenced class name \"${className}\" in ${decl.prop} not found`\n              );\n            }\n          });\n\n          decl.remove();\n        });\n\n        // Find any :local values\n        rule.walkDecls((decl) => {\n          if (!/:local\\s*\\((.+?)\\)/.test(decl.value)) {\n            return;\n          }\n\n          let tokens = decl.value.split(/(,|'[^']*'|\"[^\"]*\")/);\n\n          tokens = tokens.map((token, idx) => {\n            if (idx === 0 || tokens[idx - 1] === \",\") {\n              let result = token;\n\n              const localMatch = /:local\\s*\\((.+?)\\)/.exec(token);\n\n              if (localMatch) {\n                const input = localMatch.input;\n                const matchPattern = localMatch[0];\n                const matchVal = localMatch[1];\n                const newVal = exportScopedName(matchVal);\n\n                result = input.replace(matchPattern, newVal);\n              } else {\n                return token;\n              }\n\n              return result;\n            } else {\n              return token;\n            }\n          });\n\n          decl.value = tokens.join(\"\");\n        });\n      });\n\n      // Find any :local keyframes\n      root.walkAtRules(/keyframes$/i, (atRule) => {\n        const localMatch = /^\\s*:local\\s*\\((.+?)\\)\\s*$/.exec(atRule.params);\n\n        if (!localMatch) {\n          return;\n        }\n\n        atRule.params = exportScopedName(localMatch[1]);\n      });\n\n      // If we found any :locals, insert an :export rule\n      const exportedNames = Object.keys(exports);\n\n      if (exportedNames.length > 0) {\n        const exportRule = rule({ selector: \":export\" });\n\n        exportedNames.forEach((exportedName) =>\n          exportRule.append({\n            prop: exportedName,\n            value: exports[exportedName].join(\" \"),\n            raws: { before: \"\\n  \" },\n          })\n        );\n\n        root.append(exportRule);\n      }\n    },\n  };\n};\n\nplugin.postcss = true;\n\nplugin.generateScopedName = function (name, path) {\n  const sanitisedPath = path\n    .replace(/\\.[^./\\\\]+$/, \"\")\n    .replace(/[\\W_]+/g, \"_\")\n    .replace(/^_|_$/g, \"\");\n\n  return `_${sanitisedPath}__${name}`.trim();\n};\n\nplugin.generateExportEntry = function (name, scopedName) {\n  return {\n    key: unescape(name),\n    value: unescape(scopedName),\n  };\n};\n\nvar src$1 = plugin;\n\nvar src = {exports: {}};\n\nconst ICSSUtils = src$3;\n\nconst matchImports = /^(.+?|\\([\\s\\S]+?\\))\\s+from\\s+(\"[^\"]*\"|'[^']*'|[\\w-]+)$/;\nconst matchValueDefinition = /(?:\\s+|^)([\\w-]+):?(.*?)$/;\nconst matchImport = /^([\\w-]+)(?:\\s+as\\s+([\\w-]+))?/;\n\nsrc.exports = (options) => {\n  let importIndex = 0;\n  const createImportedName =\n    (options && options.createImportedName) ||\n    ((importName /*, path*/) =>\n      `i__const_${importName.replace(/\\W/g, \"_\")}_${importIndex++}`);\n\n  return {\n    postcssPlugin: \"postcss-modules-values\",\n    prepare(result) {\n      const importAliases = [];\n      const definitions = {};\n\n      return {\n        Once(root, postcss) {\n          root.walkAtRules(/value/i, (atRule) => {\n            const matches = atRule.params.match(matchImports);\n\n            if (matches) {\n              let [, /*match*/ aliases, path] = matches;\n\n              // We can use constants for path names\n              if (definitions[path]) {\n                path = definitions[path];\n              }\n\n              const imports = aliases\n                .replace(/^\\(\\s*([\\s\\S]+)\\s*\\)$/, \"$1\")\n                .split(/\\s*,\\s*/)\n                .map((alias) => {\n                  const tokens = matchImport.exec(alias);\n\n                  if (tokens) {\n                    const [, /*match*/ theirName, myName = theirName] = tokens;\n                    const importedName = createImportedName(myName);\n                    definitions[myName] = importedName;\n                    return { theirName, importedName };\n                  } else {\n                    throw new Error(`@import statement \"${alias}\" is invalid!`);\n                  }\n                });\n\n              importAliases.push({ path, imports });\n\n              atRule.remove();\n\n              return;\n            }\n\n            if (atRule.params.indexOf(\"@value\") !== -1) {\n              result.warn(\"Invalid value definition: \" + atRule.params);\n            }\n\n            let [, key, value] = `${atRule.params}${atRule.raws.between}`.match(\n              matchValueDefinition\n            );\n\n            const normalizedValue = value.replace(/\\/\\*((?!\\*\\/).*?)\\*\\//g, \"\");\n\n            if (normalizedValue.length === 0) {\n              result.warn(\"Invalid value definition: \" + atRule.params);\n              atRule.remove();\n\n              return;\n            }\n\n            let isOnlySpace = /^\\s+$/.test(normalizedValue);\n\n            if (!isOnlySpace) {\n              value = value.trim();\n            }\n\n            // Add to the definitions, knowing that values can refer to each other\n            definitions[key] = ICSSUtils.replaceValueSymbols(\n              value,\n              definitions\n            );\n\n            atRule.remove();\n          });\n\n          /* If we have no definitions, don't continue */\n          if (!Object.keys(definitions).length) {\n            return;\n          }\n\n          /* Perform replacements */\n          ICSSUtils.replaceSymbols(root, definitions);\n\n          /* We want to export anything defined by now, but don't add it to the CSS yet or it well get picked up by the replacement stuff */\n          const exportDeclarations = Object.keys(definitions).map((key) =>\n            postcss.decl({\n              value: definitions[key],\n              prop: key,\n              raws: { before: \"\\n  \" },\n            })\n          );\n\n          /* Add export rules if any */\n          if (exportDeclarations.length > 0) {\n            const exportRule = postcss.rule({\n              selector: \":export\",\n              raws: { after: \"\\n\" },\n            });\n\n            exportRule.append(exportDeclarations);\n\n            root.prepend(exportRule);\n          }\n\n          /* Add import rules */\n          importAliases.reverse().forEach(({ path, imports }) => {\n            const importRule = postcss.rule({\n              selector: `:import(${path})`,\n              raws: { after: \"\\n\" },\n            });\n\n            imports.forEach(({ theirName, importedName }) => {\n              importRule.append({\n                value: theirName,\n                prop: importedName,\n                raws: { before: \"\\n  \" },\n              });\n            });\n\n            root.prepend(importRule);\n          });\n        },\n      };\n    },\n  };\n};\n\nsrc.exports.postcss = true;\n\nObject.defineProperty(behaviours$1, \"__esModule\", {\n  value: true\n});\nbehaviours$1.behaviours = void 0;\nbehaviours$1.getDefaultPlugins = getDefaultPlugins;\nbehaviours$1.isValidBehaviour = isValidBehaviour;\n\nvar _postcssModulesLocalByDefault = _interopRequireDefault$1(src$4.exports);\n\nvar _postcssModulesExtractImports = _interopRequireDefault$1(src$2.exports);\n\nvar _postcssModulesScope = _interopRequireDefault$1(src$1);\n\nvar _postcssModulesValues = _interopRequireDefault$1(src.exports);\n\nfunction _interopRequireDefault$1(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst behaviours = {\n  LOCAL: \"local\",\n  GLOBAL: \"global\"\n};\nbehaviours$1.behaviours = behaviours;\n\nfunction getDefaultPlugins({\n  behaviour,\n  generateScopedName,\n  exportGlobals\n}) {\n  const scope = (0, _postcssModulesScope.default)({\n    generateScopedName,\n    exportGlobals\n  });\n  const plugins = {\n    [behaviours.LOCAL]: [_postcssModulesValues.default, (0, _postcssModulesLocalByDefault.default)({\n      mode: 'local'\n    }), _postcssModulesExtractImports.default, scope],\n    [behaviours.GLOBAL]: [_postcssModulesValues.default, (0, _postcssModulesLocalByDefault.default)({\n      mode: 'global'\n    }), _postcssModulesExtractImports.default, scope]\n  };\n  return plugins[behaviour];\n}\n\nfunction isValidBehaviour(behaviour) {\n  return Object.keys(behaviours).map(key => behaviours[key]).indexOf(behaviour) > -1;\n}\n\nvar _postcss = _interopRequireDefault(postcss__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\nvar _lodash = _interopRequireDefault(lodash_camelcase);\n\nvar _genericNames = _interopRequireDefault(genericNames);\n\nvar _unquote = _interopRequireDefault(unquote$1);\n\nvar _parser = _interopRequireDefault(parser$1);\n\nvar _loader = _interopRequireDefault(loader);\n\nvar _generateScopedName = _interopRequireDefault(generateScopedName$1);\n\nvar _saveJSON = _interopRequireDefault(saveJSON$1);\n\nvar _behaviours = behaviours$1;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst PLUGIN_NAME = \"postcss-modules\";\n\nfunction getDefaultScopeBehaviour(opts) {\n  if (opts.scopeBehaviour && (0, _behaviours.isValidBehaviour)(opts.scopeBehaviour)) {\n    return opts.scopeBehaviour;\n  }\n\n  return _behaviours.behaviours.LOCAL;\n}\n\nfunction getScopedNameGenerator(opts) {\n  const scopedNameGenerator = opts.generateScopedName || _generateScopedName.default;\n  if (typeof scopedNameGenerator === \"function\") return scopedNameGenerator;\n  return (0, _genericNames.default)(scopedNameGenerator, {\n    context: process.cwd(),\n    hashPrefix: opts.hashPrefix\n  });\n}\n\nfunction getLoader(opts, plugins) {\n  const root = typeof opts.root === \"undefined\" ? \"/\" : opts.root;\n  return typeof opts.Loader === \"function\" ? new opts.Loader(root, plugins) : new _loader.default(root, plugins);\n}\n\nfunction isGlobalModule(globalModules, inputFile) {\n  return globalModules.some(regex => inputFile.match(regex));\n}\n\nfunction getDefaultPluginsList(opts, inputFile) {\n  const globalModulesList = opts.globalModulePaths || null;\n  const exportGlobals = opts.exportGlobals || false;\n  const defaultBehaviour = getDefaultScopeBehaviour(opts);\n  const generateScopedName = getScopedNameGenerator(opts);\n\n  if (globalModulesList && isGlobalModule(globalModulesList, inputFile)) {\n    return (0, _behaviours.getDefaultPlugins)({\n      behaviour: _behaviours.behaviours.GLOBAL,\n      generateScopedName,\n      exportGlobals\n    });\n  }\n\n  return (0, _behaviours.getDefaultPlugins)({\n    behaviour: defaultBehaviour,\n    generateScopedName,\n    exportGlobals\n  });\n}\n\nfunction isOurPlugin(plugin) {\n  return plugin.postcssPlugin === PLUGIN_NAME;\n}\n\nfunction dashesCamelCase(string) {\n  return string.replace(/-+(\\w)/g, (_, firstLetter) => firstLetter.toUpperCase());\n}\n\nbuild.exports = (opts = {}) => {\n  return {\n    postcssPlugin: PLUGIN_NAME,\n\n    async OnceExit(css, {\n      result\n    }) {\n      const getJSON = opts.getJSON || _saveJSON.default;\n      const inputFile = css.source.input.file;\n      const pluginList = getDefaultPluginsList(opts, inputFile);\n      const resultPluginIndex = result.processor.plugins.findIndex(plugin => isOurPlugin(plugin));\n\n      if (resultPluginIndex === -1) {\n        throw new Error('Plugin missing from options.');\n      }\n\n      const earlierPlugins = result.processor.plugins.slice(0, resultPluginIndex);\n      const loaderPlugins = [...earlierPlugins, ...pluginList];\n      const loader = getLoader(opts, loaderPlugins);\n\n      const fetcher = (file, relativeTo, depTrace) => {\n        const unquoteFile = (0, _unquote.default)(file);\n        const resolvedResult = typeof opts.resolve === 'function' && opts.resolve(unquoteFile);\n        const resolvedFile = resolvedResult instanceof Promise ? resolvedResult : Promise.resolve(resolvedResult);\n        return resolvedFile.then(f => {\n          return loader.fetch.call(loader, `\"${f || unquoteFile}\"`, relativeTo, depTrace);\n        });\n      };\n\n      const parser = new _parser.default(fetcher);\n      await (0, _postcss.default)([...pluginList, parser.plugin()]).process(css, {\n        from: inputFile\n      });\n      const out = loader.finalSource;\n      if (out) css.prepend(out);\n\n      if (opts.localsConvention) {\n        const isFunc = typeof opts.localsConvention === \"function\";\n        parser.exportTokens = Object.entries(parser.exportTokens).reduce((tokens, [className, value]) => {\n          if (isFunc) {\n            tokens[opts.localsConvention(className, value, inputFile)] = value;\n            return tokens;\n          }\n\n          switch (opts.localsConvention) {\n            case \"camelCase\":\n              tokens[className] = value;\n              tokens[(0, _lodash.default)(className)] = value;\n              break;\n\n            case \"camelCaseOnly\":\n              tokens[(0, _lodash.default)(className)] = value;\n              break;\n\n            case \"dashes\":\n              tokens[className] = value;\n              tokens[dashesCamelCase(className)] = value;\n              break;\n\n            case \"dashesOnly\":\n              tokens[dashesCamelCase(className)] = value;\n              break;\n          }\n\n          return tokens;\n        }, {});\n      }\n\n      result.messages.push({\n        type: \"export\",\n        plugin: \"postcss-modules\",\n        exportTokens: parser.exportTokens\n      }); // getJSON may return a promise\n\n      return getJSON(css.source.input.file, parser.exportTokens, result.opts.to);\n    }\n\n  };\n};\n\nvar postcss = build.exports.postcss = true;\n\nvar index = /*#__PURE__*/_mergeNamespaces({\n  __proto__: null,\n  postcss: postcss,\n  'default': build.exports\n}, [build.exports]);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdml0ZS9kaXN0L25vZGUvY2h1bmtzL2RlcC03NTkxNDY0YS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQW1DO0FBQ3FCO0FBQzFCO0FBQ0U7QUFDSztBQUNMO0FBQ2U7O0FBRWlCO0FBQ1g7QUFDYzs7QUFFbkUsbUJBQW1CLHVEQUFtQixDQUFDLDZGQUFlO0FBQ3RELGtCQUFrQixrREFBYTtBQUMvQixnQkFBZ0IsMERBQW1CLENBQUMsNkZBQWU7QUFDbkQ7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxFQUFFO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLEdBQUc7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOEVBQThFLDRCQUE0QjtBQUMxRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEdBQUc7QUFDakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxPQUFPLHFFQUFxRTtBQUM1RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsUUFBUTtBQUNSLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTSxHQUFHOztBQUVULDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7OztBQUd4QztBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHdDQUF3Qyx1Q0FBdUM7O0FBRS9FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDLHVDQUF1Qzs7QUFFaEY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUcsc0JBQXNCLHVDQUF1Qzs7QUFFaEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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OztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdml0ZS9kaXN0L25vZGUvY2h1bmtzL2RlcC03NTkxNDY0YS5qcz9kOTg3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCByZXF1aXJlJCQwJDEgZnJvbSAncG9zdGNzcyc7XG5pbXBvcnQgeyBBIGFzIGNvbW1vbmpzR2xvYmFsIH0gZnJvbSAnLi9kZXAtNTFjNGY4MGEuanMnO1xuaW1wb3J0IHJlcXVpcmUkJDAgZnJvbSAncGF0aCc7XG5pbXBvcnQgcmVxdWlyZSQkNSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHJlcXVpcmUkJDBfX2RlZmF1bHQgZnJvbSAnZnMnO1xuaW1wb3J0IHJlcXVpcmUkJDAkMiBmcm9tICd1dGlsJztcbmltcG9ydCB7IGwgYXMgbGliJDEgfSBmcm9tICcuL2RlcC0wN2E3OTk5Ni5qcyc7XG5cbmltcG9ydCB7IGZpbGVVUkxUb1BhdGggYXMgX19janNfZmlsZVVSTFRvUGF0aCB9IGZyb20gJ25vZGU6dXJsJztcbmltcG9ydCB7IGRpcm5hbWUgYXMgX19janNfZGlybmFtZSB9IGZyb20gJ25vZGU6cGF0aCc7XG5pbXBvcnQgeyBjcmVhdGVSZXF1aXJlIGFzIF9fY2pzX2NyZWF0ZVJlcXVpcmUgfSBmcm9tICdub2RlOm1vZHVsZSc7XG5cbmNvbnN0IF9fZmlsZW5hbWUgPSBfX2Nqc19maWxlVVJMVG9QYXRoKGltcG9ydC5tZXRhLnVybCk7XG5jb25zdCBfX2Rpcm5hbWUgPSBfX2Nqc19kaXJuYW1lKF9fZmlsZW5hbWUpO1xuY29uc3QgcmVxdWlyZSA9IF9fY2pzX2NyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKTtcbmNvbnN0IF9fcmVxdWlyZSA9IHJlcXVpcmU7XG5mdW5jdGlvbiBfbWVyZ2VOYW1lc3BhY2VzKG4sIG0pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGUgPSBtW2ldO1xuICAgIGlmICh0eXBlb2YgZSAhPT0gJ3N0cmluZycgJiYgIUFycmF5LmlzQXJyYXkoZSkpIHsgZm9yICh2YXIgayBpbiBlKSB7XG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnICYmICEoayBpbiBuKSkge1xuICAgICAgICBuW2tdID0gZVtrXTtcbiAgICAgIH1cbiAgICB9IH1cbiAgfVxuICByZXR1cm4gbjtcbn1cblxudmFyIGJ1aWxkID0ge2V4cG9ydHM6IHt9fTtcblxuLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggd29yZHMgY29tcG9zZWQgb2YgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuICovXG52YXIgcmVBc2NpaVdvcmQgPSAvW15cXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3Zl0rL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIExhdGluIFVuaWNvZGUgbGV0dGVycyAoZXhjbHVkaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRvcnMpLiAqL1xudmFyIHJlTGF0aW4gPSAvW1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHhmZlxcdTAxMDAtXFx1MDE3Zl0vZztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZlxcXFx1ZmUyMC1cXFxcdWZlMjMnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmMCcsXG4gICAgcnNEaW5nYmF0UmFuZ2UgPSAnXFxcXHUyNzAwLVxcXFx1MjdiZicsXG4gICAgcnNMb3dlclJhbmdlID0gJ2EtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZicsXG4gICAgcnNNYXRoT3BSYW5nZSA9ICdcXFxceGFjXFxcXHhiMVxcXFx4ZDdcXFxceGY3JyxcbiAgICByc05vbkNoYXJSYW5nZSA9ICdcXFxceDAwLVxcXFx4MmZcXFxceDNhLVxcXFx4NDBcXFxceDViLVxcXFx4NjBcXFxceDdiLVxcXFx4YmYnLFxuICAgIHJzUHVuY3R1YXRpb25SYW5nZSA9ICdcXFxcdTIwMDAtXFxcXHUyMDZmJyxcbiAgICByc1NwYWNlUmFuZ2UgPSAnIFxcXFx0XFxcXHgwYlxcXFxmXFxcXHhhMFxcXFx1ZmVmZlxcXFxuXFxcXHJcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdTE2ODBcXFxcdTE4MGVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMGFcXFxcdTIwMmZcXFxcdTIwNWZcXFxcdTMwMDAnLFxuICAgIHJzVXBwZXJSYW5nZSA9ICdBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGUnLFxuICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJyxcbiAgICByc0JyZWFrUmFuZ2UgPSByc01hdGhPcFJhbmdlICsgcnNOb25DaGFyUmFuZ2UgKyByc1B1bmN0dWF0aW9uUmFuZ2UgKyByc1NwYWNlUmFuZ2U7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0Fwb3MgPSBcIlsnXFx1MjAxOV1cIixcbiAgICByc0FzdHJhbCA9ICdbJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNCcmVhayA9ICdbJyArIHJzQnJlYWtSYW5nZSArICddJyxcbiAgICByc0NvbWJvID0gJ1snICsgcnNDb21ib01hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlICsgJ10nLFxuICAgIHJzRGlnaXRzID0gJ1xcXFxkKycsXG4gICAgcnNEaW5nYmF0ID0gJ1snICsgcnNEaW5nYmF0UmFuZ2UgKyAnXScsXG4gICAgcnNMb3dlciA9ICdbJyArIHJzTG93ZXJSYW5nZSArICddJyxcbiAgICByc01pc2MgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArIHJzQnJlYWtSYW5nZSArIHJzRGlnaXRzICsgcnNEaW5nYmF0UmFuZ2UgKyByc0xvd2VyUmFuZ2UgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJyxcbiAgICByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgIHJzVXBwZXIgPSAnWycgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG52YXIgcnNMb3dlck1pc2MgPSAnKD86JyArIHJzTG93ZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgcnNVcHBlck1pc2MgPSAnKD86JyArIHJzVXBwZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgcnNPcHRMb3dlckNvbnRyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86ZHxsbHxtfHJlfHN8dHx2ZSkpPycsXG4gICAgcnNPcHRVcHBlckNvbnRyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86RHxMTHxNfFJFfFN8VHxWRSkpPycsXG4gICAgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSArICddPycsXG4gICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcbiAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgcnNFbW9qaSA9ICcoPzonICsgW3JzRGluZ2JhdCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNTZXEsXG4gICAgcnNTeW1ib2wgPSAnKD86JyArIFtyc05vbkFzdHJhbCArIHJzQ29tYm8gKyAnPycsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JykgKyAnKSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGFwb3N0cm9waGVzLiAqL1xudmFyIHJlQXBvcyA9IFJlZ0V4cChyc0Fwb3MsICdnJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpIGFuZFxuICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrcyBmb3Igc3ltYm9sc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzX2Zvcl9TeW1ib2xzKS5cbiAqL1xudmFyIHJlQ29tYm9NYXJrID0gUmVnRXhwKHJzQ29tYm8sICdnJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXG52YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArICcoPz0nICsgcnNGaXR6ICsgJyl8JyArIHJzU3ltYm9sICsgcnNTZXEsICdnJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGNvbXBsZXggb3IgY29tcG91bmQgd29yZHMuICovXG52YXIgcmVVbmljb2RlV29yZCA9IFJlZ0V4cChbXG4gIHJzVXBwZXIgKyAnPycgKyByc0xvd2VyICsgJysnICsgcnNPcHRMb3dlckNvbnRyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gIHJzVXBwZXJNaXNjICsgJysnICsgcnNPcHRVcHBlckNvbnRyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciArIHJzTG93ZXJNaXNjLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgcnNVcHBlciArICc/JyArIHJzTG93ZXJNaXNjICsgJysnICsgcnNPcHRMb3dlckNvbnRyLFxuICByc1VwcGVyICsgJysnICsgcnNPcHRVcHBlckNvbnRyLFxuICByc0RpZ2l0cyxcbiAgcnNFbW9qaVxuXS5qb2luKCd8JyksICdnJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHdpdGggW3plcm8td2lkdGggam9pbmVycyBvciBjb2RlIHBvaW50cyBmcm9tIHRoZSBhc3RyYWwgcGxhbmVzXShodHRwOi8vZWV2LmVlL2Jsb2cvMjAxNS8wOS8xMi9kYXJrLWNvcm5lcnMtb2YtdW5pY29kZS8pLiAqL1xudmFyIHJlSGFzVW5pY29kZSA9IFJlZ0V4cCgnWycgKyByc1pXSiArIHJzQXN0cmFsUmFuZ2UgICsgcnNDb21ib01hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlICsgcnNWYXJSYW5nZSArICddJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHRoYXQgbmVlZCBhIG1vcmUgcm9idXN0IHJlZ2V4cCB0byBtYXRjaCB3b3Jkcy4gKi9cbnZhciByZUhhc1VuaWNvZGVXb3JkID0gL1thLXpdW0EtWl18W0EtWl17Mix9W2Etel18WzAtOV1bYS16QS1aXXxbYS16QS1aXVswLTldfFteYS16QS1aMC05IF0vO1xuXG4vKiogVXNlZCB0byBtYXAgTGF0aW4gVW5pY29kZSBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuICovXG52YXIgZGVidXJyZWRMZXR0ZXJzID0ge1xuICAvLyBMYXRpbi0xIFN1cHBsZW1lbnQgYmxvY2suXG4gICdcXHhjMCc6ICdBJywgICdcXHhjMSc6ICdBJywgJ1xceGMyJzogJ0EnLCAnXFx4YzMnOiAnQScsICdcXHhjNCc6ICdBJywgJ1xceGM1JzogJ0EnLFxuICAnXFx4ZTAnOiAnYScsICAnXFx4ZTEnOiAnYScsICdcXHhlMic6ICdhJywgJ1xceGUzJzogJ2EnLCAnXFx4ZTQnOiAnYScsICdcXHhlNSc6ICdhJyxcbiAgJ1xceGM3JzogJ0MnLCAgJ1xceGU3JzogJ2MnLFxuICAnXFx4ZDAnOiAnRCcsICAnXFx4ZjAnOiAnZCcsXG4gICdcXHhjOCc6ICdFJywgICdcXHhjOSc6ICdFJywgJ1xceGNhJzogJ0UnLCAnXFx4Y2InOiAnRScsXG4gICdcXHhlOCc6ICdlJywgICdcXHhlOSc6ICdlJywgJ1xceGVhJzogJ2UnLCAnXFx4ZWInOiAnZScsXG4gICdcXHhjYyc6ICdJJywgICdcXHhjZCc6ICdJJywgJ1xceGNlJzogJ0knLCAnXFx4Y2YnOiAnSScsXG4gICdcXHhlYyc6ICdpJywgICdcXHhlZCc6ICdpJywgJ1xceGVlJzogJ2knLCAnXFx4ZWYnOiAnaScsXG4gICdcXHhkMSc6ICdOJywgICdcXHhmMSc6ICduJyxcbiAgJ1xceGQyJzogJ08nLCAgJ1xceGQzJzogJ08nLCAnXFx4ZDQnOiAnTycsICdcXHhkNSc6ICdPJywgJ1xceGQ2JzogJ08nLCAnXFx4ZDgnOiAnTycsXG4gICdcXHhmMic6ICdvJywgICdcXHhmMyc6ICdvJywgJ1xceGY0JzogJ28nLCAnXFx4ZjUnOiAnbycsICdcXHhmNic6ICdvJywgJ1xceGY4JzogJ28nLFxuICAnXFx4ZDknOiAnVScsICAnXFx4ZGEnOiAnVScsICdcXHhkYic6ICdVJywgJ1xceGRjJzogJ1UnLFxuICAnXFx4ZjknOiAndScsICAnXFx4ZmEnOiAndScsICdcXHhmYic6ICd1JywgJ1xceGZjJzogJ3UnLFxuICAnXFx4ZGQnOiAnWScsICAnXFx4ZmQnOiAneScsICdcXHhmZic6ICd5JyxcbiAgJ1xceGM2JzogJ0FlJywgJ1xceGU2JzogJ2FlJyxcbiAgJ1xceGRlJzogJ1RoJywgJ1xceGZlJzogJ3RoJyxcbiAgJ1xceGRmJzogJ3NzJyxcbiAgLy8gTGF0aW4gRXh0ZW5kZWQtQSBibG9jay5cbiAgJ1xcdTAxMDAnOiAnQScsICAnXFx1MDEwMic6ICdBJywgJ1xcdTAxMDQnOiAnQScsXG4gICdcXHUwMTAxJzogJ2EnLCAgJ1xcdTAxMDMnOiAnYScsICdcXHUwMTA1JzogJ2EnLFxuICAnXFx1MDEwNic6ICdDJywgICdcXHUwMTA4JzogJ0MnLCAnXFx1MDEwYSc6ICdDJywgJ1xcdTAxMGMnOiAnQycsXG4gICdcXHUwMTA3JzogJ2MnLCAgJ1xcdTAxMDknOiAnYycsICdcXHUwMTBiJzogJ2MnLCAnXFx1MDEwZCc6ICdjJyxcbiAgJ1xcdTAxMGUnOiAnRCcsICAnXFx1MDExMCc6ICdEJywgJ1xcdTAxMGYnOiAnZCcsICdcXHUwMTExJzogJ2QnLFxuICAnXFx1MDExMic6ICdFJywgICdcXHUwMTE0JzogJ0UnLCAnXFx1MDExNic6ICdFJywgJ1xcdTAxMTgnOiAnRScsICdcXHUwMTFhJzogJ0UnLFxuICAnXFx1MDExMyc6ICdlJywgICdcXHUwMTE1JzogJ2UnLCAnXFx1MDExNyc6ICdlJywgJ1xcdTAxMTknOiAnZScsICdcXHUwMTFiJzogJ2UnLFxuICAnXFx1MDExYyc6ICdHJywgICdcXHUwMTFlJzogJ0cnLCAnXFx1MDEyMCc6ICdHJywgJ1xcdTAxMjInOiAnRycsXG4gICdcXHUwMTFkJzogJ2cnLCAgJ1xcdTAxMWYnOiAnZycsICdcXHUwMTIxJzogJ2cnLCAnXFx1MDEyMyc6ICdnJyxcbiAgJ1xcdTAxMjQnOiAnSCcsICAnXFx1MDEyNic6ICdIJywgJ1xcdTAxMjUnOiAnaCcsICdcXHUwMTI3JzogJ2gnLFxuICAnXFx1MDEyOCc6ICdJJywgICdcXHUwMTJhJzogJ0knLCAnXFx1MDEyYyc6ICdJJywgJ1xcdTAxMmUnOiAnSScsICdcXHUwMTMwJzogJ0knLFxuICAnXFx1MDEyOSc6ICdpJywgICdcXHUwMTJiJzogJ2knLCAnXFx1MDEyZCc6ICdpJywgJ1xcdTAxMmYnOiAnaScsICdcXHUwMTMxJzogJ2knLFxuICAnXFx1MDEzNCc6ICdKJywgICdcXHUwMTM1JzogJ2onLFxuICAnXFx1MDEzNic6ICdLJywgICdcXHUwMTM3JzogJ2snLCAnXFx1MDEzOCc6ICdrJyxcbiAgJ1xcdTAxMzknOiAnTCcsICAnXFx1MDEzYic6ICdMJywgJ1xcdTAxM2QnOiAnTCcsICdcXHUwMTNmJzogJ0wnLCAnXFx1MDE0MSc6ICdMJyxcbiAgJ1xcdTAxM2EnOiAnbCcsICAnXFx1MDEzYyc6ICdsJywgJ1xcdTAxM2UnOiAnbCcsICdcXHUwMTQwJzogJ2wnLCAnXFx1MDE0Mic6ICdsJyxcbiAgJ1xcdTAxNDMnOiAnTicsICAnXFx1MDE0NSc6ICdOJywgJ1xcdTAxNDcnOiAnTicsICdcXHUwMTRhJzogJ04nLFxuICAnXFx1MDE0NCc6ICduJywgICdcXHUwMTQ2JzogJ24nLCAnXFx1MDE0OCc6ICduJywgJ1xcdTAxNGInOiAnbicsXG4gICdcXHUwMTRjJzogJ08nLCAgJ1xcdTAxNGUnOiAnTycsICdcXHUwMTUwJzogJ08nLFxuICAnXFx1MDE0ZCc6ICdvJywgICdcXHUwMTRmJzogJ28nLCAnXFx1MDE1MSc6ICdvJyxcbiAgJ1xcdTAxNTQnOiAnUicsICAnXFx1MDE1Nic6ICdSJywgJ1xcdTAxNTgnOiAnUicsXG4gICdcXHUwMTU1JzogJ3InLCAgJ1xcdTAxNTcnOiAncicsICdcXHUwMTU5JzogJ3InLFxuICAnXFx1MDE1YSc6ICdTJywgICdcXHUwMTVjJzogJ1MnLCAnXFx1MDE1ZSc6ICdTJywgJ1xcdTAxNjAnOiAnUycsXG4gICdcXHUwMTViJzogJ3MnLCAgJ1xcdTAxNWQnOiAncycsICdcXHUwMTVmJzogJ3MnLCAnXFx1MDE2MSc6ICdzJyxcbiAgJ1xcdTAxNjInOiAnVCcsICAnXFx1MDE2NCc6ICdUJywgJ1xcdTAxNjYnOiAnVCcsXG4gICdcXHUwMTYzJzogJ3QnLCAgJ1xcdTAxNjUnOiAndCcsICdcXHUwMTY3JzogJ3QnLFxuICAnXFx1MDE2OCc6ICdVJywgICdcXHUwMTZhJzogJ1UnLCAnXFx1MDE2Yyc6ICdVJywgJ1xcdTAxNmUnOiAnVScsICdcXHUwMTcwJzogJ1UnLCAnXFx1MDE3Mic6ICdVJyxcbiAgJ1xcdTAxNjknOiAndScsICAnXFx1MDE2Yic6ICd1JywgJ1xcdTAxNmQnOiAndScsICdcXHUwMTZmJzogJ3UnLCAnXFx1MDE3MSc6ICd1JywgJ1xcdTAxNzMnOiAndScsXG4gICdcXHUwMTc0JzogJ1cnLCAgJ1xcdTAxNzUnOiAndycsXG4gICdcXHUwMTc2JzogJ1knLCAgJ1xcdTAxNzcnOiAneScsICdcXHUwMTc4JzogJ1knLFxuICAnXFx1MDE3OSc6ICdaJywgICdcXHUwMTdiJzogJ1onLCAnXFx1MDE3ZCc6ICdaJyxcbiAgJ1xcdTAxN2EnOiAneicsICAnXFx1MDE3Yyc6ICd6JywgJ1xcdTAxN2UnOiAneicsXG4gICdcXHUwMTMyJzogJ0lKJywgJ1xcdTAxMzMnOiAnaWonLFxuICAnXFx1MDE1Mic6ICdPZScsICdcXHUwMTUzJzogJ29lJyxcbiAgJ1xcdTAxNDknOiBcIiduXCIsICdcXHUwMTdmJzogJ3NzJ1xufTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGNvbW1vbmpzR2xvYmFsID09ICdvYmplY3QnICYmIGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGNvbW1vbmpzR2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QkMiA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBBU0NJSSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXNjaWlUb0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnNwbGl0KCcnKTtcbn1cblxuLyoqXG4gKiBTcGxpdHMgYW4gQVNDSUkgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICovXG5mdW5jdGlvbiBhc2NpaVdvcmRzKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlQXNjaWlXb3JkKSB8fCBbXTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eU9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlPZihvYmplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIFVzZWQgYnkgYF8uZGVidXJyYCB0byBjb252ZXJ0IExhdGluLTEgU3VwcGxlbWVudCBhbmQgTGF0aW4gRXh0ZW5kZWQtQVxuICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbGV0dGVyIFRoZSBtYXRjaGVkIGxldHRlciB0byBkZWJ1cnIuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG4gKi9cbnZhciBkZWJ1cnJMZXR0ZXIgPSBiYXNlUHJvcGVydHlPZihkZWJ1cnJlZExldHRlcnMpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBVbmljb2RlIHN5bWJvbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgc3ltYm9sIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1VuaWNvZGUoc3RyaW5nKSB7XG4gIHJldHVybiByZUhhc1VuaWNvZGUudGVzdChzdHJpbmcpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBhIHdvcmQgY29tcG9zZWQgb2YgVW5pY29kZSBzeW1ib2xzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHdvcmQgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSB7XG4gIHJldHVybiByZUhhc1VuaWNvZGVXb3JkLnRlc3Qoc3RyaW5nKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgID8gdW5pY29kZVRvQXJyYXkoc3RyaW5nKVxuICAgIDogYXNjaWlUb0FycmF5KHN0cmluZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBVbmljb2RlIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiB1bmljb2RlVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGUpIHx8IFtdO1xufVxuXG4vKipcbiAqIFNwbGl0cyBhIFVuaWNvZGUgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICovXG5mdW5jdGlvbiB1bmljb2RlV29yZHMoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlV29yZCkgfHwgW107XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wkMSA9IHJvb3QkMi5TeW1ib2w7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sJDEgPyBTeW1ib2wkMS5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gIH1cbiAgZW5kID0gZW5kID4gbGVuZ3RoID8gbGVuZ3RoIDogZW5kO1xuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5ndGg7XG4gIH1cbiAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKChlbmQgLSBzdGFydCkgPj4+IDApO1xuICBzdGFydCA+Pj49IDA7XG5cbiAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENhc3RzIGBhcnJheWAgdG8gYSBzbGljZSBpZiBpdCdzIG5lZWRlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHNsaWNlLlxuICovXG5mdW5jdGlvbiBjYXN0U2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQ7XG4gIHJldHVybiAoIXN0YXJ0ICYmIGVuZCA+PSBsZW5ndGgpID8gYXJyYXkgOiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmxvd2VyRmlyc3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgYFN0cmluZ2AgY2FzZSBtZXRob2QgdG8gdXNlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FzZUZpcnN0KG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICB2YXIgc3RyU3ltYm9scyA9IGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgPyBzdHJpbmdUb0FycmF5KHN0cmluZylcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGNociA9IHN0clN5bWJvbHNcbiAgICAgID8gc3RyU3ltYm9sc1swXVxuICAgICAgOiBzdHJpbmcuY2hhckF0KDApO1xuXG4gICAgdmFyIHRyYWlsaW5nID0gc3RyU3ltYm9sc1xuICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMSkuam9pbignJylcbiAgICAgIDogc3RyaW5nLnNsaWNlKDEpO1xuXG4gICAgcmV0dXJuIGNoclttZXRob2ROYW1lXSgpICsgdHJhaWxpbmc7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uY2FtZWxDYXNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgZWFjaCB3b3JkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG91bmRlciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRlcihjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgcmV0dXJuIGFycmF5UmVkdWNlKHdvcmRzKGRlYnVycihzdHJpbmcpLnJlcGxhY2UocmVBcG9zLCAnJykpLCBjYWxsYmFjaywgJycpO1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gW2NhbWVsIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhbWVsQ2FzZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhbWVsIGNhc2VkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5jYW1lbENhc2UoJ0ZvbyBCYXInKTtcbiAqIC8vID0+ICdmb29CYXInXG4gKlxuICogXy5jYW1lbENhc2UoJy0tZm9vLWJhci0tJyk7XG4gKiAvLyA9PiAnZm9vQmFyJ1xuICpcbiAqIF8uY2FtZWxDYXNlKCdfX0ZPT19CQVJfXycpO1xuICogLy8gPT4gJ2Zvb0JhcidcbiAqL1xudmFyIGNhbWVsQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICB3b3JkID0gd29yZC50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gY2FwaXRhbGl6ZSh3b3JkKSA6IHdvcmQpO1xufSk7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlIGFuZCB0aGUgcmVtYWluaW5nXG4gKiB0byBsb3dlciBjYXNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNhcGl0YWxpemUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYXBpdGFsaXplZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uY2FwaXRhbGl6ZSgnRlJFRCcpO1xuICogLy8gPT4gJ0ZyZWQnXG4gKi9cbmZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiB1cHBlckZpcnN0KHRvU3RyaW5nKHN0cmluZykudG9Mb3dlckNhc2UoKSk7XG59XG5cbi8qKlxuICogRGVidXJycyBgc3RyaW5nYCBieSBjb252ZXJ0aW5nXG4gKiBbTGF0aW4tMSBTdXBwbGVtZW50XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbi0xX1N1cHBsZW1lbnRfKFVuaWNvZGVfYmxvY2spI0NoYXJhY3Rlcl90YWJsZSlcbiAqIGFuZCBbTGF0aW4gRXh0ZW5kZWQtQV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW5fRXh0ZW5kZWQtQSlcbiAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycyBhbmQgcmVtb3ZpbmdcbiAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZGVidXJyLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlYnVycignZMOpasOgIHZ1Jyk7XG4gKiAvLyA9PiAnZGVqYSB2dSdcbiAqL1xuZnVuY3Rpb24gZGVidXJyKHN0cmluZykge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICByZXR1cm4gc3RyaW5nICYmIHN0cmluZy5yZXBsYWNlKHJlTGF0aW4sIGRlYnVyckxldHRlcikucmVwbGFjZShyZUNvbWJvTWFyaywgJycpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51cHBlckZpcnN0KCdmcmVkJyk7XG4gKiAvLyA9PiAnRnJlZCdcbiAqXG4gKiBfLnVwcGVyRmlyc3QoJ0ZSRUQnKTtcbiAqIC8vID0+ICdGUkVEJ1xuICovXG52YXIgdXBwZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdCgndG9VcHBlckNhc2UnKTtcblxuLyoqXG4gKiBTcGxpdHMgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW3BhdHRlcm5dIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdvcmRzLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnXVxuICpcbiAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJywgL1teLCBdKy9nKTtcbiAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAnJicsICdwZWJibGVzJ11cbiAqL1xuZnVuY3Rpb24gd29yZHMoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICBwYXR0ZXJuID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBwYXR0ZXJuO1xuXG4gIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSA/IHVuaWNvZGVXb3JkcyhzdHJpbmcpIDogYXNjaWlXb3JkcyhzdHJpbmcpO1xuICB9XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybikgfHwgW107XG59XG5cbnZhciBsb2Rhc2hfY2FtZWxjYXNlID0gY2FtZWxDYXNlO1xuXG52YXIgd2FzbUhhc2ggPSB7ZXhwb3J0czoge319O1xuXG4vKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgaGFzUmVxdWlyZWRXYXNtSGFzaDtcblxuZnVuY3Rpb24gcmVxdWlyZVdhc21IYXNoICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkV2FzbUhhc2gpIHJldHVybiB3YXNtSGFzaC5leHBvcnRzO1xuXHRoYXNSZXF1aXJlZFdhc21IYXNoID0gMTtcblxuXHQvLyA2NTUzNiBpcyB0aGUgc2l6ZSBvZiBhIHdhc20gbWVtb3J5IHBhZ2Vcblx0Ly8gNjQgaXMgdGhlIG1heGltdW0gY2h1bmsgc2l6ZSBmb3IgZXZlcnkgcG9zc2libGUgd2FzbSBoYXNoIGltcGxlbWVudGF0aW9uXG5cdC8vIDQgaXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIGJ5dGVzIHBlciBjaGFyIGZvciBzdHJpbmcgZW5jb2RpbmcgKG1heCBpcyB1dGYtOClcblx0Ly8gfjMgbWFrZXMgc3VyZSB0aGF0IGl0J3MgYWx3YXlzIGEgYmxvY2sgb2YgNCBjaGFycywgc28gYXZvaWQgcGFydGlhbGx5IGVuY29kZWQgYnl0ZXMgZm9yIGJhc2U2NFxuXHRjb25zdCBNQVhfU0hPUlRfU1RSSU5HID0gTWF0aC5mbG9vcigoNjU1MzYgLSA2NCkgLyA0KSAmIH4zO1xuXG5cdGNsYXNzIFdhc21IYXNoIHtcblx0ICAvKipcblx0ICAgKiBAcGFyYW0ge1dlYkFzc2VtYmx5Lkluc3RhbmNlfSBpbnN0YW5jZSB3YXNtIGluc3RhbmNlXG5cdCAgICogQHBhcmFtIHtXZWJBc3NlbWJseS5JbnN0YW5jZVtdfSBpbnN0YW5jZXNQb29sIHBvb2wgb2YgaW5zdGFuY2VzXG5cdCAgICogQHBhcmFtIHtudW1iZXJ9IGNodW5rU2l6ZSBzaXplIG9mIGRhdGEgY2h1bmtzIHBhc3NlZCB0byB3YXNtXG5cdCAgICogQHBhcmFtIHtudW1iZXJ9IGRpZ2VzdFNpemUgc2l6ZSBvZiBkaWdlc3QgcmV0dXJuZWQgYnkgd2FzbVxuXHQgICAqL1xuXHQgIGNvbnN0cnVjdG9yKGluc3RhbmNlLCBpbnN0YW5jZXNQb29sLCBjaHVua1NpemUsIGRpZ2VzdFNpemUpIHtcblx0ICAgIGNvbnN0IGV4cG9ydHMgPSAvKiogQHR5cGUge2FueX0gKi8gKGluc3RhbmNlLmV4cG9ydHMpO1xuXG5cdCAgICBleHBvcnRzLmluaXQoKTtcblxuXHQgICAgdGhpcy5leHBvcnRzID0gZXhwb3J0cztcblx0ICAgIHRoaXMubWVtID0gQnVmZmVyLmZyb20oZXhwb3J0cy5tZW1vcnkuYnVmZmVyLCAwLCA2NTUzNik7XG5cdCAgICB0aGlzLmJ1ZmZlcmVkID0gMDtcblx0ICAgIHRoaXMuaW5zdGFuY2VzUG9vbCA9IGluc3RhbmNlc1Bvb2w7XG5cdCAgICB0aGlzLmNodW5rU2l6ZSA9IGNodW5rU2l6ZTtcblx0ICAgIHRoaXMuZGlnZXN0U2l6ZSA9IGRpZ2VzdFNpemU7XG5cdCAgfVxuXG5cdCAgcmVzZXQoKSB7XG5cdCAgICB0aGlzLmJ1ZmZlcmVkID0gMDtcblx0ICAgIHRoaXMuZXhwb3J0cy5pbml0KCk7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogQHBhcmFtIHtCdWZmZXIgfCBzdHJpbmd9IGRhdGEgZGF0YVxuXHQgICAqIEBwYXJhbSB7QnVmZmVyRW5jb2Rpbmc9fSBlbmNvZGluZyBlbmNvZGluZ1xuXHQgICAqIEByZXR1cm5zIHt0aGlzfSBpdHNlbGZcblx0ICAgKi9cblx0ICB1cGRhdGUoZGF0YSwgZW5jb2RpbmcpIHtcblx0ICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICB3aGlsZSAoZGF0YS5sZW5ndGggPiBNQVhfU0hPUlRfU1RSSU5HKSB7XG5cdCAgICAgICAgdGhpcy5fdXBkYXRlV2l0aFNob3J0U3RyaW5nKGRhdGEuc2xpY2UoMCwgTUFYX1NIT1JUX1NUUklORyksIGVuY29kaW5nKTtcblx0ICAgICAgICBkYXRhID0gZGF0YS5zbGljZShNQVhfU0hPUlRfU1RSSU5HKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuX3VwZGF0ZVdpdGhTaG9ydFN0cmluZyhkYXRhLCBlbmNvZGluZyk7XG5cblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX3VwZGF0ZVdpdGhCdWZmZXIoZGF0YSk7XG5cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIGRhdGFcblx0ICAgKiBAcGFyYW0ge0J1ZmZlckVuY29kaW5nPX0gZW5jb2RpbmcgZW5jb2Rpbmdcblx0ICAgKiBAcmV0dXJucyB7dm9pZH1cblx0ICAgKi9cblx0ICBfdXBkYXRlV2l0aFNob3J0U3RyaW5nKGRhdGEsIGVuY29kaW5nKSB7XG5cdCAgICBjb25zdCB7IGV4cG9ydHMsIGJ1ZmZlcmVkLCBtZW0sIGNodW5rU2l6ZSB9ID0gdGhpcztcblxuXHQgICAgbGV0IGVuZFBvcztcblxuXHQgICAgaWYgKGRhdGEubGVuZ3RoIDwgNzApIHtcblx0ICAgICAgaWYgKCFlbmNvZGluZyB8fCBlbmNvZGluZyA9PT0gXCJ1dGYtOFwiIHx8IGVuY29kaW5nID09PSBcInV0ZjhcIikge1xuXHQgICAgICAgIGVuZFBvcyA9IGJ1ZmZlcmVkO1xuXHQgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgY29uc3QgY2MgPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG5cblx0ICAgICAgICAgIGlmIChjYyA8IDB4ODApIHtcblx0ICAgICAgICAgICAgbWVtW2VuZFBvcysrXSA9IGNjO1xuXHQgICAgICAgICAgfSBlbHNlIGlmIChjYyA8IDB4ODAwKSB7XG5cdCAgICAgICAgICAgIG1lbVtlbmRQb3NdID0gKGNjID4+IDYpIHwgMHhjMDtcblx0ICAgICAgICAgICAgbWVtW2VuZFBvcyArIDFdID0gKGNjICYgMHgzZikgfCAweDgwO1xuXHQgICAgICAgICAgICBlbmRQb3MgKz0gMjtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIC8vIGJhaWwtb3V0IGZvciB3ZWlyZCBjaGFyc1xuXHQgICAgICAgICAgICBlbmRQb3MgKz0gbWVtLndyaXRlKGRhdGEuc2xpY2UoaSksIGVuZFBvcywgZW5jb2RpbmcpO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSBpZiAoZW5jb2RpbmcgPT09IFwibGF0aW4xXCIpIHtcblx0ICAgICAgICBlbmRQb3MgPSBidWZmZXJlZDtcblxuXHQgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgY29uc3QgY2MgPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG5cblx0ICAgICAgICAgIG1lbVtlbmRQb3MrK10gPSBjYztcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZW5kUG9zID0gYnVmZmVyZWQgKyBtZW0ud3JpdGUoZGF0YSwgYnVmZmVyZWQsIGVuY29kaW5nKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZW5kUG9zID0gYnVmZmVyZWQgKyBtZW0ud3JpdGUoZGF0YSwgYnVmZmVyZWQsIGVuY29kaW5nKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGVuZFBvcyA8IGNodW5rU2l6ZSkge1xuXHQgICAgICB0aGlzLmJ1ZmZlcmVkID0gZW5kUG9zO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgY29uc3QgbCA9IGVuZFBvcyAmIH4odGhpcy5jaHVua1NpemUgLSAxKTtcblxuXHQgICAgICBleHBvcnRzLnVwZGF0ZShsKTtcblxuXHQgICAgICBjb25zdCBuZXdCdWZmZXJlZCA9IGVuZFBvcyAtIGw7XG5cblx0ICAgICAgdGhpcy5idWZmZXJlZCA9IG5ld0J1ZmZlcmVkO1xuXG5cdCAgICAgIGlmIChuZXdCdWZmZXJlZCA+IDApIHtcblx0ICAgICAgICBtZW0uY29weVdpdGhpbigwLCBsLCBlbmRQb3MpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgZGF0YVxuXHQgICAqIEByZXR1cm5zIHt2b2lkfVxuXHQgICAqL1xuXHQgIF91cGRhdGVXaXRoQnVmZmVyKGRhdGEpIHtcblx0ICAgIGNvbnN0IHsgZXhwb3J0cywgYnVmZmVyZWQsIG1lbSB9ID0gdGhpcztcblx0ICAgIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXG5cdCAgICBpZiAoYnVmZmVyZWQgKyBsZW5ndGggPCB0aGlzLmNodW5rU2l6ZSkge1xuXHQgICAgICBkYXRhLmNvcHkobWVtLCBidWZmZXJlZCwgMCwgbGVuZ3RoKTtcblxuXHQgICAgICB0aGlzLmJ1ZmZlcmVkICs9IGxlbmd0aDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGNvbnN0IGwgPSAoYnVmZmVyZWQgKyBsZW5ndGgpICYgfih0aGlzLmNodW5rU2l6ZSAtIDEpO1xuXG5cdCAgICAgIGlmIChsID4gNjU1MzYpIHtcblx0ICAgICAgICBsZXQgaSA9IDY1NTM2IC0gYnVmZmVyZWQ7XG5cblx0ICAgICAgICBkYXRhLmNvcHkobWVtLCBidWZmZXJlZCwgMCwgaSk7XG5cdCAgICAgICAgZXhwb3J0cy51cGRhdGUoNjU1MzYpO1xuXG5cdCAgICAgICAgY29uc3Qgc3RvcCA9IGwgLSBidWZmZXJlZCAtIDY1NTM2O1xuXG5cdCAgICAgICAgd2hpbGUgKGkgPCBzdG9wKSB7XG5cdCAgICAgICAgICBkYXRhLmNvcHkobWVtLCAwLCBpLCBpICsgNjU1MzYpO1xuXHQgICAgICAgICAgZXhwb3J0cy51cGRhdGUoNjU1MzYpO1xuXHQgICAgICAgICAgaSArPSA2NTUzNjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBkYXRhLmNvcHkobWVtLCAwLCBpLCBsIC0gYnVmZmVyZWQpO1xuXG5cdCAgICAgICAgZXhwb3J0cy51cGRhdGUobCAtIGJ1ZmZlcmVkIC0gaSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZGF0YS5jb3B5KG1lbSwgYnVmZmVyZWQsIDAsIGwgLSBidWZmZXJlZCk7XG5cblx0ICAgICAgICBleHBvcnRzLnVwZGF0ZShsKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGNvbnN0IG5ld0J1ZmZlcmVkID0gbGVuZ3RoICsgYnVmZmVyZWQgLSBsO1xuXG5cdCAgICAgIHRoaXMuYnVmZmVyZWQgPSBuZXdCdWZmZXJlZDtcblxuXHQgICAgICBpZiAobmV3QnVmZmVyZWQgPiAwKSB7XG5cdCAgICAgICAgZGF0YS5jb3B5KG1lbSwgMCwgbGVuZ3RoIC0gbmV3QnVmZmVyZWQsIGxlbmd0aCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICBkaWdlc3QodHlwZSkge1xuXHQgICAgY29uc3QgeyBleHBvcnRzLCBidWZmZXJlZCwgbWVtLCBkaWdlc3RTaXplIH0gPSB0aGlzO1xuXG5cdCAgICBleHBvcnRzLmZpbmFsKGJ1ZmZlcmVkKTtcblxuXHQgICAgdGhpcy5pbnN0YW5jZXNQb29sLnB1c2godGhpcyk7XG5cblx0ICAgIGNvbnN0IGhleCA9IG1lbS50b1N0cmluZyhcImxhdGluMVwiLCAwLCBkaWdlc3RTaXplKTtcblxuXHQgICAgaWYgKHR5cGUgPT09IFwiaGV4XCIpIHtcblx0ICAgICAgcmV0dXJuIGhleDtcblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGUgPT09IFwiYmluYXJ5XCIgfHwgIXR5cGUpIHtcblx0ICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhleCwgXCJoZXhcIik7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBCdWZmZXIuZnJvbShoZXgsIFwiaGV4XCIpLnRvU3RyaW5nKHR5cGUpO1xuXHQgIH1cblx0fVxuXG5cdGNvbnN0IGNyZWF0ZSA9ICh3YXNtTW9kdWxlLCBpbnN0YW5jZXNQb29sLCBjaHVua1NpemUsIGRpZ2VzdFNpemUpID0+IHtcblx0ICBpZiAoaW5zdGFuY2VzUG9vbC5sZW5ndGggPiAwKSB7XG5cdCAgICBjb25zdCBvbGQgPSBpbnN0YW5jZXNQb29sLnBvcCgpO1xuXG5cdCAgICBvbGQucmVzZXQoKTtcblxuXHQgICAgcmV0dXJuIG9sZDtcblx0ICB9IGVsc2Uge1xuXHQgICAgcmV0dXJuIG5ldyBXYXNtSGFzaChcblx0ICAgICAgbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKHdhc21Nb2R1bGUpLFxuXHQgICAgICBpbnN0YW5jZXNQb29sLFxuXHQgICAgICBjaHVua1NpemUsXG5cdCAgICAgIGRpZ2VzdFNpemVcblx0ICAgICk7XG5cdCAgfVxuXHR9O1xuXG5cdHdhc21IYXNoLmV4cG9ydHMgPSBjcmVhdGU7XG5cdHdhc21IYXNoLmV4cG9ydHMuTUFYX1NIT1JUX1NUUklORyA9IE1BWF9TSE9SVF9TVFJJTkc7XG5cdHJldHVybiB3YXNtSGFzaC5leHBvcnRzO1xufVxuXG4vKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgeHhoYXNoNjRfMTtcbnZhciBoYXNSZXF1aXJlZFh4aGFzaDY0O1xuXG5mdW5jdGlvbiByZXF1aXJlWHhoYXNoNjQgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRYeGhhc2g2NCkgcmV0dXJuIHh4aGFzaDY0XzE7XG5cdGhhc1JlcXVpcmVkWHhoYXNoNjQgPSAxO1xuXG5cdGNvbnN0IGNyZWF0ZSA9IHJlcXVpcmVXYXNtSGFzaCgpO1xuXG5cdC8vI3JlZ2lvbiB3YXNtIGNvZGU6IHh4aGFzaDY0ICguLi8uLi8uLi9hc3NlbWJseS9oYXNoL3h4aGFzaDY0LmFzbS50cykgLS1pbml0aWFsTWVtb3J5IDFcblx0Y29uc3QgeHhoYXNoNjQgPSBuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKFxuXHQgIEJ1ZmZlci5mcm9tKFxuXHQgICAgLy8gMTE3MyBieXRlc1xuXHQgICAgXCJBR0Z6YlFFQUFBQUJDQUpnQVg4QVlBQUFBd1FEQVFBQUJRTUJBQUVHR2dWK0FVSUFDMzRCUWdBTGZnRkNBQXQrQVVJQUMzNEJRZ0FMQnlJRUJHbHVhWFFBQUFaMWNHUmhkR1VBQVFWbWFXNWhiQUFDQm0xbGJXOXllUUlBQ3JVSUF6QUFRdGJyZ3U3cS9ZbjE0QUFrQUVMUDF0Tyswc2VyMlVJa0FVSUFKQUpDK2VyUTBPZkpvZVRoQUNRRFFnQWtCQXZVQVFJQmZ3UitJQUJGQkVBUEN5TUVJQUN0ZkNRRUl3QWhBaU1CSVFNakFpRUVJd01oQlFOQUlBSWdBU2tEQUVMUDF0Tyswc2VyMlVKK2ZFSWZpVUtIbGErdm1MYmVtNTUvZmlFQ0lBTWdBU2tEQ0VMUDF0Tyswc2VyMlVKK2ZFSWZpVUtIbGErdm1MYmVtNTUvZmlFRElBUWdBU2tERUVMUDF0Tyswc2VyMlVKK2ZFSWZpVUtIbGErdm1MYmVtNTUvZmlFRUlBVWdBU2tER0VMUDF0Tyswc2VyMlVKK2ZFSWZpVUtIbGErdm1MYmVtNTUvZmlFRklBQWdBVUVnYWlJQlN3MEFDeUFDSkFBZ0F5UUJJQVFrQWlBRkpBTUxxd1lDQVg4RWZpTUVRZ0JTQkg0akFDSUNRZ0dKSXdFaUEwSUhpWHdqQWlJRVFneUpmQ01ESWdWQ0VvbDhJQUpDejliVHZ0TEhxOWxDZmtJZmlVS0hsYSt2bUxiZW01NS9mb1ZDaDVXdnI1aTIzcHVlZjM1Q25hTzE2b094allyNkFIMGdBMExQMXRPKzBzZXIyVUorUWgrSlFvZVZyNitZdHQ2Ym5uOStoVUtIbGErdm1MYmVtNTUvZmtLZG83WHFnN0dOaXZvQWZTQUVRcy9XMDc3U3g2dlpRbjVDSDRsQ2g1V3ZyNWkyM3B1ZWYzNkZRb2VWcjYrWXR0NmJubjkrUXAyanRlcURzWTJLK2dCOUlBVkN6OWJUdnRMSHE5bENma0lmaVVLSGxhK3ZtTGJlbTU1L2ZvVkNoNVd2cjVpMjNwdWVmMzVDbmFPMTZvT3hqWXI2QUgwRlFzWFAyYkx4NWJycUp3c2pCQ0FBclh4OElRSURRQ0FCUVFocUlBQk5CRUFnQWlBQktRTUFRcy9XMDc3U3g2dlpRbjVDSDRsQ2g1V3ZyNWkyM3B1ZWYzNkZRaHVKUW9lVnI2K1l0dDZibm45K1FwMmp0ZXFEc1kySytnQjlJUUlnQVVFSWFpRUJEQUVMQ3lBQlFRUnFJQUJOQkVBQ2Z5QUNJQUUxQWdCQ2g1V3ZyNWkyM3B1ZWYzNkZRaGVKUXMvVzA3N1N4NnZaUW41QytmUGQ4Wm4ybWFzV2ZDRUNJQUZCQkdvTElRRUxBMEFnQUNBQlJ3UkFJQUlnQVRFQUFFTEZ6OW15OGVXNjZpZCtoVUlMaVVLSGxhK3ZtTGJlbTU1L2ZpRUNJQUZCQVdvaEFRd0JDd3RCQUNBQ0lBSkNJWWlGUXMvVzA3N1N4NnZaUW40aUFpQUNRaDJJaFVMNTg5M3htZmFacXhaK0lnSWdBa0lnaUlVaUFrSWdpQ0lEUXYvL0E0TkNJSVlnQTBLQWdQei9ENE5DRUlpRUlnTkMvNEdBZ1BBZmcwSVFoaUFEUW9EK2c0Q0E0RCtEUWdpSWhDSURRbytBdklEd2djQUhnMElJaGlBRFF2Q0J3SWVBbm9ENEFJTkNCSWlFSWdOQ2hveVlzT0RBZ1lNR2ZFSUVpRUtCZ29TSWtLREFnQUdEUWlkK0lBTkNzT0RBZ1lPR2pKZ3doSHczQXdCQkNDQUNRdi8vLy84UGd5SUNRdi8vQTROQ0lJWWdBa0tBZ1B6L0Q0TkNFSWlFSWdKQy80R0FnUEFmZzBJUWhpQUNRb0QrZzRDQTREK0RRZ2lJaENJQ1FvK0F2SUR3Z2NBSGcwSUloaUFDUXZDQndJZUFub0Q0QUlOQ0JJaUVJZ0pDaG95WXNPREFnWU1HZkVJRWlFS0Jnb1NJa0tEQWdBR0RRaWQrSUFKQ3NPREFnWU9Hakpnd2hIdzNBd0FMXCIsXG5cdCAgICBcImJhc2U2NFwiXG5cdCAgKVxuXHQpO1xuXHQvLyNlbmRyZWdpb25cblxuXHR4eGhhc2g2NF8xID0gY3JlYXRlLmJpbmQobnVsbCwgeHhoYXNoNjQsIFtdLCAzMiwgMTYpO1xuXHRyZXR1cm4geHhoYXNoNjRfMTtcbn1cblxudmFyIEJhdGNoZWRIYXNoXzE7XG52YXIgaGFzUmVxdWlyZWRCYXRjaGVkSGFzaDtcblxuZnVuY3Rpb24gcmVxdWlyZUJhdGNoZWRIYXNoICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkQmF0Y2hlZEhhc2gpIHJldHVybiBCYXRjaGVkSGFzaF8xO1xuXHRoYXNSZXF1aXJlZEJhdGNoZWRIYXNoID0gMTtcblx0Y29uc3QgTUFYX1NIT1JUX1NUUklORyA9IHJlcXVpcmVXYXNtSGFzaCgpLk1BWF9TSE9SVF9TVFJJTkc7XG5cblx0Y2xhc3MgQmF0Y2hlZEhhc2gge1xuXHQgIGNvbnN0cnVjdG9yKGhhc2gpIHtcblx0ICAgIHRoaXMuc3RyaW5nID0gdW5kZWZpbmVkO1xuXHQgICAgdGhpcy5lbmNvZGluZyA9IHVuZGVmaW5lZDtcblx0ICAgIHRoaXMuaGFzaCA9IGhhc2g7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogVXBkYXRlIGhhc2gge0BsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvY3J5cHRvLmh0bWwjY3J5cHRvX2hhc2hfdXBkYXRlX2RhdGFfaW5wdXRlbmNvZGluZ31cblx0ICAgKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IGRhdGEgZGF0YVxuXHQgICAqIEBwYXJhbSB7c3RyaW5nPX0gaW5wdXRFbmNvZGluZyBkYXRhIGVuY29kaW5nXG5cdCAgICogQHJldHVybnMge3RoaXN9IHVwZGF0ZWQgaGFzaFxuXHQgICAqL1xuXHQgIHVwZGF0ZShkYXRhLCBpbnB1dEVuY29kaW5nKSB7XG5cdCAgICBpZiAodGhpcy5zdHJpbmcgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICBpZiAoXG5cdCAgICAgICAgdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgJiZcblx0ICAgICAgICBpbnB1dEVuY29kaW5nID09PSB0aGlzLmVuY29kaW5nICYmXG5cdCAgICAgICAgdGhpcy5zdHJpbmcubGVuZ3RoICsgZGF0YS5sZW5ndGggPCBNQVhfU0hPUlRfU1RSSU5HXG5cdCAgICAgICkge1xuXHQgICAgICAgIHRoaXMuc3RyaW5nICs9IGRhdGE7XG5cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuaGFzaC51cGRhdGUodGhpcy5zdHJpbmcsIHRoaXMuZW5jb2RpbmcpO1xuXHQgICAgICB0aGlzLnN0cmluZyA9IHVuZGVmaW5lZDtcblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgIGlmIChcblx0ICAgICAgICBkYXRhLmxlbmd0aCA8IE1BWF9TSE9SVF9TVFJJTkcgJiZcblx0ICAgICAgICAvLyBiYXNlNjQgZW5jb2RpbmcgaXMgbm90IHZhbGlkIHNpbmNlIGl0IG1heSBjb250YWluIHBhZGRpbmcgY2hhcnNcblx0ICAgICAgICAoIWlucHV0RW5jb2RpbmcgfHwgIWlucHV0RW5jb2Rpbmcuc3RhcnRzV2l0aChcImJhXCIpKVxuXHQgICAgICApIHtcblx0ICAgICAgICB0aGlzLnN0cmluZyA9IGRhdGE7XG5cdCAgICAgICAgdGhpcy5lbmNvZGluZyA9IGlucHV0RW5jb2Rpbmc7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy5oYXNoLnVwZGF0ZShkYXRhLCBpbnB1dEVuY29kaW5nKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy5oYXNoLnVwZGF0ZShkYXRhKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogQ2FsY3VsYXRlcyB0aGUgZGlnZXN0IHtAbGluayBodHRwczovL25vZGVqcy5vcmcvYXBpL2NyeXB0by5odG1sI2NyeXB0b19oYXNoX2RpZ2VzdF9lbmNvZGluZ31cblx0ICAgKiBAcGFyYW0ge3N0cmluZz19IGVuY29kaW5nIGVuY29kaW5nIG9mIHRoZSByZXR1cm4gdmFsdWVcblx0ICAgKiBAcmV0dXJucyB7c3RyaW5nfEJ1ZmZlcn0gZGlnZXN0XG5cdCAgICovXG5cdCAgZGlnZXN0KGVuY29kaW5nKSB7XG5cdCAgICBpZiAodGhpcy5zdHJpbmcgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICB0aGlzLmhhc2gudXBkYXRlKHRoaXMuc3RyaW5nLCB0aGlzLmVuY29kaW5nKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuaGFzaC5kaWdlc3QoZW5jb2RpbmcpO1xuXHQgIH1cblx0fVxuXG5cdEJhdGNoZWRIYXNoXzEgPSBCYXRjaGVkSGFzaDtcblx0cmV0dXJuIEJhdGNoZWRIYXNoXzE7XG59XG5cbi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBtZDRfMTtcbnZhciBoYXNSZXF1aXJlZE1kNDtcblxuZnVuY3Rpb24gcmVxdWlyZU1kNCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZE1kNCkgcmV0dXJuIG1kNF8xO1xuXHRoYXNSZXF1aXJlZE1kNCA9IDE7XG5cblx0Y29uc3QgY3JlYXRlID0gcmVxdWlyZVdhc21IYXNoKCk7XG5cblx0Ly8jcmVnaW9uIHdhc20gY29kZTogbWQ0ICguLi8uLi8uLi9hc3NlbWJseS9oYXNoL21kNC5hc20udHMpIC0taW5pdGlhbE1lbW9yeSAxXG5cdGNvbnN0IG1kNCA9IG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUoXG5cdCAgQnVmZmVyLmZyb20oXG5cdCAgICAvLyAyMTUwIGJ5dGVzXG5cdCAgICBcIkFHRnpiUUVBQUFBQkNBSmdBWDhBWUFBQUF3VUVBUUFBQUFVREFRQUJCaG9GZndGQkFBdC9BVUVBQzM4QlFRQUxmd0ZCQUF0L0FVRUFDd2NpQkFScGJtbDBBQUFHZFhCa1lYUmxBQUlGWm1sdVlXd0FBd1p0WlcxdmNua0NBQXFGRUFRbUFFR0J4cFM2QmlRQlFZblh0djUrSkFKQi9ybnJ4WGtrQTBIMnFNbUJBU1FFUVFBa0FBdk1DZ0VZZnlNQklRb2pBaUVHSXdNaEJ5TUVJUWdEUUNBQUlBVkxCRUFnQlNnQ0NDSU5JQWNnQmlBRktBSUVJZ3NnQ0NBSElBVW9BZ0FpRENBS0lBZ2dCaUFISUFoemNYTnFha0VEZHlJRElBWWdCM054YzJwcVFRZDNJZ0VnQXlBR2MzRnphbXBCQzNjaEFpQUZLQUlVSWc4Z0FTQUNJQVVvQWhBaUNTQURJQUVnQlNnQ0RDSU9JQVlnQXlBQ0lBRWdBM054YzJwcVFSTjNJZ1FnQVNBQ2MzRnphbXBCQTNjaUF5QUNJQVJ6Y1hOcWFrRUhkeUVCSUFVb0FpQWlFaUFESUFFZ0JTZ0NIQ0lSSUFRZ0F5QUZLQUlZSWhBZ0FpQUVJQUVnQXlBRWMzRnphbXBCQzNjaUFpQUJJQU56Y1hOcWFrRVRkeUlFSUFFZ0FuTnhjMnBxUVFOM0lRTWdCU2dDTENJVklBUWdBeUFGS0FJb0loUWdBaUFFSUFVb0FpUWlFeUFCSUFJZ0F5QUNJQVJ6Y1hOcWFrRUhkeUlCSUFNZ0JITnhjMnBxUVF0M0lnSWdBU0FEYzNGemFtcEJFM2NoQkNBUElCQWdDU0FWSUJRZ0V5QUZLQUk0SWhZZ0FpQUVJQVVvQWpRaUZ5QUJJQUlnQlNnQ01DSVlJQU1nQVNBRUlBRWdBbk54YzJwcVFRTjNJZ0VnQWlBRWMzRnphbXBCQjNjaUFpQUJJQVJ6Y1hOcWFrRUxkeUlESUFrZ0FpQU1JQUVnQlNnQ1BDSUpJQVFnQVNBRElBRWdBbk54YzJwcVFSTjNJZ0VnQWlBRGNuRWdBaUFEY1hKcWFrR1o4NG5VQldwQkEzY2lBaUFCSUFOeWNTQUJJQU54Y21wcVFabnppZFFGYWtFRmR5SUVJQUVnQW5KeElBRWdBbkZ5YWlBU2FrR1o4NG5VQldwQkNYY2lBeUFQSUFRZ0N5QUNJQmdnQVNBRElBSWdCSEp4SUFJZ0JIRnlhbXBCbWZPSjFBVnFRUTEzSWdFZ0F5QUVjbkVnQXlBRWNYSnFha0daODRuVUJXcEJBM2NpQWlBQklBTnljU0FCSUFOeGNtcHFRWm56aWRRRmFrRUZkeUlFSUFFZ0FuSnhJQUVnQW5GeWFtcEJtZk9KMUFWcVFRbDNJZ01nRUNBRUlBSWdGeUFCSUFNZ0FpQUVjbkVnQWlBRWNYSnFha0daODRuVUJXcEJEWGNpQVNBRElBUnljU0FESUFSeGNtb2dEV3BCbWZPSjFBVnFRUU4zSWdJZ0FTQURjbkVnQVNBRGNYSnFha0daODRuVUJXcEJCWGNpQkNBQklBSnljU0FCSUFKeGNtcHFRWm56aWRRRmFrRUpkeUlESUJFZ0JDQU9JQUlnRmlBQklBTWdBaUFFY25FZ0FpQUVjWEpxYWtHWjg0blVCV3BCRFhjaUFTQURJQVJ5Y1NBRElBUnhjbXBxUVpuemlkUUZha0VEZHlJQ0lBRWdBM0p4SUFFZ0EzRnlhbXBCbWZPSjFBVnFRUVYzSWdRZ0FTQUNjbkVnQVNBQ2NYSnFha0daODRuVUJXcEJDWGNpQXlBTUlBSWdBeUFKSUFFZ0F5QUNJQVJ5Y1NBQ0lBUnhjbXBxUVpuemlkUUZha0VOZHlJQmN5QUVjMnBxUWFIWDUvWUdha0VEZHlJQ0lBUWdBU0FDY3lBRGMyb2dFbXBCb2RmbjlnWnFRUWwzSWdSeklBRnphbXBCb2RmbjlnWnFRUXQzSWdNZ0FpQURJQmdnQVNBRElBUnpJQUp6YW1wQm9kZm45Z1pxUVE5M0lnRnpJQVJ6YWlBTmFrR2gxK2YyQm1wQkEzY2lBaUFVSUFRZ0FTQUNjeUFEYzJwcVFhSFg1L1lHYWtFSmR5SUVjeUFCYzJwcVFhSFg1L1lHYWtFTGR5SURJQXNnQWlBRElCWWdBU0FESUFSeklBSnphbXBCb2RmbjlnWnFRUTkzSWdGeklBUnphbXBCb2RmbjlnWnFRUU4zSWdJZ0V5QUVJQUVnQW5NZ0EzTnFha0doMStmMkJtcEJDWGNpQkhNZ0FYTnFha0doMStmMkJtcEJDM2NoQXlBS0lBNGdBaUFESUJjZ0FTQURJQVJ6SUFKemFtcEJvZGZuOWdacVFROTNJZ0Z6SUFSemFtcEJvZGZuOWdacVFRTjNJZ0pxSVFvZ0JpQUpJQUVnRVNBRElBSWdGU0FFSUFFZ0FuTWdBM05xYWtHaDErZjJCbXBCQ1hjaUJITWdBWE5xYWtHaDErZjJCbXBCQzNjaUF5QUVjeUFDYzJwcVFhSFg1L1lHYWtFUGQyb2hCaUFESUFkcUlRY2dCQ0FJYWlFSUlBVkJRR3NoQlF3QkN3c2dDaVFCSUFZa0FpQUhKQU1nQ0NRRUN3MEFJQUFRQVNNQUlBQnFKQUFML3dRQ0EzOEJmaU1BSUFCcXJVSURoaUVFSUFCQnlBQnFRVUJ4SWdKQkNHc2hBeUFBSWdGQkFXb2hBQ0FCUVlBQk9nQUFBMEFnQUNBQ1NVRUFJQUJCQjNFYkJFQWdBRUVBT2dBQUlBQkJBV29oQUF3QkN3c0RRQ0FBSUFKSkJFQWdBRUlBTndNQUlBQkJDR29oQUF3QkN3c2dBeUFFTndNQUlBSVFBVUVBSXdHdElnUkMvLzhEZ3lBRVFvQ0EvUDhQZzBJUWhvUWlCRUwvZ1lDQThCK0RJQVJDZ1A2RGdJRGdQNE5DQ0lhRUlnUkNqNEM4Z1BDQndBZURRZ2lHSUFSQzhJSEFoNENlZ1BnQWcwSUVpSVFpQkVLR2pKaXc0TUNCZ3daOFFnU0lRb0dDaElpUW9NQ0FBWU5DSjM0Z0JFS3c0TUNCZzRhTW1EQ0VmRGNEQUVFSUl3S3RJZ1JDLy84RGd5QUVRb0NBL1A4UGcwSVFob1FpQkVML2dZQ0E4QitESUFSQ2dQNkRnSURnUDROQ0NJYUVJZ1JDajRDOGdQQ0J3QWVEUWdpR0lBUkM4SUhBaDRDZWdQZ0FnMElFaUlRaUJFS0dqSml3NE1DQmd3WjhRZ1NJUW9HQ2hJaVFvTUNBQVlOQ0ozNGdCRUt3NE1DQmc0YU1tRENFZkRjREFFRVFJd090SWdSQy8vOERneUFFUW9DQS9QOFBnMElRaG9RaUJFTC9nWUNBOEIrRElBUkNnUDZEZ0lEZ1A0TkNDSWFFSWdSQ2o0QzhnUENCd0FlRFFnaUdJQVJDOElIQWg0Q2VnUGdBZzBJRWlJUWlCRUtHakppdzRNQ0Jnd1o4UWdTSVFvR0NoSWlRb01DQUFZTkNKMzRnQkVLdzRNQ0JnNGFNbURDRWZEY0RBRUVZSXdTdElnUkMvLzhEZ3lBRVFvQ0EvUDhQZzBJUWhvUWlCRUwvZ1lDQThCK0RJQVJDZ1A2RGdJRGdQNE5DQ0lhRUlnUkNqNEM4Z1BDQndBZURRZ2lHSUFSQzhJSEFoNENlZ1BnQWcwSUVpSVFpQkVLR2pKaXc0TUNCZ3daOFFnU0lRb0dDaElpUW9NQ0FBWU5DSjM0Z0JFS3c0TUNCZzRhTW1EQ0VmRGNEQUFzPVwiLFxuXHQgICAgXCJiYXNlNjRcIlxuXHQgIClcblx0KTtcblx0Ly8jZW5kcmVnaW9uXG5cblx0bWQ0XzEgPSBjcmVhdGUuYmluZChudWxsLCBtZDQsIFtdLCA2NCwgMzIpO1xuXHRyZXR1cm4gbWQ0XzE7XG59XG5cbnZhciBCdWxrVXBkYXRlRGVjb3JhdG9yXzE7XG52YXIgaGFzUmVxdWlyZWRCdWxrVXBkYXRlRGVjb3JhdG9yO1xuXG5mdW5jdGlvbiByZXF1aXJlQnVsa1VwZGF0ZURlY29yYXRvciAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEJ1bGtVcGRhdGVEZWNvcmF0b3IpIHJldHVybiBCdWxrVXBkYXRlRGVjb3JhdG9yXzE7XG5cdGhhc1JlcXVpcmVkQnVsa1VwZGF0ZURlY29yYXRvciA9IDE7XG5cdGNvbnN0IEJVTEtfU0laRSA9IDIwMDA7XG5cblx0Ly8gV2UgYXJlIHVzaW5nIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGEgTWFwIGFzIHRoaXMgd2lsbCBzdGF5IHN0YXRpYyBkdXJpbmcgdGhlIHJ1bnRpbWVcblx0Ly8gc28gYWNjZXNzIHRvIGl0IGNhbiBiZSBvcHRpbWl6ZWQgYnkgdjhcblx0Y29uc3QgZGlnZXN0Q2FjaGVzID0ge307XG5cblx0Y2xhc3MgQnVsa1VwZGF0ZURlY29yYXRvciB7XG5cdCAgLyoqXG5cdCAgICogQHBhcmFtIHtIYXNoIHwgZnVuY3Rpb24oKTogSGFzaH0gaGFzaE9yRmFjdG9yeSBmdW5jdGlvbiB0byBjcmVhdGUgYSBoYXNoXG5cdCAgICogQHBhcmFtIHtzdHJpbmc9fSBoYXNoS2V5IGtleSBmb3IgY2FjaGluZ1xuXHQgICAqL1xuXHQgIGNvbnN0cnVjdG9yKGhhc2hPckZhY3RvcnksIGhhc2hLZXkpIHtcblx0ICAgIHRoaXMuaGFzaEtleSA9IGhhc2hLZXk7XG5cblx0ICAgIGlmICh0eXBlb2YgaGFzaE9yRmFjdG9yeSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgIHRoaXMuaGFzaEZhY3RvcnkgPSBoYXNoT3JGYWN0b3J5O1xuXHQgICAgICB0aGlzLmhhc2ggPSB1bmRlZmluZWQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLmhhc2hGYWN0b3J5ID0gdW5kZWZpbmVkO1xuXHQgICAgICB0aGlzLmhhc2ggPSBoYXNoT3JGYWN0b3J5O1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLmJ1ZmZlciA9IFwiXCI7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogVXBkYXRlIGhhc2gge0BsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvY3J5cHRvLmh0bWwjY3J5cHRvX2hhc2hfdXBkYXRlX2RhdGFfaW5wdXRlbmNvZGluZ31cblx0ICAgKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IGRhdGEgZGF0YVxuXHQgICAqIEBwYXJhbSB7c3RyaW5nPX0gaW5wdXRFbmNvZGluZyBkYXRhIGVuY29kaW5nXG5cdCAgICogQHJldHVybnMge3RoaXN9IHVwZGF0ZWQgaGFzaFxuXHQgICAqL1xuXHQgIHVwZGF0ZShkYXRhLCBpbnB1dEVuY29kaW5nKSB7XG5cdCAgICBpZiAoXG5cdCAgICAgIGlucHV0RW5jb2RpbmcgIT09IHVuZGVmaW5lZCB8fFxuXHQgICAgICB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiB8fFxuXHQgICAgICBkYXRhLmxlbmd0aCA+IEJVTEtfU0laRVxuXHQgICAgKSB7XG5cdCAgICAgIGlmICh0aGlzLmhhc2ggPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHRoaXMuaGFzaCA9IHRoaXMuaGFzaEZhY3RvcnkoKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgdGhpcy5oYXNoLnVwZGF0ZSh0aGlzLmJ1ZmZlcik7XG5cdCAgICAgICAgdGhpcy5idWZmZXIgPSBcIlwiO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5oYXNoLnVwZGF0ZShkYXRhLCBpbnB1dEVuY29kaW5nKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuYnVmZmVyICs9IGRhdGE7XG5cblx0ICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IEJVTEtfU0laRSkge1xuXHQgICAgICAgIGlmICh0aGlzLmhhc2ggPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgdGhpcy5oYXNoID0gdGhpcy5oYXNoRmFjdG9yeSgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMuaGFzaC51cGRhdGUodGhpcy5idWZmZXIpO1xuXHQgICAgICAgIHRoaXMuYnVmZmVyID0gXCJcIjtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBDYWxjdWxhdGVzIHRoZSBkaWdlc3Qge0BsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvY3J5cHRvLmh0bWwjY3J5cHRvX2hhc2hfZGlnZXN0X2VuY29kaW5nfVxuXHQgICAqIEBwYXJhbSB7c3RyaW5nPX0gZW5jb2RpbmcgZW5jb2Rpbmcgb2YgdGhlIHJldHVybiB2YWx1ZVxuXHQgICAqIEByZXR1cm5zIHtzdHJpbmd8QnVmZmVyfSBkaWdlc3Rcblx0ICAgKi9cblx0ICBkaWdlc3QoZW5jb2RpbmcpIHtcblx0ICAgIGxldCBkaWdlc3RDYWNoZTtcblxuXHQgICAgY29uc3QgYnVmZmVyID0gdGhpcy5idWZmZXI7XG5cblx0ICAgIGlmICh0aGlzLmhhc2ggPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAvLyBzaG9ydCBkYXRhIGZvciBoYXNoLCB3ZSBjYW4gdXNlIGNhY2hpbmdcblx0ICAgICAgY29uc3QgY2FjaGVLZXkgPSBgJHt0aGlzLmhhc2hLZXl9LSR7ZW5jb2Rpbmd9YDtcblxuXHQgICAgICBkaWdlc3RDYWNoZSA9IGRpZ2VzdENhY2hlc1tjYWNoZUtleV07XG5cblx0ICAgICAgaWYgKGRpZ2VzdENhY2hlID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICBkaWdlc3RDYWNoZSA9IGRpZ2VzdENhY2hlc1tjYWNoZUtleV0gPSBuZXcgTWFwKCk7XG5cdCAgICAgIH1cblxuXHQgICAgICBjb25zdCBjYWNoZUVudHJ5ID0gZGlnZXN0Q2FjaGUuZ2V0KGJ1ZmZlcik7XG5cblx0ICAgICAgaWYgKGNhY2hlRW50cnkgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHJldHVybiBjYWNoZUVudHJ5O1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5oYXNoID0gdGhpcy5oYXNoRmFjdG9yeSgpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcblx0ICAgICAgdGhpcy5oYXNoLnVwZGF0ZShidWZmZXIpO1xuXHQgICAgfVxuXG5cdCAgICBjb25zdCBkaWdlc3RSZXN1bHQgPSB0aGlzLmhhc2guZGlnZXN0KGVuY29kaW5nKTtcblxuXHQgICAgaWYgKGRpZ2VzdENhY2hlICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgZGlnZXN0Q2FjaGUuc2V0KGJ1ZmZlciwgZGlnZXN0UmVzdWx0KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGRpZ2VzdFJlc3VsdDtcblx0ICB9XG5cdH1cblxuXHRCdWxrVXBkYXRlRGVjb3JhdG9yXzEgPSBCdWxrVXBkYXRlRGVjb3JhdG9yO1xuXHRyZXR1cm4gQnVsa1VwZGF0ZURlY29yYXRvcl8xO1xufVxuXG5jb25zdCBiYXNlRW5jb2RlVGFibGVzID0ge1xuICAyNjogXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLFxuICAzMjogXCIxMjM0NTY3ODlhYmNkZWZnaGprbW5wcXJzdHV2d3h5elwiLCAvLyBubyAwbGlvXG4gIDM2OiBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLFxuICA0OTogXCJhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaXCIsIC8vIG5vIGxJT1xuICA1MjogXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCIsXG4gIDU4OiBcIjEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVpcIiwgLy8gbm8gMGxJT1xuICA2MjogXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiLFxuICA2NDogXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWi1fXCIsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDMyQXJyYXl9IHVpbnQzMkFycmF5IFRyZWF0ZWQgYXMgYSBsb25nIGJhc2UtMHgxMDAwMDAwMDAgbnVtYmVyLCBsaXR0bGUgZW5kaWFuXG4gKiBAcGFyYW0ge251bWJlcn0gZGl2aXNvciBUaGUgZGl2aXNvclxuICogQHJldHVybiB7bnVtYmVyfSBNb2R1bG8gKHJlbWFpbmRlcikgb2YgdGhlIGRpdmlzaW9uXG4gKi9cbmZ1bmN0aW9uIGRpdm1vZDMyKHVpbnQzMkFycmF5LCBkaXZpc29yKSB7XG4gIGxldCBjYXJyeSA9IDA7XG4gIGZvciAobGV0IGkgPSB1aW50MzJBcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IHZhbHVlID0gY2FycnkgKiAweDEwMDAwMDAwMCArIHVpbnQzMkFycmF5W2ldO1xuICAgIGNhcnJ5ID0gdmFsdWUgJSBkaXZpc29yO1xuICAgIHVpbnQzMkFycmF5W2ldID0gTWF0aC5mbG9vcih2YWx1ZSAvIGRpdmlzb3IpO1xuICB9XG4gIHJldHVybiBjYXJyeTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQnVmZmVyVG9CYXNlKGJ1ZmZlciwgYmFzZSwgbGVuZ3RoKSB7XG4gIGNvbnN0IGVuY29kZVRhYmxlID0gYmFzZUVuY29kZVRhYmxlc1tiYXNlXTtcblxuICBpZiAoIWVuY29kZVRhYmxlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBlbmNvZGluZyBiYXNlXCIgKyBiYXNlKTtcbiAgfVxuXG4gIC8vIElucHV0IGJpdHMgYXJlIG9ubHkgZW5vdWdoIHRvIGdlbmVyYXRlIHRoaXMgbWFueSBjaGFyYWN0ZXJzXG4gIGNvbnN0IGxpbWl0ID0gTWF0aC5jZWlsKChidWZmZXIubGVuZ3RoICogOCkgLyBNYXRoLmxvZzIoYmFzZSkpO1xuICBsZW5ndGggPSBNYXRoLm1pbihsZW5ndGgsIGxpbWl0KTtcblxuICAvLyBNb3N0IG9mIHRoZSBjcnlwdG8gZGlnZXN0cyAoaWYgbm90IGFsbCkgaGFzIGxlbmd0aCBhIG11bHRpcGxlIG9mIDQgYnl0ZXMuXG4gIC8vIEZld2VyIG51bWJlcnMgaW4gdGhlIGFycmF5IG1lYW5zIGZhc3RlciBtYXRoLlxuICBjb25zdCB1aW50MzJBcnJheSA9IG5ldyBVaW50MzJBcnJheShNYXRoLmNlaWwoYnVmZmVyLmxlbmd0aCAvIDQpKTtcblxuICAvLyBNYWtlIHN1cmUgdGhlIGlucHV0IGJ1ZmZlciBkYXRhIGlzIGNvcGllZCBhbmQgaXMgbm90IG11dGF0ZWQgYnkgcmVmZXJlbmNlLlxuICAvLyBkaXZtb2QzMigpIHdvdWxkIGNvcnJ1cHQgdGhlIEJ1bGtVcGRhdGVEZWNvcmF0b3IgY2FjaGUgb3RoZXJ3aXNlLlxuICBidWZmZXIuY29weShCdWZmZXIuZnJvbSh1aW50MzJBcnJheS5idWZmZXIpKTtcblxuICBsZXQgb3V0cHV0ID0gXCJcIjtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0ID0gZW5jb2RlVGFibGVbZGl2bW9kMzIodWludDMyQXJyYXksIGJhc2UpXSArIG91dHB1dDtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmxldCBjcnlwdG8gPSB1bmRlZmluZWQ7XG5sZXQgY3JlYXRlWFhIYXNoNjQgPSB1bmRlZmluZWQ7XG5sZXQgY3JlYXRlTWQ0ID0gdW5kZWZpbmVkO1xubGV0IEJhdGNoZWRIYXNoID0gdW5kZWZpbmVkO1xubGV0IEJ1bGtVcGRhdGVEZWNvcmF0b3IgPSB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGdldEhhc2hEaWdlc3QkMShidWZmZXIsIGFsZ29yaXRobSwgZGlnZXN0VHlwZSwgbWF4TGVuZ3RoKSB7XG4gIGFsZ29yaXRobSA9IGFsZ29yaXRobSB8fCBcInh4aGFzaDY0XCI7XG4gIG1heExlbmd0aCA9IG1heExlbmd0aCB8fCA5OTk5O1xuXG4gIGxldCBoYXNoO1xuXG4gIGlmIChhbGdvcml0aG0gPT09IFwieHhoYXNoNjRcIikge1xuICAgIGlmIChjcmVhdGVYWEhhc2g2NCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjcmVhdGVYWEhhc2g2NCA9IHJlcXVpcmVYeGhhc2g2NCgpO1xuXG4gICAgICBpZiAoQmF0Y2hlZEhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBCYXRjaGVkSGFzaCA9IHJlcXVpcmVCYXRjaGVkSGFzaCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhhc2ggPSBuZXcgQmF0Y2hlZEhhc2goY3JlYXRlWFhIYXNoNjQoKSk7XG4gIH0gZWxzZSBpZiAoYWxnb3JpdGhtID09PSBcIm1kNFwiKSB7XG4gICAgaWYgKGNyZWF0ZU1kNCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjcmVhdGVNZDQgPSByZXF1aXJlTWQ0KCk7XG5cbiAgICAgIGlmIChCYXRjaGVkSGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIEJhdGNoZWRIYXNoID0gcmVxdWlyZUJhdGNoZWRIYXNoKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFzaCA9IG5ldyBCYXRjaGVkSGFzaChjcmVhdGVNZDQoKSk7XG4gIH0gZWxzZSBpZiAoYWxnb3JpdGhtID09PSBcIm5hdGl2ZS1tZDRcIikge1xuICAgIGlmICh0eXBlb2YgY3J5cHRvID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjcnlwdG8gPSByZXF1aXJlJCQ1O1xuXG4gICAgICBpZiAoQnVsa1VwZGF0ZURlY29yYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIEJ1bGtVcGRhdGVEZWNvcmF0b3IgPSByZXF1aXJlQnVsa1VwZGF0ZURlY29yYXRvcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhhc2ggPSBuZXcgQnVsa1VwZGF0ZURlY29yYXRvcigoKSA9PiBjcnlwdG8uY3JlYXRlSGFzaChcIm1kNFwiKSwgXCJtZDRcIik7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBjcnlwdG8gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNyeXB0byA9IHJlcXVpcmUkJDU7XG5cbiAgICAgIGlmIChCdWxrVXBkYXRlRGVjb3JhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgQnVsa1VwZGF0ZURlY29yYXRvciA9IHJlcXVpcmVCdWxrVXBkYXRlRGVjb3JhdG9yKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFzaCA9IG5ldyBCdWxrVXBkYXRlRGVjb3JhdG9yKFxuICAgICAgKCkgPT4gY3J5cHRvLmNyZWF0ZUhhc2goYWxnb3JpdGhtKSxcbiAgICAgIGFsZ29yaXRobVxuICAgICk7XG4gIH1cblxuICBoYXNoLnVwZGF0ZShidWZmZXIpO1xuXG4gIGlmIChcbiAgICBkaWdlc3RUeXBlID09PSBcImJhc2UyNlwiIHx8XG4gICAgZGlnZXN0VHlwZSA9PT0gXCJiYXNlMzJcIiB8fFxuICAgIGRpZ2VzdFR5cGUgPT09IFwiYmFzZTM2XCIgfHxcbiAgICBkaWdlc3RUeXBlID09PSBcImJhc2U0OVwiIHx8XG4gICAgZGlnZXN0VHlwZSA9PT0gXCJiYXNlNTJcIiB8fFxuICAgIGRpZ2VzdFR5cGUgPT09IFwiYmFzZTU4XCIgfHxcbiAgICBkaWdlc3RUeXBlID09PSBcImJhc2U2MlwiXG4gICkge1xuICAgIHJldHVybiBlbmNvZGVCdWZmZXJUb0Jhc2UoaGFzaC5kaWdlc3QoKSwgZGlnZXN0VHlwZS5zdWJzdHIoNCksIG1heExlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGhhc2guZGlnZXN0KGRpZ2VzdFR5cGUgfHwgXCJoZXhcIikuc3Vic3RyKDAsIG1heExlbmd0aCk7XG4gIH1cbn1cblxudmFyIGdldEhhc2hEaWdlc3RfMSA9IGdldEhhc2hEaWdlc3QkMTtcblxuY29uc3QgcGF0aCQxID0gcmVxdWlyZSQkMDtcbmNvbnN0IGdldEhhc2hEaWdlc3QgPSBnZXRIYXNoRGlnZXN0XzE7XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlTmFtZSQxKGxvYWRlckNvbnRleHQsIG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgZmlsZW5hbWU7XG5cbiAgY29uc3QgaGFzUXVlcnkgPVxuICAgIGxvYWRlckNvbnRleHQucmVzb3VyY2VRdWVyeSAmJiBsb2FkZXJDb250ZXh0LnJlc291cmNlUXVlcnkubGVuZ3RoID4gMTtcblxuICBpZiAodHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZpbGVuYW1lID0gbmFtZShcbiAgICAgIGxvYWRlckNvbnRleHQucmVzb3VyY2VQYXRoLFxuICAgICAgaGFzUXVlcnkgPyBsb2FkZXJDb250ZXh0LnJlc291cmNlUXVlcnkgOiB1bmRlZmluZWRcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGZpbGVuYW1lID0gbmFtZSB8fCBcIltoYXNoXS5bZXh0XVwiO1xuICB9XG5cbiAgY29uc3QgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dDtcbiAgY29uc3QgY29udGVudCA9IG9wdGlvbnMuY29udGVudDtcbiAgY29uc3QgcmVnRXhwID0gb3B0aW9ucy5yZWdFeHA7XG5cbiAgbGV0IGV4dCA9IFwiYmluXCI7XG4gIGxldCBiYXNlbmFtZSA9IFwiZmlsZVwiO1xuICBsZXQgZGlyZWN0b3J5ID0gXCJcIjtcbiAgbGV0IGZvbGRlciA9IFwiXCI7XG4gIGxldCBxdWVyeSA9IFwiXCI7XG5cbiAgaWYgKGxvYWRlckNvbnRleHQucmVzb3VyY2VQYXRoKSB7XG4gICAgY29uc3QgcGFyc2VkID0gcGF0aCQxLnBhcnNlKGxvYWRlckNvbnRleHQucmVzb3VyY2VQYXRoKTtcbiAgICBsZXQgcmVzb3VyY2VQYXRoID0gbG9hZGVyQ29udGV4dC5yZXNvdXJjZVBhdGg7XG5cbiAgICBpZiAocGFyc2VkLmV4dCkge1xuICAgICAgZXh0ID0gcGFyc2VkLmV4dC5zdWJzdHIoMSk7XG4gICAgfVxuXG4gICAgaWYgKHBhcnNlZC5kaXIpIHtcbiAgICAgIGJhc2VuYW1lID0gcGFyc2VkLm5hbWU7XG4gICAgICByZXNvdXJjZVBhdGggPSBwYXJzZWQuZGlyICsgcGF0aCQxLnNlcDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbnRleHQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGRpcmVjdG9yeSA9IHBhdGgkMVxuICAgICAgICAucmVsYXRpdmUoY29udGV4dCwgcmVzb3VyY2VQYXRoICsgXCJfXCIpXG4gICAgICAgIC5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKVxuICAgICAgICAucmVwbGFjZSgvXFwuXFwuKFxcLyk/L2csIFwiXyQxXCIpO1xuICAgICAgZGlyZWN0b3J5ID0gZGlyZWN0b3J5LnN1YnN0cigwLCBkaXJlY3RvcnkubGVuZ3RoIC0gMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpcmVjdG9yeSA9IHJlc291cmNlUGF0aC5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKS5yZXBsYWNlKC9cXC5cXC4oXFwvKT8vZywgXCJfJDFcIik7XG4gICAgfVxuXG4gICAgaWYgKGRpcmVjdG9yeS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGRpcmVjdG9yeSA9IFwiXCI7XG4gICAgfSBlbHNlIGlmIChkaXJlY3RvcnkubGVuZ3RoID4gMSkge1xuICAgICAgZm9sZGVyID0gcGF0aCQxLmJhc2VuYW1lKGRpcmVjdG9yeSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxvYWRlckNvbnRleHQucmVzb3VyY2VRdWVyeSAmJiBsb2FkZXJDb250ZXh0LnJlc291cmNlUXVlcnkubGVuZ3RoID4gMSkge1xuICAgIHF1ZXJ5ID0gbG9hZGVyQ29udGV4dC5yZXNvdXJjZVF1ZXJ5O1xuXG4gICAgY29uc3QgaGFzaElkeCA9IHF1ZXJ5LmluZGV4T2YoXCIjXCIpO1xuXG4gICAgaWYgKGhhc2hJZHggPj0gMCkge1xuICAgICAgcXVlcnkgPSBxdWVyeS5zdWJzdHIoMCwgaGFzaElkeCk7XG4gICAgfVxuICB9XG5cbiAgbGV0IHVybCA9IGZpbGVuYW1lO1xuXG4gIGlmIChjb250ZW50KSB7XG4gICAgLy8gTWF0Y2ggaGFzaCB0ZW1wbGF0ZVxuICAgIHVybCA9IHVybFxuICAgICAgLy8gYGhhc2hgIGFuZCBgY29udGVudGhhc2hgIGFyZSBzYW1lIGluIGBsb2FkZXItdXRpbHNgIGNvbnRleHRcbiAgICAgIC8vIGxldCdzIGtlZXAgYGhhc2hgIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAucmVwbGFjZShcbiAgICAgICAgL1xcWyg/OihbXjpcXF1dKyk6KT8oPzpoYXNofGNvbnRlbnRoYXNoKSg/OjooW2Etel0rXFxkKikpPyg/OjooXFxkKykpP1xcXS9naSxcbiAgICAgICAgKGFsbCwgaGFzaFR5cGUsIGRpZ2VzdFR5cGUsIG1heExlbmd0aCkgPT5cbiAgICAgICAgICBnZXRIYXNoRGlnZXN0KGNvbnRlbnQsIGhhc2hUeXBlLCBkaWdlc3RUeXBlLCBwYXJzZUludChtYXhMZW5ndGgsIDEwKSlcbiAgICAgICk7XG4gIH1cblxuICB1cmwgPSB1cmxcbiAgICAucmVwbGFjZSgvXFxbZXh0XFxdL2dpLCAoKSA9PiBleHQpXG4gICAgLnJlcGxhY2UoL1xcW25hbWVcXF0vZ2ksICgpID0+IGJhc2VuYW1lKVxuICAgIC5yZXBsYWNlKC9cXFtwYXRoXFxdL2dpLCAoKSA9PiBkaXJlY3RvcnkpXG4gICAgLnJlcGxhY2UoL1xcW2ZvbGRlclxcXS9naSwgKCkgPT4gZm9sZGVyKVxuICAgIC5yZXBsYWNlKC9cXFtxdWVyeVxcXS9naSwgKCkgPT4gcXVlcnkpO1xuXG4gIGlmIChyZWdFeHAgJiYgbG9hZGVyQ29udGV4dC5yZXNvdXJjZVBhdGgpIHtcbiAgICBjb25zdCBtYXRjaCA9IGxvYWRlckNvbnRleHQucmVzb3VyY2VQYXRoLm1hdGNoKG5ldyBSZWdFeHAocmVnRXhwKSk7XG5cbiAgICBtYXRjaCAmJlxuICAgICAgbWF0Y2guZm9yRWFjaCgobWF0Y2hlZCwgaSkgPT4ge1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShuZXcgUmVnRXhwKFwiXFxcXFtcIiArIGkgKyBcIlxcXFxdXCIsIFwiaWdcIiksIG1hdGNoZWQpO1xuICAgICAgfSk7XG4gIH1cblxuICBpZiAoXG4gICAgdHlwZW9mIGxvYWRlckNvbnRleHQub3B0aW9ucyA9PT0gXCJvYmplY3RcIiAmJlxuICAgIHR5cGVvZiBsb2FkZXJDb250ZXh0Lm9wdGlvbnMuY3VzdG9tSW50ZXJwb2xhdGVOYW1lID09PSBcImZ1bmN0aW9uXCJcbiAgKSB7XG4gICAgdXJsID0gbG9hZGVyQ29udGV4dC5vcHRpb25zLmN1c3RvbUludGVycG9sYXRlTmFtZS5jYWxsKFxuICAgICAgbG9hZGVyQ29udGV4dCxcbiAgICAgIHVybCxcbiAgICAgIG5hbWUsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59XG5cbnZhciBpbnRlcnBvbGF0ZU5hbWVfMSA9IGludGVycG9sYXRlTmFtZSQxO1xuXG52YXIgaW50ZXJwb2xhdGVOYW1lID0gaW50ZXJwb2xhdGVOYW1lXzE7XG52YXIgcGF0aCA9IHJlcXVpcmUkJDA7XG5cbi8qKlxuICogQHBhcmFtICB7c3RyaW5nfSBwYXR0ZXJuXG4gKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSAge3N0cmluZ30gb3B0aW9ucy5jb250ZXh0XG4gKiBAcGFyYW0gIHtzdHJpbmd9IG9wdGlvbnMuaGFzaFByZWZpeFxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbnZhciBnZW5lcmljTmFtZXMgPSBmdW5jdGlvbiBjcmVhdGVHZW5lcmF0b3IocGF0dGVybiwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGNvbnRleHQgPVxuICAgIG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuY29udGV4dCA9PT0gXCJzdHJpbmdcIlxuICAgICAgPyBvcHRpb25zLmNvbnRleHRcbiAgICAgIDogcHJvY2Vzcy5jd2QoKTtcbiAgdmFyIGhhc2hQcmVmaXggPVxuICAgIG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuaGFzaFByZWZpeCA9PT0gXCJzdHJpbmdcIiA/IG9wdGlvbnMuaGFzaFByZWZpeCA6IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gbG9jYWxOYW1lIFVzdWFsbHkgYSBjbGFzcyBuYW1lXG4gICAqIEBwYXJhbSAge3N0cmluZ30gZmlsZXBhdGggIEFic29sdXRlIHBhdGhcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uIGdlbmVyYXRlKGxvY2FsTmFtZSwgZmlsZXBhdGgpIHtcbiAgICB2YXIgbmFtZSA9IHBhdHRlcm4ucmVwbGFjZSgvXFxbbG9jYWxcXF0vZ2ksIGxvY2FsTmFtZSk7XG4gICAgdmFyIGxvYWRlckNvbnRleHQgPSB7XG4gICAgICByZXNvdXJjZVBhdGg6IGZpbGVwYXRoLFxuICAgIH07XG5cbiAgICB2YXIgbG9hZGVyT3B0aW9ucyA9IHtcbiAgICAgIGNvbnRlbnQ6XG4gICAgICAgIGhhc2hQcmVmaXggK1xuICAgICAgICBwYXRoLnJlbGF0aXZlKGNvbnRleHQsIGZpbGVwYXRoKS5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKSArXG4gICAgICAgIFwiXFx4MDBcIiArXG4gICAgICAgIGxvY2FsTmFtZSxcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgfTtcblxuICAgIHZhciBnZW5lcmljTmFtZSA9IGludGVycG9sYXRlTmFtZShsb2FkZXJDb250ZXh0LCBuYW1lLCBsb2FkZXJPcHRpb25zKTtcbiAgICByZXR1cm4gZ2VuZXJpY05hbWVcbiAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoXCJbXmEtekEtWjAtOVxcXFwtX1xcdTAwQTAtXFx1RkZGRl1cIiwgXCJnXCIpLCBcIi1cIilcbiAgICAgIC5yZXBsYWNlKC9eKCgtP1swLTldKXwtLSkvLCBcIl8kMVwiKTtcbiAgfTtcbn07XG5cbnZhciB1bnF1b3RlJDEgPSB7fTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHVucXVvdGUkMSwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudW5xdW90ZSQxLmRlZmF1bHQgPSB1bnF1b3RlO1xuLy8gY29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2xha2VuZW4vbm9kZS11bnF1b3RlXG52YXIgcmVnID0gL1snXCJdLztcblxuZnVuY3Rpb24gdW5xdW90ZShzdHIpIHtcbiAgaWYgKCFzdHIpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuXG4gIGlmIChyZWcudGVzdChzdHIuY2hhckF0KDApKSkge1xuICAgIHN0ciA9IHN0ci5zdWJzdHIoMSk7XG4gIH1cblxuICBpZiAocmVnLnRlc3Qoc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSkpKSB7XG4gICAgc3RyID0gc3RyLnN1YnN0cigwLCBzdHIubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuXG52YXIgcGFyc2VyJDEgPSB7fTtcblxudmFyIGxpYiA9IHt9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkobGliLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5saWIucmVwbGFjZUFsbCA9IHJlcGxhY2VBbGw7XG52YXIgbWF0Y2hDb25zdE5hbWUgPSAvWyQjXT9bXFx3LVxcLl0rL2c7XG5cbmZ1bmN0aW9uIHJlcGxhY2VBbGwocmVwbGFjZW1lbnRzLCB0ZXh0KSB7XG4gIHZhciBtYXRjaGVzID0gdm9pZCAwO1xuICB3aGlsZSAobWF0Y2hlcyA9IG1hdGNoQ29uc3ROYW1lLmV4ZWModGV4dCkpIHtcbiAgICB2YXIgcmVwbGFjZW1lbnQgPSByZXBsYWNlbWVudHNbbWF0Y2hlc1swXV07XG4gICAgaWYgKHJlcGxhY2VtZW50KSB7XG4gICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCBtYXRjaGVzLmluZGV4KSArIHJlcGxhY2VtZW50ICsgdGV4dC5zbGljZShtYXRjaENvbnN0TmFtZS5sYXN0SW5kZXgpO1xuICAgICAgbWF0Y2hDb25zdE5hbWUubGFzdEluZGV4IC09IG1hdGNoZXNbMF0ubGVuZ3RoIC0gcmVwbGFjZW1lbnQubGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGV4dDtcbn1cblxubGliLmRlZmF1bHQgPSBmdW5jdGlvbiAoY3NzLCB0cmFuc2xhdGlvbnMpIHtcbiAgY3NzLndhbGtEZWNscyhmdW5jdGlvbiAoZGVjbCkge1xuICAgIHJldHVybiBkZWNsLnZhbHVlID0gcmVwbGFjZUFsbCh0cmFuc2xhdGlvbnMsIGRlY2wudmFsdWUpO1xuICB9KTtcbiAgY3NzLndhbGtBdFJ1bGVzKCdtZWRpYScsIGZ1bmN0aW9uIChhdFJ1bGUpIHtcbiAgICByZXR1cm4gYXRSdWxlLnBhcmFtcyA9IHJlcGxhY2VBbGwodHJhbnNsYXRpb25zLCBhdFJ1bGUucGFyYW1zKTtcbiAgfSk7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocGFyc2VyJDEsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnBhcnNlciQxLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfaWNzc1JlcGxhY2VTeW1ib2xzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCQ2KGxpYik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQkNihvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Nzcy1tb2R1bGVzL2Nzcy1tb2R1bGVzLWxvYWRlci1jb3JlXG5jb25zdCBpbXBvcnRSZWdleHAgPSAvXjppbXBvcnRcXCgoLispXFwpJC87XG5cbmNsYXNzIFBhcnNlciB7XG4gIGNvbnN0cnVjdG9yKHBhdGhGZXRjaGVyLCB0cmFjZSkge1xuICAgIHRoaXMucGF0aEZldGNoZXIgPSBwYXRoRmV0Y2hlcjtcbiAgICB0aGlzLnBsdWdpbiA9IHRoaXMucGx1Z2luLmJpbmQodGhpcyk7XG4gICAgdGhpcy5leHBvcnRUb2tlbnMgPSB7fTtcbiAgICB0aGlzLnRyYW5zbGF0aW9ucyA9IHt9O1xuICAgIHRoaXMudHJhY2UgPSB0cmFjZTtcbiAgfVxuXG4gIHBsdWdpbigpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIHJldHVybiB7XG4gICAgICBwb3N0Y3NzUGx1Z2luOiBcImNzcy1tb2R1bGVzLXBhcnNlclwiLFxuXG4gICAgICBPbmNlRXhpdChjc3MpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHBhcnNlci5mZXRjaEFsbEltcG9ydHMoY3NzKSkudGhlbigoKSA9PiBwYXJzZXIubGlua0ltcG9ydGVkU3ltYm9scyhjc3MpKS50aGVuKCgpID0+IHBhcnNlci5leHRyYWN0RXhwb3J0cyhjc3MpKTtcbiAgICAgIH1cblxuICAgIH07XG4gIH1cblxuICBmZXRjaEFsbEltcG9ydHMoY3NzKSB7XG4gICAgbGV0IGltcG9ydHMgPSBbXTtcbiAgICBjc3MuZWFjaChub2RlID0+IHtcbiAgICAgIGlmIChub2RlLnR5cGUgPT0gXCJydWxlXCIgJiYgbm9kZS5zZWxlY3Rvci5tYXRjaChpbXBvcnRSZWdleHApKSB7XG4gICAgICAgIGltcG9ydHMucHVzaCh0aGlzLmZldGNoSW1wb3J0KG5vZGUsIGNzcy5zb3VyY2UuaW5wdXQuZnJvbSwgaW1wb3J0cy5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaW1wb3J0cztcbiAgfVxuXG4gIGxpbmtJbXBvcnRlZFN5bWJvbHMoY3NzKSB7XG4gICAgKDAsIF9pY3NzUmVwbGFjZVN5bWJvbHMuZGVmYXVsdCkoY3NzLCB0aGlzLnRyYW5zbGF0aW9ucyk7XG4gIH1cblxuICBleHRyYWN0RXhwb3J0cyhjc3MpIHtcbiAgICBjc3MuZWFjaChub2RlID0+IHtcbiAgICAgIGlmIChub2RlLnR5cGUgPT0gXCJydWxlXCIgJiYgbm9kZS5zZWxlY3RvciA9PSBcIjpleHBvcnRcIikgdGhpcy5oYW5kbGVFeHBvcnQobm9kZSk7XG4gICAgfSk7XG4gIH1cblxuICBoYW5kbGVFeHBvcnQoZXhwb3J0Tm9kZSkge1xuICAgIGV4cG9ydE5vZGUuZWFjaChkZWNsID0+IHtcbiAgICAgIGlmIChkZWNsLnR5cGUgPT0gXCJkZWNsXCIpIHtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy50cmFuc2xhdGlvbnMpLmZvckVhY2godHJhbnNsYXRpb24gPT4ge1xuICAgICAgICAgIGRlY2wudmFsdWUgPSBkZWNsLnZhbHVlLnJlcGxhY2UodHJhbnNsYXRpb24sIHRoaXMudHJhbnNsYXRpb25zW3RyYW5zbGF0aW9uXSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV4cG9ydFRva2Vuc1tkZWNsLnByb3BdID0gZGVjbC52YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBleHBvcnROb2RlLnJlbW92ZSgpO1xuICB9XG5cbiAgZmV0Y2hJbXBvcnQoaW1wb3J0Tm9kZSwgcmVsYXRpdmVUbywgZGVwTnIpIHtcbiAgICBsZXQgZmlsZSA9IGltcG9ydE5vZGUuc2VsZWN0b3IubWF0Y2goaW1wb3J0UmVnZXhwKVsxXSxcbiAgICAgICAgZGVwVHJhY2UgPSB0aGlzLnRyYWNlICsgU3RyaW5nLmZyb21DaGFyQ29kZShkZXBOcik7XG4gICAgcmV0dXJuIHRoaXMucGF0aEZldGNoZXIoZmlsZSwgcmVsYXRpdmVUbywgZGVwVHJhY2UpLnRoZW4oZXhwb3J0cyA9PiB7XG4gICAgICBpbXBvcnROb2RlLmVhY2goZGVjbCA9PiB7XG4gICAgICAgIGlmIChkZWNsLnR5cGUgPT0gXCJkZWNsXCIpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zbGF0aW9uc1tkZWNsLnByb3BdID0gZXhwb3J0c1tkZWNsLnZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpbXBvcnROb2RlLnJlbW92ZSgpO1xuICAgIH0sIGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgfVxuXG59XG5cbnBhcnNlciQxLmRlZmF1bHQgPSBQYXJzZXI7XG5cbnZhciBsb2FkZXIgPSB7fTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGxvYWRlciwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xubG9hZGVyLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfcG9zdGNzcyQxID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCQ1KHJlcXVpcmUkJDAkMSk7XG5cbnZhciBfZnMkMSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQkNShyZXF1aXJlJCQwX19kZWZhdWx0KTtcblxudmFyIF9wYXRoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCQ1KHJlcXVpcmUkJDApO1xuXG52YXIgX3BhcnNlciQxID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCQ1KHBhcnNlciQxKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCQ1KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vY3NzLW1vZHVsZXMvY3NzLW1vZHVsZXMtbG9hZGVyLWNvcmVcbmNsYXNzIENvcmUge1xuICBjb25zdHJ1Y3RvcihwbHVnaW5zKSB7XG4gICAgdGhpcy5wbHVnaW5zID0gcGx1Z2lucyB8fCBDb3JlLmRlZmF1bHRQbHVnaW5zO1xuICB9XG5cbiAgbG9hZChzb3VyY2VTdHJpbmcsIHNvdXJjZVBhdGgsIHRyYWNlLCBwYXRoRmV0Y2hlcikge1xuICAgIGxldCBwYXJzZXIgPSBuZXcgX3BhcnNlciQxLmRlZmF1bHQocGF0aEZldGNoZXIsIHRyYWNlKTtcbiAgICByZXR1cm4gKDAsIF9wb3N0Y3NzJDEuZGVmYXVsdCkodGhpcy5wbHVnaW5zLmNvbmNhdChbcGFyc2VyLnBsdWdpbigpXSkpLnByb2Nlc3Moc291cmNlU3RyaW5nLCB7XG4gICAgICBmcm9tOiBzb3VyY2VQYXRoXG4gICAgfSkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5qZWN0YWJsZVNvdXJjZTogcmVzdWx0LmNzcyxcbiAgICAgICAgZXhwb3J0VG9rZW5zOiBwYXJzZXIuZXhwb3J0VG9rZW5zXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbn0gLy8gU29ydHMgZGVwZW5kZW5jaWVzIGluIHRoZSBmb2xsb3dpbmcgd2F5OlxuLy8gQUFBIGNvbWVzIGJlZm9yZSBBQSBhbmQgQVxuLy8gQUIgY29tZXMgYWZ0ZXIgQUEgYW5kIGJlZm9yZSBBXG4vLyBBbGwgQnMgY29tZSBhZnRlciBhbGwgQXNcbi8vIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBmaWxlcyBhcmUgYWx3YXlzIHJldHVybmVkIGluIHRoZSBmb2xsb3dpbmcgb3JkZXI6XG4vLyAtIEluIHRoZSBvcmRlciB0aGV5IHdlcmUgcmVxdWlyZWQsIGV4Y2VwdFxuLy8gLSBBZnRlciBhbGwgdGhlaXIgZGVwZW5kZW5jaWVzXG5cblxuY29uc3QgdHJhY2VLZXlTb3J0ZXIgPSAoYSwgYikgPT4ge1xuICBpZiAoYS5sZW5ndGggPCBiLmxlbmd0aCkge1xuICAgIHJldHVybiBhIDwgYi5zdWJzdHJpbmcoMCwgYS5sZW5ndGgpID8gLTEgOiAxO1xuICB9IGVsc2UgaWYgKGEubGVuZ3RoID4gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYS5zdWJzdHJpbmcoMCwgYi5sZW5ndGgpIDw9IGIgPyAtMSA6IDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiAxO1xuICB9XG59O1xuXG5jbGFzcyBGaWxlU3lzdGVtTG9hZGVyIHtcbiAgY29uc3RydWN0b3Iocm9vdCwgcGx1Z2lucykge1xuICAgIGlmIChyb290ID09PSAnLycgJiYgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgICBjb25zdCBjd2REcml2ZSA9IHByb2Nlc3MuY3dkKCkuc2xpY2UoMCwgMyk7XG5cbiAgICAgIGlmICghL15bQS1aXTpcXFxcJC8udGVzdChjd2REcml2ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gb2J0YWluIHJvb3QgZnJvbSBcIiR7cHJvY2Vzcy5jd2QoKX1cIi5gKTtcbiAgICAgIH1cblxuICAgICAgcm9vdCA9IGN3ZERyaXZlO1xuICAgIH1cblxuICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgdGhpcy5zb3VyY2VzID0ge307XG4gICAgdGhpcy50cmFjZXMgPSB7fTtcbiAgICB0aGlzLmltcG9ydE5yID0gMDtcbiAgICB0aGlzLmNvcmUgPSBuZXcgQ29yZShwbHVnaW5zKTtcbiAgICB0aGlzLnRva2Vuc0J5RmlsZSA9IHt9O1xuICB9XG5cbiAgZmV0Y2goX25ld1BhdGgsIHJlbGF0aXZlVG8sIF90cmFjZSkge1xuICAgIGxldCBuZXdQYXRoID0gX25ld1BhdGgucmVwbGFjZSgvXltcIiddfFtcIiddJC9nLCBcIlwiKSxcbiAgICAgICAgdHJhY2UgPSBfdHJhY2UgfHwgU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLmltcG9ydE5yKyspO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCByZWxhdGl2ZURpciA9IF9wYXRoLmRlZmF1bHQuZGlybmFtZShyZWxhdGl2ZVRvKSxcbiAgICAgICAgICByb290UmVsYXRpdmVQYXRoID0gX3BhdGguZGVmYXVsdC5yZXNvbHZlKHJlbGF0aXZlRGlyLCBuZXdQYXRoKSxcbiAgICAgICAgICBmaWxlUmVsYXRpdmVQYXRoID0gX3BhdGguZGVmYXVsdC5yZXNvbHZlKF9wYXRoLmRlZmF1bHQucmVzb2x2ZSh0aGlzLnJvb3QsIHJlbGF0aXZlRGlyKSwgbmV3UGF0aCk7IC8vIGlmIHRoZSBwYXRoIGlzIG5vdCByZWxhdGl2ZSBvciBhYnNvbHV0ZSwgdHJ5IHRvIHJlc29sdmUgaXQgaW4gbm9kZV9tb2R1bGVzXG5cblxuICAgICAgaWYgKG5ld1BhdGhbMF0gIT09IFwiLlwiICYmICFfcGF0aC5kZWZhdWx0LmlzQWJzb2x1dGUobmV3UGF0aCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmaWxlUmVsYXRpdmVQYXRoID0gcmVxdWlyZS5yZXNvbHZlKG5ld1BhdGgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7Ly8gbm9vcFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRva2VucyA9IHRoaXMudG9rZW5zQnlGaWxlW2ZpbGVSZWxhdGl2ZVBhdGhdO1xuXG4gICAgICBpZiAodG9rZW5zKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKHRva2Vucyk7XG4gICAgICB9XG5cbiAgICAgIF9mcyQxLmRlZmF1bHQucmVhZEZpbGUoZmlsZVJlbGF0aXZlUGF0aCwgXCJ1dGYtOFwiLCAoZXJyLCBzb3VyY2UpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmVqZWN0KGVycik7XG4gICAgICAgIHRoaXMuY29yZS5sb2FkKHNvdXJjZSwgcm9vdFJlbGF0aXZlUGF0aCwgdHJhY2UsIHRoaXMuZmV0Y2guYmluZCh0aGlzKSkudGhlbigoe1xuICAgICAgICAgIGluamVjdGFibGVTb3VyY2UsXG4gICAgICAgICAgZXhwb3J0VG9rZW5zXG4gICAgICAgIH0pID0+IHtcbiAgICAgICAgICB0aGlzLnNvdXJjZXNbZmlsZVJlbGF0aXZlUGF0aF0gPSBpbmplY3RhYmxlU291cmNlO1xuICAgICAgICAgIHRoaXMudHJhY2VzW3RyYWNlXSA9IGZpbGVSZWxhdGl2ZVBhdGg7XG4gICAgICAgICAgdGhpcy50b2tlbnNCeUZpbGVbZmlsZVJlbGF0aXZlUGF0aF0gPSBleHBvcnRUb2tlbnM7XG4gICAgICAgICAgcmVzb2x2ZShleHBvcnRUb2tlbnMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgZmluYWxTb3VyY2UoKSB7XG4gICAgY29uc3QgdHJhY2VzID0gdGhpcy50cmFjZXM7XG4gICAgY29uc3Qgc291cmNlcyA9IHRoaXMuc291cmNlcztcbiAgICBsZXQgd3JpdHRlbiA9IG5ldyBTZXQoKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModHJhY2VzKS5zb3J0KHRyYWNlS2V5U29ydGVyKS5tYXAoa2V5ID0+IHtcbiAgICAgIGNvbnN0IGZpbGVuYW1lID0gdHJhY2VzW2tleV07XG5cbiAgICAgIGlmICh3cml0dGVuLmhhcyhmaWxlbmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHdyaXR0ZW4uYWRkKGZpbGVuYW1lKTtcbiAgICAgIHJldHVybiBzb3VyY2VzW2ZpbGVuYW1lXTtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9XG5cbn1cblxubG9hZGVyLmRlZmF1bHQgPSBGaWxlU3lzdGVtTG9hZGVyO1xuXG52YXIgZ2VuZXJhdGVTY29wZWROYW1lJDEgPSB7fTtcblxuZnVuY3Rpb24gaGFzaChzdHIpIHtcbiAgdmFyIGhhc2ggPSA1MzgxLFxuICAgICAgaSAgICA9IHN0ci5sZW5ndGg7XG5cbiAgd2hpbGUoaSkge1xuICAgIGhhc2ggPSAoaGFzaCAqIDMzKSBeIHN0ci5jaGFyQ29kZUF0KC0taSk7XG4gIH1cblxuICAvKiBKYXZhU2NyaXB0IGRvZXMgYml0d2lzZSBvcGVyYXRpb25zIChsaWtlIFhPUiwgYWJvdmUpIG9uIDMyLWJpdCBzaWduZWRcbiAgICogaW50ZWdlcnMuIFNpbmNlIHdlIHdhbnQgdGhlIHJlc3VsdHMgdG8gYmUgYWx3YXlzIHBvc2l0aXZlLCBjb252ZXJ0IHRoZVxuICAgKiBzaWduZWQgaW50IHRvIGFuIHVuc2lnbmVkIGJ5IGRvaW5nIGFuIHVuc2lnbmVkIGJpdHNoaWZ0LiAqL1xuICByZXR1cm4gaGFzaCA+Pj4gMDtcbn1cblxudmFyIHN0cmluZ0hhc2ggPSBoYXNoO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZ2VuZXJhdGVTY29wZWROYW1lJDEsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmdlbmVyYXRlU2NvcGVkTmFtZSQxLmRlZmF1bHQgPSBnZW5lcmF0ZVNjb3BlZE5hbWU7XG5cbnZhciBfc3RyaW5nSGFzaCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQkNChzdHJpbmdIYXNoKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCQ0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVNjb3BlZE5hbWUobmFtZSwgZmlsZW5hbWUsIGNzcykge1xuICBjb25zdCBpID0gY3NzLmluZGV4T2YoYC4ke25hbWV9YCk7XG4gIGNvbnN0IGxpbmVOdW1iZXIgPSBjc3Muc3Vic3RyKDAsIGkpLnNwbGl0KC9bXFxyXFxuXS8pLmxlbmd0aDtcbiAgY29uc3QgaGFzaCA9ICgwLCBfc3RyaW5nSGFzaC5kZWZhdWx0KShjc3MpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMCwgNSk7XG4gIHJldHVybiBgXyR7bmFtZX1fJHtoYXNofV8ke2xpbmVOdW1iZXJ9YDtcbn1cblxudmFyIHNhdmVKU09OJDEgPSB7fTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNhdmVKU09OJDEsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnNhdmVKU09OJDEuZGVmYXVsdCA9IHNhdmVKU09OO1xuXG52YXIgX2ZzID0gcmVxdWlyZSQkMF9fZGVmYXVsdDtcblxuZnVuY3Rpb24gc2F2ZUpTT04oY3NzRmlsZSwganNvbikge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICgwLCBfZnMud3JpdGVGaWxlKShgJHtjc3NGaWxlfS5qc29uYCwgSlNPTi5zdHJpbmdpZnkoanNvbiksIGUgPT4gZSA/IHJlamVjdChlKSA6IHJlc29sdmUoanNvbikpO1xuICB9KTtcbn1cblxudmFyIGJlaGF2aW91cnMkMSA9IHt9O1xuXG52YXIgc3JjJDQgPSB7ZXhwb3J0czoge319O1xuXG52YXIgZGlzdCA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBwcm9jZXNzb3IgPSB7ZXhwb3J0czoge319O1xuXG52YXIgcGFyc2VyID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIHJvb3QkMSA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBjb250YWluZXIgPSB7ZXhwb3J0czoge319O1xuXG52YXIgbm9kZSQxID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIHV0aWwgPSB7fTtcblxudmFyIHVuZXNjID0ge2V4cG9ydHM6IHt9fTtcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHVuZXNjO1xuXG5cdC8vIE1hbnkgdGhhbmtzIGZvciB0aGlzIHBvc3Qgd2hpY2ggbWFkZSB0aGlzIG1pZ3JhdGlvbiBtdWNoIGVhc2llci5cblx0Ly8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2Nzcy1lc2NhcGVzXG5cblx0LyoqXG5cdCAqIFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFxuXHQgKiBAcmV0dXJucyB7W3N0cmluZywgbnVtYmVyXXx1bmRlZmluZWR9XG5cdCAqL1xuXHRmdW5jdGlvbiBnb2JibGVIZXgoc3RyKSB7XG5cdCAgdmFyIGxvd2VyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG5cdCAgdmFyIGhleCA9ICcnO1xuXHQgIHZhciBzcGFjZVRlcm1pbmF0ZWQgPSBmYWxzZTtcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgNiAmJiBsb3dlcltpXSAhPT0gdW5kZWZpbmVkOyBpKyspIHtcblx0ICAgIHZhciBjb2RlID0gbG93ZXIuY2hhckNvZGVBdChpKTsgLy8gY2hlY2sgdG8gc2VlIGlmIHdlIGFyZSBkZWFsaW5nIHdpdGggYSB2YWxpZCBoZXggY2hhciBbYS1mfDAtOV1cblxuXHQgICAgdmFyIHZhbGlkID0gY29kZSA+PSA5NyAmJiBjb2RlIDw9IDEwMiB8fCBjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTc7IC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3Mtc3ludGF4LyNjb25zdW1lLWVzY2FwZWQtY29kZS1wb2ludFxuXG5cdCAgICBzcGFjZVRlcm1pbmF0ZWQgPSBjb2RlID09PSAzMjtcblxuXHQgICAgaWYgKCF2YWxpZCkge1xuXHQgICAgICBicmVhaztcblx0ICAgIH1cblxuXHQgICAgaGV4ICs9IGxvd2VyW2ldO1xuXHQgIH1cblxuXHQgIGlmIChoZXgubGVuZ3RoID09PSAwKSB7XG5cdCAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgIH1cblxuXHQgIHZhciBjb2RlUG9pbnQgPSBwYXJzZUludChoZXgsIDE2KTtcblx0ICB2YXIgaXNTdXJyb2dhdGUgPSBjb2RlUG9pbnQgPj0gMHhEODAwICYmIGNvZGVQb2ludCA8PSAweERGRkY7IC8vIEFkZCBzcGVjaWFsIGNhc2UgZm9yXG5cdCAgLy8gXCJJZiB0aGlzIG51bWJlciBpcyB6ZXJvLCBvciBpcyBmb3IgYSBzdXJyb2dhdGUsIG9yIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSBhbGxvd2VkIGNvZGUgcG9pbnRcIlxuXHQgIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3Mtc3ludGF4LyNtYXhpbXVtLWFsbG93ZWQtY29kZS1wb2ludFxuXG5cdCAgaWYgKGlzU3Vycm9nYXRlIHx8IGNvZGVQb2ludCA9PT0gMHgwMDAwIHx8IGNvZGVQb2ludCA+IDB4MTBGRkZGKSB7XG5cdCAgICByZXR1cm4gW1wiXFx1RkZGRFwiLCBoZXgubGVuZ3RoICsgKHNwYWNlVGVybWluYXRlZCA/IDEgOiAwKV07XG5cdCAgfVxuXG5cdCAgcmV0dXJuIFtTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlUG9pbnQpLCBoZXgubGVuZ3RoICsgKHNwYWNlVGVybWluYXRlZCA/IDEgOiAwKV07XG5cdH1cblxuXHR2YXIgQ09OVEFJTlNfRVNDQVBFID0gL1xcXFwvO1xuXG5cdGZ1bmN0aW9uIHVuZXNjKHN0cikge1xuXHQgIHZhciBuZWVkVG9Qcm9jZXNzID0gQ09OVEFJTlNfRVNDQVBFLnRlc3Qoc3RyKTtcblxuXHQgIGlmICghbmVlZFRvUHJvY2Vzcykge1xuXHQgICAgcmV0dXJuIHN0cjtcblx0ICB9XG5cblx0ICB2YXIgcmV0ID0gXCJcIjtcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAoc3RyW2ldID09PSBcIlxcXFxcIikge1xuXHQgICAgICB2YXIgZ29iYmxlZCA9IGdvYmJsZUhleChzdHIuc2xpY2UoaSArIDEsIGkgKyA3KSk7XG5cblx0ICAgICAgaWYgKGdvYmJsZWQgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHJldCArPSBnb2JibGVkWzBdO1xuXHQgICAgICAgIGkgKz0gZ29iYmxlZFsxXTtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfSAvLyBSZXRhaW4gYSBwYWlyIG9mIFxcXFwgaWYgZG91YmxlIGVzY2FwZWQgYFxcXFxcXFxcYFxuXHQgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9zdGNzcy9wb3N0Y3NzLXNlbGVjdG9yLXBhcnNlci9jb21taXQvMjY4YzlhNzY1NmZiNTNmNTQzZGM2MjBhYTViNzNhMzBlYzNmZjIwZVxuXG5cblx0ICAgICAgaWYgKHN0cltpICsgMV0gPT09IFwiXFxcXFwiKSB7XG5cdCAgICAgICAgcmV0ICs9IFwiXFxcXFwiO1xuXHQgICAgICAgIGkrKztcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfSAvLyBpZiBcXFxcIGlzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZyByZXRhaW4gaXRcblx0ICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Bvc3Rjc3MvcG9zdGNzcy1zZWxlY3Rvci1wYXJzZXIvY29tbWl0LzAxYTZiMzQ2ZTM2MTJjZTFhYjIwMjE5YWNjMjZhYmRjMjU5Y2NlZmJcblxuXG5cdCAgICAgIGlmIChzdHIubGVuZ3RoID09PSBpICsgMSkge1xuXHQgICAgICAgIHJldCArPSBzdHJbaV07XG5cdCAgICAgIH1cblxuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblxuXHQgICAgcmV0ICs9IHN0cltpXTtcblx0ICB9XG5cblx0ICByZXR1cm4gcmV0O1xuXHR9XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59ICh1bmVzYywgdW5lc2MuZXhwb3J0cykpO1xuXG52YXIgZ2V0UHJvcCA9IHtleHBvcnRzOiB7fX07XG5cbihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBnZXRQcm9wO1xuXG5cdGZ1bmN0aW9uIGdldFByb3Aob2JqKSB7XG5cdCAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHByb3BzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcblx0ICAgIHByb3BzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0ICB9XG5cblx0ICB3aGlsZSAocHJvcHMubGVuZ3RoID4gMCkge1xuXHQgICAgdmFyIHByb3AgPSBwcm9wcy5zaGlmdCgpO1xuXG5cdCAgICBpZiAoIW9ialtwcm9wXSkge1xuXHQgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgICAgfVxuXG5cdCAgICBvYmogPSBvYmpbcHJvcF07XG5cdCAgfVxuXG5cdCAgcmV0dXJuIG9iajtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufSAoZ2V0UHJvcCwgZ2V0UHJvcC5leHBvcnRzKSk7XG5cbnZhciBlbnN1cmVPYmplY3QgPSB7ZXhwb3J0czoge319O1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZW5zdXJlT2JqZWN0O1xuXG5cdGZ1bmN0aW9uIGVuc3VyZU9iamVjdChvYmopIHtcblx0ICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcHJvcHMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuXHQgICAgcHJvcHNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuXHQgIH1cblxuXHQgIHdoaWxlIChwcm9wcy5sZW5ndGggPiAwKSB7XG5cdCAgICB2YXIgcHJvcCA9IHByb3BzLnNoaWZ0KCk7XG5cblx0ICAgIGlmICghb2JqW3Byb3BdKSB7XG5cdCAgICAgIG9ialtwcm9wXSA9IHt9O1xuXHQgICAgfVxuXG5cdCAgICBvYmogPSBvYmpbcHJvcF07XG5cdCAgfVxuXHR9XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59IChlbnN1cmVPYmplY3QsIGVuc3VyZU9iamVjdC5leHBvcnRzKSk7XG5cbnZhciBzdHJpcENvbW1lbnRzID0ge2V4cG9ydHM6IHt9fTtcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHN0cmlwQ29tbWVudHM7XG5cblx0ZnVuY3Rpb24gc3RyaXBDb21tZW50cyhzdHIpIHtcblx0ICB2YXIgcyA9IFwiXCI7XG5cdCAgdmFyIGNvbW1lbnRTdGFydCA9IHN0ci5pbmRleE9mKFwiLypcIik7XG5cdCAgdmFyIGxhc3RFbmQgPSAwO1xuXG5cdCAgd2hpbGUgKGNvbW1lbnRTdGFydCA+PSAwKSB7XG5cdCAgICBzID0gcyArIHN0ci5zbGljZShsYXN0RW5kLCBjb21tZW50U3RhcnQpO1xuXHQgICAgdmFyIGNvbW1lbnRFbmQgPSBzdHIuaW5kZXhPZihcIiovXCIsIGNvbW1lbnRTdGFydCArIDIpO1xuXG5cdCAgICBpZiAoY29tbWVudEVuZCA8IDApIHtcblx0ICAgICAgcmV0dXJuIHM7XG5cdCAgICB9XG5cblx0ICAgIGxhc3RFbmQgPSBjb21tZW50RW5kICsgMjtcblx0ICAgIGNvbW1lbnRTdGFydCA9IHN0ci5pbmRleE9mKFwiLypcIiwgbGFzdEVuZCk7XG5cdCAgfVxuXG5cdCAgcyA9IHMgKyBzdHIuc2xpY2UobGFzdEVuZCk7XG5cdCAgcmV0dXJuIHM7XG5cdH1cblxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn0gKHN0cmlwQ29tbWVudHMsIHN0cmlwQ29tbWVudHMuZXhwb3J0cykpO1xuXG51dGlsLl9fZXNNb2R1bGUgPSB0cnVlO1xudXRpbC5zdHJpcENvbW1lbnRzID0gdXRpbC5lbnN1cmVPYmplY3QgPSB1dGlsLmdldFByb3AgPSB1dGlsLnVuZXNjID0gdm9pZCAwO1xuXG52YXIgX3VuZXNjID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCQzKHVuZXNjLmV4cG9ydHMpO1xuXG51dGlsLnVuZXNjID0gX3VuZXNjW1wiZGVmYXVsdFwiXTtcblxudmFyIF9nZXRQcm9wID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCQzKGdldFByb3AuZXhwb3J0cyk7XG5cbnV0aWwuZ2V0UHJvcCA9IF9nZXRQcm9wW1wiZGVmYXVsdFwiXTtcblxudmFyIF9lbnN1cmVPYmplY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0JDMoZW5zdXJlT2JqZWN0LmV4cG9ydHMpO1xuXG51dGlsLmVuc3VyZU9iamVjdCA9IF9lbnN1cmVPYmplY3RbXCJkZWZhdWx0XCJdO1xuXG52YXIgX3N0cmlwQ29tbWVudHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0JDMoc3RyaXBDb21tZW50cy5leHBvcnRzKTtcblxudXRpbC5zdHJpcENvbW1lbnRzID0gX3N0cmlwQ29tbWVudHNbXCJkZWZhdWx0XCJdO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0JDMob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG5cdHZhciBfdXRpbCA9IHV0aWw7XG5cblx0ZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5cdGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cblx0dmFyIGNsb25lTm9kZSA9IGZ1bmN0aW9uIGNsb25lTm9kZShvYmosIHBhcmVudCkge1xuXHQgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcblx0ICAgIHJldHVybiBvYmo7XG5cdCAgfVxuXG5cdCAgdmFyIGNsb25lZCA9IG5ldyBvYmouY29uc3RydWN0b3IoKTtcblxuXHQgIGZvciAodmFyIGkgaW4gb2JqKSB7XG5cdCAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHZhbHVlID0gb2JqW2ldO1xuXHQgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0ICAgIGlmIChpID09PSAncGFyZW50JyAmJiB0eXBlID09PSAnb2JqZWN0Jykge1xuXHQgICAgICBpZiAocGFyZW50KSB7XG5cdCAgICAgICAgY2xvbmVkW2ldID0gcGFyZW50O1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0ICAgICAgY2xvbmVkW2ldID0gdmFsdWUubWFwKGZ1bmN0aW9uIChqKSB7XG5cdCAgICAgICAgcmV0dXJuIGNsb25lTm9kZShqLCBjbG9uZWQpO1xuXHQgICAgICB9KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGNsb25lZFtpXSA9IGNsb25lTm9kZSh2YWx1ZSwgY2xvbmVkKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gY2xvbmVkO1xuXHR9O1xuXG5cdHZhciBOb2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBOb2RlKG9wdHMpIHtcblx0ICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcblx0ICAgICAgb3B0cyA9IHt9O1xuXHQgICAgfVxuXG5cdCAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdHMpO1xuXHQgICAgdGhpcy5zcGFjZXMgPSB0aGlzLnNwYWNlcyB8fCB7fTtcblx0ICAgIHRoaXMuc3BhY2VzLmJlZm9yZSA9IHRoaXMuc3BhY2VzLmJlZm9yZSB8fCAnJztcblx0ICAgIHRoaXMuc3BhY2VzLmFmdGVyID0gdGhpcy5zcGFjZXMuYWZ0ZXIgfHwgJyc7XG5cdCAgfVxuXG5cdCAgdmFyIF9wcm90byA9IE5vZGUucHJvdG90eXBlO1xuXG5cdCAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcblx0ICAgIGlmICh0aGlzLnBhcmVudCkge1xuXHQgICAgICB0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgX3Byb3RvLnJlcGxhY2VXaXRoID0gZnVuY3Rpb24gcmVwbGFjZVdpdGgoKSB7XG5cdCAgICBpZiAodGhpcy5wYXJlbnQpIHtcblx0ICAgICAgZm9yICh2YXIgaW5kZXggaW4gYXJndW1lbnRzKSB7XG5cdCAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMsIGFyZ3VtZW50c1tpbmRleF0pO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5yZW1vdmUoKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIF9wcm90by5uZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcblx0ICAgIHJldHVybiB0aGlzLnBhcmVudC5hdCh0aGlzLnBhcmVudC5pbmRleCh0aGlzKSArIDEpO1xuXHQgIH07XG5cblx0ICBfcHJvdG8ucHJldiA9IGZ1bmN0aW9uIHByZXYoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5wYXJlbnQuYXQodGhpcy5wYXJlbnQuaW5kZXgodGhpcykgLSAxKTtcblx0ICB9O1xuXG5cdCAgX3Byb3RvLmNsb25lID0gZnVuY3Rpb24gY2xvbmUob3ZlcnJpZGVzKSB7XG5cdCAgICBpZiAob3ZlcnJpZGVzID09PSB2b2lkIDApIHtcblx0ICAgICAgb3ZlcnJpZGVzID0ge307XG5cdCAgICB9XG5cblx0ICAgIHZhciBjbG9uZWQgPSBjbG9uZU5vZGUodGhpcyk7XG5cblx0ICAgIGZvciAodmFyIG5hbWUgaW4gb3ZlcnJpZGVzKSB7XG5cdCAgICAgIGNsb25lZFtuYW1lXSA9IG92ZXJyaWRlc1tuYW1lXTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGNsb25lZDtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogU29tZSBub24tc3RhbmRhcmQgc3ludGF4IGRvZXNuJ3QgZm9sbG93IG5vcm1hbCBlc2NhcGluZyBydWxlcyBmb3IgY3NzLlxuXHQgICAqIFRoaXMgYWxsb3dzIG5vbiBzdGFuZGFyZCBzeW50YXggdG8gYmUgYXBwZW5kZWQgdG8gYW4gZXhpc3RpbmcgcHJvcGVydHlcblx0ICAgKiBieSBzcGVjaWZ5aW5nIHRoZSBlc2NhcGVkIHZhbHVlLiBCeSBzcGVjaWZ5aW5nIHRoZSBlc2NhcGVkIHZhbHVlLFxuXHQgICAqIGlsbGVnYWwgY2hhcmFjdGVycyBhcmUgYWxsb3dlZCB0byBiZSBkaXJlY3RseSBpbnNlcnRlZCBpbnRvIGNzcyBvdXRwdXQuXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIHByb3BlcnR5IHRvIHNldFxuXHQgICAqIEBwYXJhbSB7YW55fSB2YWx1ZSB0aGUgdW5lc2NhcGVkIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZUVzY2FwZWQgb3B0aW9uYWwuIHRoZSBlc2NhcGVkIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS5cblx0ICAgKi9cblx0ICA7XG5cblx0ICBfcHJvdG8uYXBwZW5kVG9Qcm9wZXJ0eUFuZEVzY2FwZSA9IGZ1bmN0aW9uIGFwcGVuZFRvUHJvcGVydHlBbmRFc2NhcGUobmFtZSwgdmFsdWUsIHZhbHVlRXNjYXBlZCkge1xuXHQgICAgaWYgKCF0aGlzLnJhd3MpIHtcblx0ICAgICAgdGhpcy5yYXdzID0ge307XG5cdCAgICB9XG5cblx0ICAgIHZhciBvcmlnaW5hbFZhbHVlID0gdGhpc1tuYW1lXTtcblx0ICAgIHZhciBvcmlnaW5hbEVzY2FwZWQgPSB0aGlzLnJhd3NbbmFtZV07XG5cdCAgICB0aGlzW25hbWVdID0gb3JpZ2luYWxWYWx1ZSArIHZhbHVlOyAvLyB0aGlzIG1heSB0cmlnZ2VyIGEgc2V0dGVyIHRoYXQgdXBkYXRlcyByYXdzLCBzbyBpdCBoYXMgdG8gYmUgc2V0IGZpcnN0LlxuXG5cdCAgICBpZiAob3JpZ2luYWxFc2NhcGVkIHx8IHZhbHVlRXNjYXBlZCAhPT0gdmFsdWUpIHtcblx0ICAgICAgdGhpcy5yYXdzW25hbWVdID0gKG9yaWdpbmFsRXNjYXBlZCB8fCBvcmlnaW5hbFZhbHVlKSArIHZhbHVlRXNjYXBlZDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGRlbGV0ZSB0aGlzLnJhd3NbbmFtZV07IC8vIGRlbGV0ZSBhbnkgZXNjYXBlZCB2YWx1ZSB0aGF0IHdhcyBjcmVhdGVkIGJ5IHRoZSBzZXR0ZXIuXG5cdCAgICB9XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFNvbWUgbm9uLXN0YW5kYXJkIHN5bnRheCBkb2Vzbid0IGZvbGxvdyBub3JtYWwgZXNjYXBpbmcgcnVsZXMgZm9yIGNzcy5cblx0ICAgKiBUaGlzIGFsbG93cyB0aGUgZXNjYXBlZCB2YWx1ZSB0byBiZSBzcGVjaWZpZWQgZGlyZWN0bHksIGFsbG93aW5nIGlsbGVnYWxcblx0ICAgKiBjaGFyYWN0ZXJzIHRvIGJlIGRpcmVjdGx5IGluc2VydGVkIGludG8gY3NzIG91dHB1dC5cblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgcHJvcGVydHkgdG8gc2V0XG5cdCAgICogQHBhcmFtIHthbnl9IHZhbHVlIHRoZSB1bmVzY2FwZWQgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlRXNjYXBlZCB0aGUgZXNjYXBlZCB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuXG5cdCAgICovXG5cdCAgO1xuXG5cdCAgX3Byb3RvLnNldFByb3BlcnR5QW5kRXNjYXBlID0gZnVuY3Rpb24gc2V0UHJvcGVydHlBbmRFc2NhcGUobmFtZSwgdmFsdWUsIHZhbHVlRXNjYXBlZCkge1xuXHQgICAgaWYgKCF0aGlzLnJhd3MpIHtcblx0ICAgICAgdGhpcy5yYXdzID0ge307XG5cdCAgICB9XG5cblx0ICAgIHRoaXNbbmFtZV0gPSB2YWx1ZTsgLy8gdGhpcyBtYXkgdHJpZ2dlciBhIHNldHRlciB0aGF0IHVwZGF0ZXMgcmF3cywgc28gaXQgaGFzIHRvIGJlIHNldCBmaXJzdC5cblxuXHQgICAgdGhpcy5yYXdzW25hbWVdID0gdmFsdWVFc2NhcGVkO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBXaGVuIHlvdSB3YW50IGEgdmFsdWUgdG8gcGFzc2VkIHRocm91Z2ggdG8gQ1NTIGRpcmVjdGx5LiBUaGlzIG1ldGhvZFxuXHQgICAqIGRlbGV0ZXMgdGhlIGNvcnJlc3BvbmRpbmcgcmF3IHZhbHVlIGNhdXNpbmcgdGhlIHN0cmluZ2lmaWVyIHRvIGZhbGxiYWNrXG5cdCAgICogdG8gdGhlIHVuZXNjYXBlZCB2YWx1ZS5cblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgcHJvcGVydHkgdG8gc2V0LlxuXHQgICAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgdmFsdWUgdGhhdCBpcyBib3RoIGVzY2FwZWQgYW5kIHVuZXNjYXBlZC5cblx0ICAgKi9cblx0ICA7XG5cblx0ICBfcHJvdG8uc2V0UHJvcGVydHlXaXRob3V0RXNjYXBlID0gZnVuY3Rpb24gc2V0UHJvcGVydHlXaXRob3V0RXNjYXBlKG5hbWUsIHZhbHVlKSB7XG5cdCAgICB0aGlzW25hbWVdID0gdmFsdWU7IC8vIHRoaXMgbWF5IHRyaWdnZXIgYSBzZXR0ZXIgdGhhdCB1cGRhdGVzIHJhd3MsIHNvIGl0IGhhcyB0byBiZSBzZXQgZmlyc3QuXG5cblx0ICAgIGlmICh0aGlzLnJhd3MpIHtcblx0ICAgICAgZGVsZXRlIHRoaXMucmF3c1tuYW1lXTtcblx0ICAgIH1cblx0ICB9XG5cdCAgLyoqXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge251bWJlcn0gbGluZSBUaGUgbnVtYmVyIChzdGFydGluZyB3aXRoIDEpXG5cdCAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbiBUaGUgY29sdW1uIG51bWJlciAoc3RhcnRpbmcgd2l0aCAxKVxuXHQgICAqL1xuXHQgIDtcblxuXHQgIF9wcm90by5pc0F0UG9zaXRpb24gPSBmdW5jdGlvbiBpc0F0UG9zaXRpb24obGluZSwgY29sdW1uKSB7XG5cdCAgICBpZiAodGhpcy5zb3VyY2UgJiYgdGhpcy5zb3VyY2Uuc3RhcnQgJiYgdGhpcy5zb3VyY2UuZW5kKSB7XG5cdCAgICAgIGlmICh0aGlzLnNvdXJjZS5zdGFydC5saW5lID4gbGluZSkge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh0aGlzLnNvdXJjZS5lbmQubGluZSA8IGxpbmUpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAodGhpcy5zb3VyY2Uuc3RhcnQubGluZSA9PT0gbGluZSAmJiB0aGlzLnNvdXJjZS5zdGFydC5jb2x1bW4gPiBjb2x1bW4pIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAodGhpcy5zb3VyY2UuZW5kLmxpbmUgPT09IGxpbmUgJiYgdGhpcy5zb3VyY2UuZW5kLmNvbHVtbiA8IGNvbHVtbikge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgIH07XG5cblx0ICBfcHJvdG8uc3RyaW5naWZ5UHJvcGVydHkgPSBmdW5jdGlvbiBzdHJpbmdpZnlQcm9wZXJ0eShuYW1lKSB7XG5cdCAgICByZXR1cm4gdGhpcy5yYXdzICYmIHRoaXMucmF3c1tuYW1lXSB8fCB0aGlzW25hbWVdO1xuXHQgIH07XG5cblx0ICBfcHJvdG8udmFsdWVUb1N0cmluZyA9IGZ1bmN0aW9uIHZhbHVlVG9TdHJpbmcoKSB7XG5cdCAgICByZXR1cm4gU3RyaW5nKHRoaXMuc3RyaW5naWZ5UHJvcGVydHkoXCJ2YWx1ZVwiKSk7XG5cdCAgfTtcblxuXHQgIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHQgICAgcmV0dXJuIFt0aGlzLnJhd1NwYWNlQmVmb3JlLCB0aGlzLnZhbHVlVG9TdHJpbmcoKSwgdGhpcy5yYXdTcGFjZUFmdGVyXS5qb2luKCcnKTtcblx0ICB9O1xuXG5cdCAgX2NyZWF0ZUNsYXNzKE5vZGUsIFt7XG5cdCAgICBrZXk6IFwicmF3U3BhY2VCZWZvcmVcIixcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICB2YXIgcmF3U3BhY2UgPSB0aGlzLnJhd3MgJiYgdGhpcy5yYXdzLnNwYWNlcyAmJiB0aGlzLnJhd3Muc3BhY2VzLmJlZm9yZTtcblxuXHQgICAgICBpZiAocmF3U3BhY2UgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHJhd1NwYWNlID0gdGhpcy5zcGFjZXMgJiYgdGhpcy5zcGFjZXMuYmVmb3JlO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIHJhd1NwYWNlIHx8IFwiXCI7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbiBzZXQocmF3KSB7XG5cdCAgICAgICgwLCBfdXRpbC5lbnN1cmVPYmplY3QpKHRoaXMsIFwicmF3c1wiLCBcInNwYWNlc1wiKTtcblx0ICAgICAgdGhpcy5yYXdzLnNwYWNlcy5iZWZvcmUgPSByYXc7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiBcInJhd1NwYWNlQWZ0ZXJcIixcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICB2YXIgcmF3U3BhY2UgPSB0aGlzLnJhd3MgJiYgdGhpcy5yYXdzLnNwYWNlcyAmJiB0aGlzLnJhd3Muc3BhY2VzLmFmdGVyO1xuXG5cdCAgICAgIGlmIChyYXdTcGFjZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgcmF3U3BhY2UgPSB0aGlzLnNwYWNlcy5hZnRlcjtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiByYXdTcGFjZSB8fCBcIlwiO1xuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24gc2V0KHJhdykge1xuXHQgICAgICAoMCwgX3V0aWwuZW5zdXJlT2JqZWN0KSh0aGlzLCBcInJhd3NcIiwgXCJzcGFjZXNcIik7XG5cdCAgICAgIHRoaXMucmF3cy5zcGFjZXMuYWZ0ZXIgPSByYXc7XG5cdCAgICB9XG5cdCAgfV0pO1xuXG5cdCAgcmV0dXJuIE5vZGU7XG5cdH0oKTtcblxuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IE5vZGU7XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufSAobm9kZSQxLCBub2RlJDEuZXhwb3J0cykpO1xuXG52YXIgdHlwZXMgPSB7fTtcblxudHlwZXMuX19lc01vZHVsZSA9IHRydWU7XG50eXBlcy5VTklWRVJTQUwgPSB0eXBlcy5BVFRSSUJVVEUgPSB0eXBlcy5DTEFTUyA9IHR5cGVzLkNPTUJJTkFUT1IgPSB0eXBlcy5DT01NRU5UID0gdHlwZXMuSUQgPSB0eXBlcy5ORVNUSU5HID0gdHlwZXMuUFNFVURPID0gdHlwZXMuUk9PVCA9IHR5cGVzLlNFTEVDVE9SID0gdHlwZXMuU1RSSU5HID0gdHlwZXMuVEFHID0gdm9pZCAwO1xudmFyIFRBRyA9ICd0YWcnO1xudHlwZXMuVEFHID0gVEFHO1xudmFyIFNUUklORyA9ICdzdHJpbmcnO1xudHlwZXMuU1RSSU5HID0gU1RSSU5HO1xudmFyIFNFTEVDVE9SID0gJ3NlbGVjdG9yJztcbnR5cGVzLlNFTEVDVE9SID0gU0VMRUNUT1I7XG52YXIgUk9PVCA9ICdyb290JztcbnR5cGVzLlJPT1QgPSBST09UO1xudmFyIFBTRVVETyA9ICdwc2V1ZG8nO1xudHlwZXMuUFNFVURPID0gUFNFVURPO1xudmFyIE5FU1RJTkcgPSAnbmVzdGluZyc7XG50eXBlcy5ORVNUSU5HID0gTkVTVElORztcbnZhciBJRCA9ICdpZCc7XG50eXBlcy5JRCA9IElEO1xudmFyIENPTU1FTlQgPSAnY29tbWVudCc7XG50eXBlcy5DT01NRU5UID0gQ09NTUVOVDtcbnZhciBDT01CSU5BVE9SID0gJ2NvbWJpbmF0b3InO1xudHlwZXMuQ09NQklOQVRPUiA9IENPTUJJTkFUT1I7XG52YXIgQ0xBU1MgPSAnY2xhc3MnO1xudHlwZXMuQ0xBU1MgPSBDTEFTUztcbnZhciBBVFRSSUJVVEUgPSAnYXR0cmlidXRlJztcbnR5cGVzLkFUVFJJQlVURSA9IEFUVFJJQlVURTtcbnZhciBVTklWRVJTQUwgPSAndW5pdmVyc2FsJztcbnR5cGVzLlVOSVZFUlNBTCA9IFVOSVZFUlNBTDtcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxuXHR2YXIgX25vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG5vZGUkMS5leHBvcnRzKTtcblxuXHR2YXIgdHlwZXMkMSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHR5cGVzKTtcblxuXHRmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5cdGZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHJldHVybiBmdW5jdGlvbiAoKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IHJldHVybiBpdC5uZXh0LmJpbmQoaXQpOyB9XG5cblx0ZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cblx0ZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cblx0ZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5cdGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cblx0ZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cblx0ZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuXHR2YXIgQ29udGFpbmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZSkge1xuXHQgIF9pbmhlcml0c0xvb3NlKENvbnRhaW5lciwgX05vZGUpO1xuXG5cdCAgZnVuY3Rpb24gQ29udGFpbmVyKG9wdHMpIHtcblx0ICAgIHZhciBfdGhpcztcblxuXHQgICAgX3RoaXMgPSBfTm9kZS5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG5cblx0ICAgIGlmICghX3RoaXMubm9kZXMpIHtcblx0ICAgICAgX3RoaXMubm9kZXMgPSBbXTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIF90aGlzO1xuXHQgIH1cblxuXHQgIHZhciBfcHJvdG8gPSBDb250YWluZXIucHJvdG90eXBlO1xuXG5cdCAgX3Byb3RvLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChzZWxlY3Rvcikge1xuXHQgICAgc2VsZWN0b3IucGFyZW50ID0gdGhpcztcblx0ICAgIHRoaXMubm9kZXMucHVzaChzZWxlY3Rvcik7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgX3Byb3RvLnByZXBlbmQgPSBmdW5jdGlvbiBwcmVwZW5kKHNlbGVjdG9yKSB7XG5cdCAgICBzZWxlY3Rvci5wYXJlbnQgPSB0aGlzO1xuXHQgICAgdGhpcy5ub2Rlcy51bnNoaWZ0KHNlbGVjdG9yKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICBfcHJvdG8uYXQgPSBmdW5jdGlvbiBhdChpbmRleCkge1xuXHQgICAgcmV0dXJuIHRoaXMubm9kZXNbaW5kZXhdO1xuXHQgIH07XG5cblx0ICBfcHJvdG8uaW5kZXggPSBmdW5jdGlvbiBpbmRleChjaGlsZCkge1xuXHQgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgcmV0dXJuIGNoaWxkO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5ub2Rlcy5pbmRleE9mKGNoaWxkKTtcblx0ICB9O1xuXG5cdCAgX3Byb3RvLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQoY2hpbGQpIHtcblx0ICAgIGNoaWxkID0gdGhpcy5pbmRleChjaGlsZCk7XG5cdCAgICB0aGlzLmF0KGNoaWxkKS5wYXJlbnQgPSB1bmRlZmluZWQ7XG5cdCAgICB0aGlzLm5vZGVzLnNwbGljZShjaGlsZCwgMSk7XG5cdCAgICB2YXIgaW5kZXg7XG5cblx0ICAgIGZvciAodmFyIGlkIGluIHRoaXMuaW5kZXhlcykge1xuXHQgICAgICBpbmRleCA9IHRoaXMuaW5kZXhlc1tpZF07XG5cblx0ICAgICAgaWYgKGluZGV4ID49IGNoaWxkKSB7XG5cdCAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IGluZGV4IC0gMTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgX3Byb3RvLnJlbW92ZUFsbCA9IGZ1bmN0aW9uIHJlbW92ZUFsbCgpIHtcblx0ICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodGhpcy5ub2RlcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG5cdCAgICAgIHZhciBub2RlID0gX3N0ZXAudmFsdWU7XG5cdCAgICAgIG5vZGUucGFyZW50ID0gdW5kZWZpbmVkO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLm5vZGVzID0gW107XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgX3Byb3RvLmVtcHR5ID0gZnVuY3Rpb24gZW1wdHkoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5yZW1vdmVBbGwoKTtcblx0ICB9O1xuXG5cdCAgX3Byb3RvLmluc2VydEFmdGVyID0gZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIob2xkTm9kZSwgbmV3Tm9kZSkge1xuXHQgICAgbmV3Tm9kZS5wYXJlbnQgPSB0aGlzO1xuXHQgICAgdmFyIG9sZEluZGV4ID0gdGhpcy5pbmRleChvbGROb2RlKTtcblx0ICAgIHRoaXMubm9kZXMuc3BsaWNlKG9sZEluZGV4ICsgMSwgMCwgbmV3Tm9kZSk7XG5cdCAgICBuZXdOb2RlLnBhcmVudCA9IHRoaXM7XG5cdCAgICB2YXIgaW5kZXg7XG5cblx0ICAgIGZvciAodmFyIGlkIGluIHRoaXMuaW5kZXhlcykge1xuXHQgICAgICBpbmRleCA9IHRoaXMuaW5kZXhlc1tpZF07XG5cblx0ICAgICAgaWYgKG9sZEluZGV4IDw9IGluZGV4KSB7XG5cdCAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IGluZGV4ICsgMTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgX3Byb3RvLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIGluc2VydEJlZm9yZShvbGROb2RlLCBuZXdOb2RlKSB7XG5cdCAgICBuZXdOb2RlLnBhcmVudCA9IHRoaXM7XG5cdCAgICB2YXIgb2xkSW5kZXggPSB0aGlzLmluZGV4KG9sZE5vZGUpO1xuXHQgICAgdGhpcy5ub2Rlcy5zcGxpY2Uob2xkSW5kZXgsIDAsIG5ld05vZGUpO1xuXHQgICAgbmV3Tm9kZS5wYXJlbnQgPSB0aGlzO1xuXHQgICAgdmFyIGluZGV4O1xuXG5cdCAgICBmb3IgKHZhciBpZCBpbiB0aGlzLmluZGV4ZXMpIHtcblx0ICAgICAgaW5kZXggPSB0aGlzLmluZGV4ZXNbaWRdO1xuXG5cdCAgICAgIGlmIChpbmRleCA8PSBvbGRJbmRleCkge1xuXHQgICAgICAgIHRoaXMuaW5kZXhlc1tpZF0gPSBpbmRleCArIDE7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIF9wcm90by5fZmluZENoaWxkQXRQb3NpdGlvbiA9IGZ1bmN0aW9uIF9maW5kQ2hpbGRBdFBvc2l0aW9uKGxpbmUsIGNvbCkge1xuXHQgICAgdmFyIGZvdW5kID0gdW5kZWZpbmVkO1xuXHQgICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgIGlmIChub2RlLmF0UG9zaXRpb24pIHtcblx0ICAgICAgICB2YXIgZm91bmRDaGlsZCA9IG5vZGUuYXRQb3NpdGlvbihsaW5lLCBjb2wpO1xuXG5cdCAgICAgICAgaWYgKGZvdW5kQ2hpbGQpIHtcblx0ICAgICAgICAgIGZvdW5kID0gZm91bmRDaGlsZDtcblx0ICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSBpZiAobm9kZS5pc0F0UG9zaXRpb24obGluZSwgY29sKSkge1xuXHQgICAgICAgIGZvdW5kID0gbm9kZTtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIGZvdW5kO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBSZXR1cm4gdGhlIG1vc3Qgc3BlY2lmaWMgbm9kZSBhdCB0aGUgbGluZSBhbmQgY29sdW1uIG51bWJlciBnaXZlbi5cblx0ICAgKiBUaGUgc291cmNlIGxvY2F0aW9uIGlzIGJhc2VkIG9uIHRoZSBvcmlnaW5hbCBwYXJzZWQgbG9jYXRpb24sIGxvY2F0aW9ucyBhcmVuJ3Rcblx0ICAgKiB1cGRhdGVkIGFzIHNlbGVjdG9yIG5vZGVzIGFyZSBtdXRhdGVkLlxuXHQgICAqIFxuXHQgICAqIE5vdGUgdGhhdCB0aGlzIGxvY2F0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSBsb2NhdGlvbiBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyXG5cdCAgICogb2YgdGhlIHNlbGVjdG9yLCBhbmQgbm90IHRoZSBsb2NhdGlvbiBvZiB0aGUgc2VsZWN0b3IgaW4gdGhlIG92ZXJhbGwgZG9jdW1lbnRcblx0ICAgKiB3aGVuIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBwb3N0Y3NzLlxuXHQgICAqXG5cdCAgICogSWYgbm90IGZvdW5kLCByZXR1cm5zIHVuZGVmaW5lZC5cblx0ICAgKiBAcGFyYW0ge251bWJlcn0gbGluZSBUaGUgbGluZSBudW1iZXIgb2YgdGhlIG5vZGUgdG8gZmluZC4gKDEtYmFzZWQgaW5kZXgpXG5cdCAgICogQHBhcmFtIHtudW1iZXJ9IGNvbCAgVGhlIGNvbHVtbiBudW1iZXIgb2YgdGhlIG5vZGUgdG8gZmluZC4gKDEtYmFzZWQgaW5kZXgpXG5cdCAgICovXG5cdCAgO1xuXG5cdCAgX3Byb3RvLmF0UG9zaXRpb24gPSBmdW5jdGlvbiBhdFBvc2l0aW9uKGxpbmUsIGNvbCkge1xuXHQgICAgaWYgKHRoaXMuaXNBdFBvc2l0aW9uKGxpbmUsIGNvbCkpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRDaGlsZEF0UG9zaXRpb24obGluZSwgY29sKSB8fCB0aGlzO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgX3Byb3RvLl9pbmZlckVuZFBvc2l0aW9uID0gZnVuY3Rpb24gX2luZmVyRW5kUG9zaXRpb24oKSB7XG5cdCAgICBpZiAodGhpcy5sYXN0ICYmIHRoaXMubGFzdC5zb3VyY2UgJiYgdGhpcy5sYXN0LnNvdXJjZS5lbmQpIHtcblx0ICAgICAgdGhpcy5zb3VyY2UgPSB0aGlzLnNvdXJjZSB8fCB7fTtcblx0ICAgICAgdGhpcy5zb3VyY2UuZW5kID0gdGhpcy5zb3VyY2UuZW5kIHx8IHt9O1xuXHQgICAgICBPYmplY3QuYXNzaWduKHRoaXMuc291cmNlLmVuZCwgdGhpcy5sYXN0LnNvdXJjZS5lbmQpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBfcHJvdG8uZWFjaCA9IGZ1bmN0aW9uIGVhY2goY2FsbGJhY2spIHtcblx0ICAgIGlmICghdGhpcy5sYXN0RWFjaCkge1xuXHQgICAgICB0aGlzLmxhc3RFYWNoID0gMDtcblx0ICAgIH1cblxuXHQgICAgaWYgKCF0aGlzLmluZGV4ZXMpIHtcblx0ICAgICAgdGhpcy5pbmRleGVzID0ge307XG5cdCAgICB9XG5cblx0ICAgIHRoaXMubGFzdEVhY2grKztcblx0ICAgIHZhciBpZCA9IHRoaXMubGFzdEVhY2g7XG5cdCAgICB0aGlzLmluZGV4ZXNbaWRdID0gMDtcblxuXHQgICAgaWYgKCF0aGlzLmxlbmd0aCkge1xuXHQgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgaW5kZXgsIHJlc3VsdDtcblxuXHQgICAgd2hpbGUgKHRoaXMuaW5kZXhlc1tpZF0gPCB0aGlzLmxlbmd0aCkge1xuXHQgICAgICBpbmRleCA9IHRoaXMuaW5kZXhlc1tpZF07XG5cdCAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKHRoaXMuYXQoaW5kZXgpLCBpbmRleCk7XG5cblx0ICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuaW5kZXhlc1tpZF0gKz0gMTtcblx0ICAgIH1cblxuXHQgICAgZGVsZXRlIHRoaXMuaW5kZXhlc1tpZF07XG5cblx0ICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgX3Byb3RvLndhbGsgPSBmdW5jdGlvbiB3YWxrKGNhbGxiYWNrKSB7XG5cdCAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChub2RlLCBpKSB7XG5cdCAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjayhub2RlLCBpKTtcblxuXHQgICAgICBpZiAocmVzdWx0ICE9PSBmYWxzZSAmJiBub2RlLmxlbmd0aCkge1xuXHQgICAgICAgIHJlc3VsdCA9IG5vZGUud2FsayhjYWxsYmFjayk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfTtcblxuXHQgIF9wcm90by53YWxrQXR0cmlidXRlcyA9IGZ1bmN0aW9uIHdhbGtBdHRyaWJ1dGVzKGNhbGxiYWNrKSB7XG5cdCAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuXHQgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbiAoc2VsZWN0b3IpIHtcblx0ICAgICAgaWYgKHNlbGVjdG9yLnR5cGUgPT09IHR5cGVzJDEuQVRUUklCVVRFKSB7XG5cdCAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoX3RoaXMyLCBzZWxlY3Rvcik7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH07XG5cblx0ICBfcHJvdG8ud2Fsa0NsYXNzZXMgPSBmdW5jdGlvbiB3YWxrQ2xhc3NlcyhjYWxsYmFjaykge1xuXHQgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cblx0ICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG5cdCAgICAgIGlmIChzZWxlY3Rvci50eXBlID09PSB0eXBlcyQxLkNMQVNTKSB7XG5cdCAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoX3RoaXMzLCBzZWxlY3Rvcik7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH07XG5cblx0ICBfcHJvdG8ud2Fsa0NvbWJpbmF0b3JzID0gZnVuY3Rpb24gd2Fsa0NvbWJpbmF0b3JzKGNhbGxiYWNrKSB7XG5cdCAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuXHQgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbiAoc2VsZWN0b3IpIHtcblx0ICAgICAgaWYgKHNlbGVjdG9yLnR5cGUgPT09IHR5cGVzJDEuQ09NQklOQVRPUikge1xuXHQgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKF90aGlzNCwgc2VsZWN0b3IpO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICB9O1xuXG5cdCAgX3Byb3RvLndhbGtDb21tZW50cyA9IGZ1bmN0aW9uIHdhbGtDb21tZW50cyhjYWxsYmFjaykge1xuXHQgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cblx0ICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG5cdCAgICAgIGlmIChzZWxlY3Rvci50eXBlID09PSB0eXBlcyQxLkNPTU1FTlQpIHtcblx0ICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChfdGhpczUsIHNlbGVjdG9yKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfTtcblxuXHQgIF9wcm90by53YWxrSWRzID0gZnVuY3Rpb24gd2Fsa0lkcyhjYWxsYmFjaykge1xuXHQgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cblx0ICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG5cdCAgICAgIGlmIChzZWxlY3Rvci50eXBlID09PSB0eXBlcyQxLklEKSB7XG5cdCAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoX3RoaXM2LCBzZWxlY3Rvcik7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH07XG5cblx0ICBfcHJvdG8ud2Fsa05lc3RpbmcgPSBmdW5jdGlvbiB3YWxrTmVzdGluZyhjYWxsYmFjaykge1xuXHQgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cblx0ICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG5cdCAgICAgIGlmIChzZWxlY3Rvci50eXBlID09PSB0eXBlcyQxLk5FU1RJTkcpIHtcblx0ICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChfdGhpczcsIHNlbGVjdG9yKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfTtcblxuXHQgIF9wcm90by53YWxrUHNldWRvcyA9IGZ1bmN0aW9uIHdhbGtQc2V1ZG9zKGNhbGxiYWNrKSB7XG5cdCAgICB2YXIgX3RoaXM4ID0gdGhpcztcblxuXHQgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbiAoc2VsZWN0b3IpIHtcblx0ICAgICAgaWYgKHNlbGVjdG9yLnR5cGUgPT09IHR5cGVzJDEuUFNFVURPKSB7XG5cdCAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoX3RoaXM4LCBzZWxlY3Rvcik7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH07XG5cblx0ICBfcHJvdG8ud2Fsa1RhZ3MgPSBmdW5jdGlvbiB3YWxrVGFncyhjYWxsYmFjaykge1xuXHQgICAgdmFyIF90aGlzOSA9IHRoaXM7XG5cblx0ICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG5cdCAgICAgIGlmIChzZWxlY3Rvci50eXBlID09PSB0eXBlcyQxLlRBRykge1xuXHQgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKF90aGlzOSwgc2VsZWN0b3IpO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICB9O1xuXG5cdCAgX3Byb3RvLndhbGtVbml2ZXJzYWxzID0gZnVuY3Rpb24gd2Fsa1VuaXZlcnNhbHMoY2FsbGJhY2spIHtcblx0ICAgIHZhciBfdGhpczEwID0gdGhpcztcblxuXHQgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbiAoc2VsZWN0b3IpIHtcblx0ICAgICAgaWYgKHNlbGVjdG9yLnR5cGUgPT09IHR5cGVzJDEuVU5JVkVSU0FMKSB7XG5cdCAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoX3RoaXMxMCwgc2VsZWN0b3IpO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICB9O1xuXG5cdCAgX3Byb3RvLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQoY2FsbGJhY2spIHtcblx0ICAgIHZhciBfdGhpczExID0gdGhpcztcblxuXHQgICAgdmFyIGN1cnJlbnQgPSBbXTtcblx0ICAgIHJldHVybiB0aGlzLnJlZHVjZShmdW5jdGlvbiAobWVtbywgbm9kZSwgaW5kZXgpIHtcblx0ICAgICAgdmFyIHNwbGl0ID0gY2FsbGJhY2suY2FsbChfdGhpczExLCBub2RlKTtcblx0ICAgICAgY3VycmVudC5wdXNoKG5vZGUpO1xuXG5cdCAgICAgIGlmIChzcGxpdCkge1xuXHQgICAgICAgIG1lbW8ucHVzaChjdXJyZW50KTtcblx0ICAgICAgICBjdXJyZW50ID0gW107XG5cdCAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IF90aGlzMTEubGVuZ3RoIC0gMSkge1xuXHQgICAgICAgIG1lbW8ucHVzaChjdXJyZW50KTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiBtZW1vO1xuXHQgICAgfSwgW10pO1xuXHQgIH07XG5cblx0ICBfcHJvdG8ubWFwID0gZnVuY3Rpb24gbWFwKGNhbGxiYWNrKSB7XG5cdCAgICByZXR1cm4gdGhpcy5ub2Rlcy5tYXAoY2FsbGJhY2spO1xuXHQgIH07XG5cblx0ICBfcHJvdG8ucmVkdWNlID0gZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrLCBtZW1vKSB7XG5cdCAgICByZXR1cm4gdGhpcy5ub2Rlcy5yZWR1Y2UoY2FsbGJhY2ssIG1lbW8pO1xuXHQgIH07XG5cblx0ICBfcHJvdG8uZXZlcnkgPSBmdW5jdGlvbiBldmVyeShjYWxsYmFjaykge1xuXHQgICAgcmV0dXJuIHRoaXMubm9kZXMuZXZlcnkoY2FsbGJhY2spO1xuXHQgIH07XG5cblx0ICBfcHJvdG8uc29tZSA9IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2spIHtcblx0ICAgIHJldHVybiB0aGlzLm5vZGVzLnNvbWUoY2FsbGJhY2spO1xuXHQgIH07XG5cblx0ICBfcHJvdG8uZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrKSB7XG5cdCAgICByZXR1cm4gdGhpcy5ub2Rlcy5maWx0ZXIoY2FsbGJhY2spO1xuXHQgIH07XG5cblx0ICBfcHJvdG8uc29ydCA9IGZ1bmN0aW9uIHNvcnQoY2FsbGJhY2spIHtcblx0ICAgIHJldHVybiB0aGlzLm5vZGVzLnNvcnQoY2FsbGJhY2spO1xuXHQgIH07XG5cblx0ICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0ICAgIHJldHVybiB0aGlzLm1hcChTdHJpbmcpLmpvaW4oJycpO1xuXHQgIH07XG5cblx0ICBfY3JlYXRlQ2xhc3MoQ29udGFpbmVyLCBbe1xuXHQgICAga2V5OiBcImZpcnN0XCIsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuYXQoMCk7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiBcImxhc3RcIixcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5hdCh0aGlzLmxlbmd0aCAtIDEpO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJsZW5ndGhcIixcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGg7XG5cdCAgICB9XG5cdCAgfV0pO1xuXG5cdCAgcmV0dXJuIENvbnRhaW5lcjtcblx0fShfbm9kZVtcImRlZmF1bHRcIl0pO1xuXG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ29udGFpbmVyO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn0gKGNvbnRhaW5lciwgY29udGFpbmVyLmV4cG9ydHMpKTtcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxuXHR2YXIgX2NvbnRhaW5lciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoY29udGFpbmVyLmV4cG9ydHMpO1xuXG5cdHZhciBfdHlwZXMgPSB0eXBlcztcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuXHRmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cblx0ZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuXHRmdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuXHRmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5cdHZhciBSb290ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29udGFpbmVyKSB7XG5cdCAgX2luaGVyaXRzTG9vc2UoUm9vdCwgX0NvbnRhaW5lcik7XG5cblx0ICBmdW5jdGlvbiBSb290KG9wdHMpIHtcblx0ICAgIHZhciBfdGhpcztcblxuXHQgICAgX3RoaXMgPSBfQ29udGFpbmVyLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcblx0ICAgIF90aGlzLnR5cGUgPSBfdHlwZXMuUk9PVDtcblx0ICAgIHJldHVybiBfdGhpcztcblx0ICB9XG5cblx0ICB2YXIgX3Byb3RvID0gUm9vdC5wcm90b3R5cGU7XG5cblx0ICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0ICAgIHZhciBzdHIgPSB0aGlzLnJlZHVjZShmdW5jdGlvbiAobWVtbywgc2VsZWN0b3IpIHtcblx0ICAgICAgbWVtby5wdXNoKFN0cmluZyhzZWxlY3RvcikpO1xuXHQgICAgICByZXR1cm4gbWVtbztcblx0ICAgIH0sIFtdKS5qb2luKCcsJyk7XG5cdCAgICByZXR1cm4gdGhpcy50cmFpbGluZ0NvbW1hID8gc3RyICsgJywnIDogc3RyO1xuXHQgIH07XG5cblx0ICBfcHJvdG8uZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihtZXNzYWdlLCBvcHRpb25zKSB7XG5cdCAgICBpZiAodGhpcy5fZXJyb3IpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKG1lc3NhZ2UsIG9wdGlvbnMpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIG5ldyBFcnJvcihtZXNzYWdlKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgX2NyZWF0ZUNsYXNzKFJvb3QsIFt7XG5cdCAgICBrZXk6IFwiZXJyb3JHZW5lcmF0b3JcIixcblx0ICAgIHNldDogZnVuY3Rpb24gc2V0KGhhbmRsZXIpIHtcblx0ICAgICAgdGhpcy5fZXJyb3IgPSBoYW5kbGVyO1xuXHQgICAgfVxuXHQgIH1dKTtcblxuXHQgIHJldHVybiBSb290O1xuXHR9KF9jb250YWluZXJbXCJkZWZhdWx0XCJdKTtcblxuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IFJvb3Q7XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufSAocm9vdCQxLCByb290JDEuZXhwb3J0cykpO1xuXG52YXIgc2VsZWN0b3IkMSA9IHtleHBvcnRzOiB7fX07XG5cbihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cblx0dmFyIF9jb250YWluZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGNvbnRhaW5lci5leHBvcnRzKTtcblxuXHR2YXIgX3R5cGVzID0gdHlwZXM7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cblx0ZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cblx0ZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuXHR2YXIgU2VsZWN0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db250YWluZXIpIHtcblx0ICBfaW5oZXJpdHNMb29zZShTZWxlY3RvciwgX0NvbnRhaW5lcik7XG5cblx0ICBmdW5jdGlvbiBTZWxlY3RvcihvcHRzKSB7XG5cdCAgICB2YXIgX3RoaXM7XG5cblx0ICAgIF90aGlzID0gX0NvbnRhaW5lci5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG5cdCAgICBfdGhpcy50eXBlID0gX3R5cGVzLlNFTEVDVE9SO1xuXHQgICAgcmV0dXJuIF90aGlzO1xuXHQgIH1cblxuXHQgIHJldHVybiBTZWxlY3Rvcjtcblx0fShfY29udGFpbmVyW1wiZGVmYXVsdFwiXSk7XG5cblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBTZWxlY3Rvcjtcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59IChzZWxlY3RvciQxLCBzZWxlY3RvciQxLmV4cG9ydHMpKTtcblxudmFyIGNsYXNzTmFtZSQxID0ge2V4cG9ydHM6IHt9fTtcblxuLyohIGh0dHBzOi8vbXRocy5iZS9jc3Nlc2MgdjMuMC4wIGJ5IEBtYXRoaWFzICovXG5cbnZhciBvYmplY3QgPSB7fTtcbnZhciBoYXNPd25Qcm9wZXJ0eSQxID0gb2JqZWN0Lmhhc093blByb3BlcnR5O1xudmFyIG1lcmdlID0gZnVuY3Rpb24gbWVyZ2Uob3B0aW9ucywgZGVmYXVsdHMpIHtcblx0aWYgKCFvcHRpb25zKSB7XG5cdFx0cmV0dXJuIGRlZmF1bHRzO1xuXHR9XG5cdHZhciByZXN1bHQgPSB7fTtcblx0Zm9yICh2YXIga2V5IGluIGRlZmF1bHRzKSB7XG5cdFx0Ly8gYGlmIChkZWZhdWx0cy5oYXNPd25Qcm9wZXJ0eShrZXkpIHsg4oCmIH1gIGlzIG5vdCBuZWVkZWQgaGVyZSwgc2luY2Vcblx0XHQvLyBvbmx5IHJlY29nbml6ZWQgb3B0aW9uIG5hbWVzIGFyZSB1c2VkLlxuXHRcdHJlc3VsdFtrZXldID0gaGFzT3duUHJvcGVydHkkMS5jYWxsKG9wdGlvbnMsIGtleSkgPyBvcHRpb25zW2tleV0gOiBkZWZhdWx0c1trZXldO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgcmVnZXhBbnlTaW5nbGVFc2NhcGUgPSAvWyAtLFxcLlxcLzotQFxcWy1cXF5gXFx7LX5dLztcbnZhciByZWdleFNpbmdsZUVzY2FwZSA9IC9bIC0sXFwuXFwvOi1AXFxbXFxdXFxeYFxcey1+XS87XG52YXIgcmVnZXhFeGNlc3NpdmVTcGFjZXMgPSAvKF58XFxcXCspPyhcXFxcW0EtRjAtOV17MSw2fSlcXHgyMCg/IVthLWZBLUYwLTlcXHgyMF0pL2c7XG5cbi8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9jc3MtZXNjYXBlcyNjc3NcbnZhciBjc3Nlc2MgPSBmdW5jdGlvbiBjc3Nlc2Moc3RyaW5nLCBvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBtZXJnZShvcHRpb25zLCBjc3Nlc2Mub3B0aW9ucyk7XG5cdGlmIChvcHRpb25zLnF1b3RlcyAhPSAnc2luZ2xlJyAmJiBvcHRpb25zLnF1b3RlcyAhPSAnZG91YmxlJykge1xuXHRcdG9wdGlvbnMucXVvdGVzID0gJ3NpbmdsZSc7XG5cdH1cblx0dmFyIHF1b3RlID0gb3B0aW9ucy5xdW90ZXMgPT0gJ2RvdWJsZScgPyAnXCInIDogJ1xcJyc7XG5cdHZhciBpc0lkZW50aWZpZXIgPSBvcHRpb25zLmlzSWRlbnRpZmllcjtcblxuXHR2YXIgZmlyc3RDaGFyID0gc3RyaW5nLmNoYXJBdCgwKTtcblx0dmFyIG91dHB1dCA9ICcnO1xuXHR2YXIgY291bnRlciA9IDA7XG5cdHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdHZhciBjaGFyYWN0ZXIgPSBzdHJpbmcuY2hhckF0KGNvdW50ZXIrKyk7XG5cdFx0dmFyIGNvZGVQb2ludCA9IGNoYXJhY3Rlci5jaGFyQ29kZUF0KCk7XG5cdFx0dmFyIHZhbHVlID0gdm9pZCAwO1xuXHRcdC8vIElmIGl04oCZcyBub3QgYSBwcmludGFibGUgQVNDSUkgY2hhcmFjdGVy4oCmXG5cdFx0aWYgKGNvZGVQb2ludCA8IDB4MjAgfHwgY29kZVBvaW50ID4gMHg3RSkge1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIEl04oCZcyBhIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3Rlci5cblx0XHRcdFx0dmFyIGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7XG5cdFx0XHRcdFx0Ly8gbmV4dCBjaGFyYWN0ZXIgaXMgbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdGNvZGVQb2ludCA9ICgoY29kZVBvaW50ICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDA7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gSXTigJlzIGFuIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlXG5cdFx0XHRcdFx0Ly8gdGhlIG5leHQgY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLlxuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dmFsdWUgPSAnXFxcXCcgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyAnICc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChvcHRpb25zLmVzY2FwZUV2ZXJ5dGhpbmcpIHtcblx0XHRcdFx0aWYgKHJlZ2V4QW55U2luZ2xlRXNjYXBlLnRlc3QoY2hhcmFjdGVyKSkge1xuXHRcdFx0XHRcdHZhbHVlID0gJ1xcXFwnICsgY2hhcmFjdGVyO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gJ1xcXFwnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgJyAnO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKC9bXFx0XFxuXFxmXFxyXFx4MEJdLy50ZXN0KGNoYXJhY3RlcikpIHtcblx0XHRcdFx0dmFsdWUgPSAnXFxcXCcgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyAnICc7XG5cdFx0XHR9IGVsc2UgaWYgKGNoYXJhY3RlciA9PSAnXFxcXCcgfHwgIWlzSWRlbnRpZmllciAmJiAoY2hhcmFjdGVyID09ICdcIicgJiYgcXVvdGUgPT0gY2hhcmFjdGVyIHx8IGNoYXJhY3RlciA9PSAnXFwnJyAmJiBxdW90ZSA9PSBjaGFyYWN0ZXIpIHx8IGlzSWRlbnRpZmllciAmJiByZWdleFNpbmdsZUVzY2FwZS50ZXN0KGNoYXJhY3RlcikpIHtcblx0XHRcdFx0dmFsdWUgPSAnXFxcXCcgKyBjaGFyYWN0ZXI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWx1ZSA9IGNoYXJhY3Rlcjtcblx0XHRcdH1cblx0XHR9XG5cdFx0b3V0cHV0ICs9IHZhbHVlO1xuXHR9XG5cblx0aWYgKGlzSWRlbnRpZmllcikge1xuXHRcdGlmICgvXi1bLVxcZF0vLnRlc3Qob3V0cHV0KSkge1xuXHRcdFx0b3V0cHV0ID0gJ1xcXFwtJyArIG91dHB1dC5zbGljZSgxKTtcblx0XHR9IGVsc2UgaWYgKC9cXGQvLnRlc3QoZmlyc3RDaGFyKSkge1xuXHRcdFx0b3V0cHV0ID0gJ1xcXFwzJyArIGZpcnN0Q2hhciArICcgJyArIG91dHB1dC5zbGljZSgxKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgc3BhY2VzIGFmdGVyIGBcXEhFWGAgZXNjYXBlcyB0aGF0IGFyZSBub3QgZm9sbG93ZWQgYnkgYSBoZXggZGlnaXQsXG5cdC8vIHNpbmNlIHRoZXnigJlyZSByZWR1bmRhbnQuIE5vdGUgdGhhdCB0aGlzIGlzIG9ubHkgcG9zc2libGUgaWYgdGhlIGVzY2FwZVxuXHQvLyBzZXF1ZW5jZSBpc27igJl0IHByZWNlZGVkIGJ5IGFuIG9kZCBudW1iZXIgb2YgYmFja3NsYXNoZXMuXG5cdG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKHJlZ2V4RXhjZXNzaXZlU3BhY2VzLCBmdW5jdGlvbiAoJDAsICQxLCAkMikge1xuXHRcdGlmICgkMSAmJiAkMS5sZW5ndGggJSAyKSB7XG5cdFx0XHQvLyBJdOKAmXMgbm90IHNhZmUgdG8gcmVtb3ZlIHRoZSBzcGFjZSwgc28gZG9u4oCZdC5cblx0XHRcdHJldHVybiAkMDtcblx0XHR9XG5cdFx0Ly8gU3RyaXAgdGhlIHNwYWNlLlxuXHRcdHJldHVybiAoJDEgfHwgJycpICsgJDI7XG5cdH0pO1xuXG5cdGlmICghaXNJZGVudGlmaWVyICYmIG9wdGlvbnMud3JhcCkge1xuXHRcdHJldHVybiBxdW90ZSArIG91dHB1dCArIHF1b3RlO1xuXHR9XG5cdHJldHVybiBvdXRwdXQ7XG59O1xuXG4vLyBFeHBvc2UgZGVmYXVsdCBvcHRpb25zIChzbyB0aGV5IGNhbiBiZSBvdmVycmlkZGVuIGdsb2JhbGx5KS5cbmNzc2VzYy5vcHRpb25zID0ge1xuXHQnZXNjYXBlRXZlcnl0aGluZyc6IGZhbHNlLFxuXHQnaXNJZGVudGlmaWVyJzogZmFsc2UsXG5cdCdxdW90ZXMnOiAnc2luZ2xlJyxcblx0J3dyYXAnOiBmYWxzZVxufTtcblxuY3NzZXNjLnZlcnNpb24gPSAnMy4wLjAnO1xuXG52YXIgY3NzZXNjXzEgPSBjc3Nlc2M7XG5cbihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cblx0dmFyIF9jc3Nlc2MgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGNzc2VzY18xKTtcblxuXHR2YXIgX3V0aWwgPSB1dGlsO1xuXG5cdHZhciBfbm9kZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQobm9kZSQxLmV4cG9ydHMpO1xuXG5cdHZhciBfdHlwZXMgPSB0eXBlcztcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuXHRmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cblx0ZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuXHRmdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuXHRmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5cdHZhciBDbGFzc05hbWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7XG5cdCAgX2luaGVyaXRzTG9vc2UoQ2xhc3NOYW1lLCBfTm9kZSk7XG5cblx0ICBmdW5jdGlvbiBDbGFzc05hbWUob3B0cykge1xuXHQgICAgdmFyIF90aGlzO1xuXG5cdCAgICBfdGhpcyA9IF9Ob2RlLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcblx0ICAgIF90aGlzLnR5cGUgPSBfdHlwZXMuQ0xBU1M7XG5cdCAgICBfdGhpcy5fY29uc3RydWN0ZWQgPSB0cnVlO1xuXHQgICAgcmV0dXJuIF90aGlzO1xuXHQgIH1cblxuXHQgIHZhciBfcHJvdG8gPSBDbGFzc05hbWUucHJvdG90eXBlO1xuXG5cdCAgX3Byb3RvLnZhbHVlVG9TdHJpbmcgPSBmdW5jdGlvbiB2YWx1ZVRvU3RyaW5nKCkge1xuXHQgICAgcmV0dXJuICcuJyArIF9Ob2RlLnByb3RvdHlwZS52YWx1ZVRvU3RyaW5nLmNhbGwodGhpcyk7XG5cdCAgfTtcblxuXHQgIF9jcmVhdGVDbGFzcyhDbGFzc05hbWUsIFt7XG5cdCAgICBrZXk6IFwidmFsdWVcIixcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbiBzZXQodikge1xuXHQgICAgICBpZiAodGhpcy5fY29uc3RydWN0ZWQpIHtcblx0ICAgICAgICB2YXIgZXNjYXBlZCA9ICgwLCBfY3NzZXNjW1wiZGVmYXVsdFwiXSkodiwge1xuXHQgICAgICAgICAgaXNJZGVudGlmaWVyOiB0cnVlXG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICBpZiAoZXNjYXBlZCAhPT0gdikge1xuXHQgICAgICAgICAgKDAsIF91dGlsLmVuc3VyZU9iamVjdCkodGhpcywgXCJyYXdzXCIpO1xuXHQgICAgICAgICAgdGhpcy5yYXdzLnZhbHVlID0gZXNjYXBlZDtcblx0ICAgICAgICB9IGVsc2UgaWYgKHRoaXMucmF3cykge1xuXHQgICAgICAgICAgZGVsZXRlIHRoaXMucmF3cy52YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLl92YWx1ZSA9IHY7XG5cdCAgICB9XG5cdCAgfV0pO1xuXG5cdCAgcmV0dXJuIENsYXNzTmFtZTtcblx0fShfbm9kZVtcImRlZmF1bHRcIl0pO1xuXG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ2xhc3NOYW1lO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn0gKGNsYXNzTmFtZSQxLCBjbGFzc05hbWUkMS5leHBvcnRzKSk7XG5cbnZhciBjb21tZW50JDIgPSB7ZXhwb3J0czoge319O1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG5cdHZhciBfbm9kZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQobm9kZSQxLmV4cG9ydHMpO1xuXG5cdHZhciBfdHlwZXMgPSB0eXBlcztcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuXHRmdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuXHRmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5cdHZhciBDb21tZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZSkge1xuXHQgIF9pbmhlcml0c0xvb3NlKENvbW1lbnQsIF9Ob2RlKTtcblxuXHQgIGZ1bmN0aW9uIENvbW1lbnQob3B0cykge1xuXHQgICAgdmFyIF90aGlzO1xuXG5cdCAgICBfdGhpcyA9IF9Ob2RlLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcblx0ICAgIF90aGlzLnR5cGUgPSBfdHlwZXMuQ09NTUVOVDtcblx0ICAgIHJldHVybiBfdGhpcztcblx0ICB9XG5cblx0ICByZXR1cm4gQ29tbWVudDtcblx0fShfbm9kZVtcImRlZmF1bHRcIl0pO1xuXG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ29tbWVudDtcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59IChjb21tZW50JDIsIGNvbW1lbnQkMi5leHBvcnRzKSk7XG5cbnZhciBpZCQxID0ge2V4cG9ydHM6IHt9fTtcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxuXHR2YXIgX25vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG5vZGUkMS5leHBvcnRzKTtcblxuXHR2YXIgX3R5cGVzID0gdHlwZXM7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cblx0ZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cblx0ZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuXHR2YXIgSUQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7XG5cdCAgX2luaGVyaXRzTG9vc2UoSUQsIF9Ob2RlKTtcblxuXHQgIGZ1bmN0aW9uIElEKG9wdHMpIHtcblx0ICAgIHZhciBfdGhpcztcblxuXHQgICAgX3RoaXMgPSBfTm9kZS5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG5cdCAgICBfdGhpcy50eXBlID0gX3R5cGVzLklEO1xuXHQgICAgcmV0dXJuIF90aGlzO1xuXHQgIH1cblxuXHQgIHZhciBfcHJvdG8gPSBJRC5wcm90b3R5cGU7XG5cblx0ICBfcHJvdG8udmFsdWVUb1N0cmluZyA9IGZ1bmN0aW9uIHZhbHVlVG9TdHJpbmcoKSB7XG5cdCAgICByZXR1cm4gJyMnICsgX05vZGUucHJvdG90eXBlLnZhbHVlVG9TdHJpbmcuY2FsbCh0aGlzKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIElEO1xuXHR9KF9ub2RlW1wiZGVmYXVsdFwiXSk7XG5cblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBJRDtcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59IChpZCQxLCBpZCQxLmV4cG9ydHMpKTtcblxudmFyIHRhZyQxID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIG5hbWVzcGFjZSA9IHtleHBvcnRzOiB7fX07XG5cbihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cblx0dmFyIF9jc3Nlc2MgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGNzc2VzY18xKTtcblxuXHR2YXIgX3V0aWwgPSB1dGlsO1xuXG5cdHZhciBfbm9kZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQobm9kZSQxLmV4cG9ydHMpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5cdGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuXHRmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5cdGZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5cdGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cblx0dmFyIE5hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUpIHtcblx0ICBfaW5oZXJpdHNMb29zZShOYW1lc3BhY2UsIF9Ob2RlKTtcblxuXHQgIGZ1bmN0aW9uIE5hbWVzcGFjZSgpIHtcblx0ICAgIHJldHVybiBfTm9kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgfVxuXG5cdCAgdmFyIF9wcm90byA9IE5hbWVzcGFjZS5wcm90b3R5cGU7XG5cblx0ICBfcHJvdG8ucXVhbGlmaWVkTmFtZSA9IGZ1bmN0aW9uIHF1YWxpZmllZE5hbWUodmFsdWUpIHtcblx0ICAgIGlmICh0aGlzLm5hbWVzcGFjZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2VTdHJpbmcgKyBcInxcIiArIHZhbHVlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBfcHJvdG8udmFsdWVUb1N0cmluZyA9IGZ1bmN0aW9uIHZhbHVlVG9TdHJpbmcoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5xdWFsaWZpZWROYW1lKF9Ob2RlLnByb3RvdHlwZS52YWx1ZVRvU3RyaW5nLmNhbGwodGhpcykpO1xuXHQgIH07XG5cblx0ICBfY3JlYXRlQ2xhc3MoTmFtZXNwYWNlLCBbe1xuXHQgICAga2V5OiBcIm5hbWVzcGFjZVwiLFxuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9uYW1lc3BhY2U7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbiBzZXQobmFtZXNwYWNlKSB7XG5cdCAgICAgIGlmIChuYW1lc3BhY2UgPT09IHRydWUgfHwgbmFtZXNwYWNlID09PSBcIipcIiB8fCBuYW1lc3BhY2UgPT09IFwiJlwiKSB7XG5cdCAgICAgICAgdGhpcy5fbmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXG5cdCAgICAgICAgaWYgKHRoaXMucmF3cykge1xuXHQgICAgICAgICAgZGVsZXRlIHRoaXMucmF3cy5uYW1lc3BhY2U7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIGVzY2FwZWQgPSAoMCwgX2Nzc2VzY1tcImRlZmF1bHRcIl0pKG5hbWVzcGFjZSwge1xuXHQgICAgICAgIGlzSWRlbnRpZmllcjogdHJ1ZVxuXHQgICAgICB9KTtcblx0ICAgICAgdGhpcy5fbmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXG5cdCAgICAgIGlmIChlc2NhcGVkICE9PSBuYW1lc3BhY2UpIHtcblx0ICAgICAgICAoMCwgX3V0aWwuZW5zdXJlT2JqZWN0KSh0aGlzLCBcInJhd3NcIik7XG5cdCAgICAgICAgdGhpcy5yYXdzLm5hbWVzcGFjZSA9IGVzY2FwZWQ7XG5cdCAgICAgIH0gZWxzZSBpZiAodGhpcy5yYXdzKSB7XG5cdCAgICAgICAgZGVsZXRlIHRoaXMucmF3cy5uYW1lc3BhY2U7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwibnNcIixcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fbmFtZXNwYWNlO1xuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24gc2V0KG5hbWVzcGFjZSkge1xuXHQgICAgICB0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwibmFtZXNwYWNlU3RyaW5nXCIsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgaWYgKHRoaXMubmFtZXNwYWNlKSB7XG5cdCAgICAgICAgdmFyIG5zID0gdGhpcy5zdHJpbmdpZnlQcm9wZXJ0eShcIm5hbWVzcGFjZVwiKTtcblxuXHQgICAgICAgIGlmIChucyA9PT0gdHJ1ZSkge1xuXHQgICAgICAgICAgcmV0dXJuICcnO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICByZXR1cm4gbnM7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiAnJztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1dKTtcblxuXHQgIHJldHVybiBOYW1lc3BhY2U7XG5cdH0oX25vZGVbXCJkZWZhdWx0XCJdKTtcblxuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IE5hbWVzcGFjZTtcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59IChuYW1lc3BhY2UsIG5hbWVzcGFjZS5leHBvcnRzKSk7XG5cbihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cblx0dmFyIF9uYW1lc3BhY2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG5hbWVzcGFjZS5leHBvcnRzKTtcblxuXHR2YXIgX3R5cGVzID0gdHlwZXM7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cblx0ZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cblx0ZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuXHR2YXIgVGFnID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTmFtZXNwYWNlKSB7XG5cdCAgX2luaGVyaXRzTG9vc2UoVGFnLCBfTmFtZXNwYWNlKTtcblxuXHQgIGZ1bmN0aW9uIFRhZyhvcHRzKSB7XG5cdCAgICB2YXIgX3RoaXM7XG5cblx0ICAgIF90aGlzID0gX05hbWVzcGFjZS5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG5cdCAgICBfdGhpcy50eXBlID0gX3R5cGVzLlRBRztcblx0ICAgIHJldHVybiBfdGhpcztcblx0ICB9XG5cblx0ICByZXR1cm4gVGFnO1xuXHR9KF9uYW1lc3BhY2VbXCJkZWZhdWx0XCJdKTtcblxuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IFRhZztcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59ICh0YWckMSwgdGFnJDEuZXhwb3J0cykpO1xuXG52YXIgc3RyaW5nJDEgPSB7ZXhwb3J0czoge319O1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG5cdHZhciBfbm9kZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQobm9kZSQxLmV4cG9ydHMpO1xuXG5cdHZhciBfdHlwZXMgPSB0eXBlcztcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuXHRmdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuXHRmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5cdHZhciBTdHJpbmcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7XG5cdCAgX2luaGVyaXRzTG9vc2UoU3RyaW5nLCBfTm9kZSk7XG5cblx0ICBmdW5jdGlvbiBTdHJpbmcob3B0cykge1xuXHQgICAgdmFyIF90aGlzO1xuXG5cdCAgICBfdGhpcyA9IF9Ob2RlLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcblx0ICAgIF90aGlzLnR5cGUgPSBfdHlwZXMuU1RSSU5HO1xuXHQgICAgcmV0dXJuIF90aGlzO1xuXHQgIH1cblxuXHQgIHJldHVybiBTdHJpbmc7XG5cdH0oX25vZGVbXCJkZWZhdWx0XCJdKTtcblxuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IFN0cmluZztcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59IChzdHJpbmckMSwgc3RyaW5nJDEuZXhwb3J0cykpO1xuXG52YXIgcHNldWRvJDEgPSB7ZXhwb3J0czoge319O1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG5cdHZhciBfY29udGFpbmVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChjb250YWluZXIuZXhwb3J0cyk7XG5cblx0dmFyIF90eXBlcyA9IHR5cGVzO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5cdGZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5cdGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cblx0dmFyIFBzZXVkbyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbnRhaW5lcikge1xuXHQgIF9pbmhlcml0c0xvb3NlKFBzZXVkbywgX0NvbnRhaW5lcik7XG5cblx0ICBmdW5jdGlvbiBQc2V1ZG8ob3B0cykge1xuXHQgICAgdmFyIF90aGlzO1xuXG5cdCAgICBfdGhpcyA9IF9Db250YWluZXIuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuXHQgICAgX3RoaXMudHlwZSA9IF90eXBlcy5QU0VVRE87XG5cdCAgICByZXR1cm4gX3RoaXM7XG5cdCAgfVxuXG5cdCAgdmFyIF9wcm90byA9IFBzZXVkby5wcm90b3R5cGU7XG5cblx0ICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0ICAgIHZhciBwYXJhbXMgPSB0aGlzLmxlbmd0aCA/ICcoJyArIHRoaXMubWFwKFN0cmluZykuam9pbignLCcpICsgJyknIDogJyc7XG5cdCAgICByZXR1cm4gW3RoaXMucmF3U3BhY2VCZWZvcmUsIHRoaXMuc3RyaW5naWZ5UHJvcGVydHkoXCJ2YWx1ZVwiKSwgcGFyYW1zLCB0aGlzLnJhd1NwYWNlQWZ0ZXJdLmpvaW4oJycpO1xuXHQgIH07XG5cblx0ICByZXR1cm4gUHNldWRvO1xuXHR9KF9jb250YWluZXJbXCJkZWZhdWx0XCJdKTtcblxuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IFBzZXVkbztcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59IChwc2V1ZG8kMSwgcHNldWRvJDEuZXhwb3J0cykpO1xuXG52YXIgYXR0cmlidXRlJDEgPSB7fTtcblxuLyoqXG4gKiBGb3IgTm9kZS5qcywgc2ltcGx5IHJlLWV4cG9ydCB0aGUgY29yZSBgdXRpbC5kZXByZWNhdGVgIGZ1bmN0aW9uLlxuICovXG5cbnZhciBub2RlID0gcmVxdWlyZSQkMCQyLmRlcHJlY2F0ZTtcblxuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0ZXhwb3J0cy51bmVzY2FwZVZhbHVlID0gdW5lc2NhcGVWYWx1ZTtcblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cblx0dmFyIF9jc3Nlc2MgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGNzc2VzY18xKTtcblxuXHR2YXIgX3VuZXNjID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCh1bmVzYy5leHBvcnRzKTtcblxuXHR2YXIgX25hbWVzcGFjZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQobmFtZXNwYWNlLmV4cG9ydHMpO1xuXG5cdHZhciBfdHlwZXMgPSB0eXBlcztcblxuXHR2YXIgX0NTU0VTQ19RVU9URV9PUFRJT05TO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5cdGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuXHRmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5cdGZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5cdGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cblx0dmFyIGRlcHJlY2F0ZSA9IG5vZGU7XG5cblx0dmFyIFdSQVBQRURfSU5fUVVPVEVTID0gL14oJ3xcIikoW15dKilcXDEkLztcblx0dmFyIHdhcm5PZkRlcHJlY2F0ZWRWYWx1ZUFzc2lnbm1lbnQgPSBkZXByZWNhdGUoZnVuY3Rpb24gKCkge30sIFwiQXNzaWduaW5nIGFuIGF0dHJpYnV0ZSBhIHZhbHVlIGNvbnRhaW5pbmcgY2hhcmFjdGVycyB0aGF0IG1pZ2h0IG5lZWQgdG8gYmUgZXNjYXBlZCBpcyBkZXByZWNhdGVkLiBcIiArIFwiQ2FsbCBhdHRyaWJ1dGUuc2V0VmFsdWUoKSBpbnN0ZWFkLlwiKTtcblx0dmFyIHdhcm5PZkRlcHJlY2F0ZWRRdW90ZWRBc3NpZ25tZW50ID0gZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHt9LCBcIkFzc2lnbmluZyBhdHRyLnF1b3RlZCBpcyBkZXByZWNhdGVkIGFuZCBoYXMgbm8gZWZmZWN0LiBBc3NpZ24gdG8gYXR0ci5xdW90ZU1hcmsgaW5zdGVhZC5cIik7XG5cdHZhciB3YXJuT2ZEZXByZWNhdGVkQ29uc3RydWN0b3IgPSBkZXByZWNhdGUoZnVuY3Rpb24gKCkge30sIFwiQ29uc3RydWN0aW5nIGFuIEF0dHJpYnV0ZSBzZWxlY3RvciB3aXRoIGEgdmFsdWUgd2l0aG91dCBzcGVjaWZ5aW5nIHF1b3RlTWFyayBpcyBkZXByZWNhdGVkLiBOb3RlOiBUaGUgdmFsdWUgc2hvdWxkIGJlIHVuZXNjYXBlZCBub3cuXCIpO1xuXG5cdGZ1bmN0aW9uIHVuZXNjYXBlVmFsdWUodmFsdWUpIHtcblx0ICB2YXIgZGVwcmVjYXRlZFVzYWdlID0gZmFsc2U7XG5cdCAgdmFyIHF1b3RlTWFyayA9IG51bGw7XG5cdCAgdmFyIHVuZXNjYXBlZCA9IHZhbHVlO1xuXHQgIHZhciBtID0gdW5lc2NhcGVkLm1hdGNoKFdSQVBQRURfSU5fUVVPVEVTKTtcblxuXHQgIGlmIChtKSB7XG5cdCAgICBxdW90ZU1hcmsgPSBtWzFdO1xuXHQgICAgdW5lc2NhcGVkID0gbVsyXTtcblx0ICB9XG5cblx0ICB1bmVzY2FwZWQgPSAoMCwgX3VuZXNjW1wiZGVmYXVsdFwiXSkodW5lc2NhcGVkKTtcblxuXHQgIGlmICh1bmVzY2FwZWQgIT09IHZhbHVlKSB7XG5cdCAgICBkZXByZWNhdGVkVXNhZ2UgPSB0cnVlO1xuXHQgIH1cblxuXHQgIHJldHVybiB7XG5cdCAgICBkZXByZWNhdGVkVXNhZ2U6IGRlcHJlY2F0ZWRVc2FnZSxcblx0ICAgIHVuZXNjYXBlZDogdW5lc2NhcGVkLFxuXHQgICAgcXVvdGVNYXJrOiBxdW90ZU1hcmtcblx0ICB9O1xuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlRGVwcmVjYXRlZENvbnRydWN0b3JPcHRzKG9wdHMpIHtcblx0ICBpZiAob3B0cy5xdW90ZU1hcmsgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgcmV0dXJuIG9wdHM7XG5cdCAgfVxuXG5cdCAgaWYgKG9wdHMudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgcmV0dXJuIG9wdHM7XG5cdCAgfVxuXG5cdCAgd2Fybk9mRGVwcmVjYXRlZENvbnN0cnVjdG9yKCk7XG5cblx0ICB2YXIgX3VuZXNjYXBlVmFsdWUgPSB1bmVzY2FwZVZhbHVlKG9wdHMudmFsdWUpLFxuXHQgICAgICBxdW90ZU1hcmsgPSBfdW5lc2NhcGVWYWx1ZS5xdW90ZU1hcmssXG5cdCAgICAgIHVuZXNjYXBlZCA9IF91bmVzY2FwZVZhbHVlLnVuZXNjYXBlZDtcblxuXHQgIGlmICghb3B0cy5yYXdzKSB7XG5cdCAgICBvcHRzLnJhd3MgPSB7fTtcblx0ICB9XG5cblx0ICBpZiAob3B0cy5yYXdzLnZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0ICAgIG9wdHMucmF3cy52YWx1ZSA9IG9wdHMudmFsdWU7XG5cdCAgfVxuXG5cdCAgb3B0cy52YWx1ZSA9IHVuZXNjYXBlZDtcblx0ICBvcHRzLnF1b3RlTWFyayA9IHF1b3RlTWFyaztcblx0ICByZXR1cm4gb3B0cztcblx0fVxuXG5cdHZhciBBdHRyaWJ1dGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9OYW1lc3BhY2UpIHtcblx0ICBfaW5oZXJpdHNMb29zZShBdHRyaWJ1dGUsIF9OYW1lc3BhY2UpO1xuXG5cdCAgZnVuY3Rpb24gQXR0cmlidXRlKG9wdHMpIHtcblx0ICAgIHZhciBfdGhpcztcblxuXHQgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuXHQgICAgICBvcHRzID0ge307XG5cdCAgICB9XG5cblx0ICAgIF90aGlzID0gX05hbWVzcGFjZS5jYWxsKHRoaXMsIGhhbmRsZURlcHJlY2F0ZWRDb250cnVjdG9yT3B0cyhvcHRzKSkgfHwgdGhpcztcblx0ICAgIF90aGlzLnR5cGUgPSBfdHlwZXMuQVRUUklCVVRFO1xuXHQgICAgX3RoaXMucmF3cyA9IF90aGlzLnJhd3MgfHwge307XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMucmF3cywgJ3VucXVvdGVkJywge1xuXHQgICAgICBnZXQ6IGRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzLnZhbHVlO1xuXHQgICAgICB9LCBcImF0dHIucmF3cy51bnF1b3RlZCBpcyBkZXByZWNhdGVkLiBDYWxsIGF0dHIudmFsdWUgaW5zdGVhZC5cIiksXG5cdCAgICAgIHNldDogZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gX3RoaXMudmFsdWU7XG5cdCAgICAgIH0sIFwiU2V0dGluZyBhdHRyLnJhd3MudW5xdW90ZWQgaXMgZGVwcmVjYXRlZCBhbmQgaGFzIG5vIGVmZmVjdC4gYXR0ci52YWx1ZSBpcyB1bmVzY2FwZWQgYnkgZGVmYXVsdCBub3cuXCIpXG5cdCAgICB9KTtcblx0ICAgIF90aGlzLl9jb25zdHJ1Y3RlZCA9IHRydWU7XG5cdCAgICByZXR1cm4gX3RoaXM7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFJldHVybnMgdGhlIEF0dHJpYnV0ZSdzIHZhbHVlIHF1b3RlZCBzdWNoIHRoYXQgaXQgd291bGQgYmUgbGVnYWwgdG8gdXNlXG5cdCAgICogaW4gdGhlIHZhbHVlIG9mIGEgY3NzIGZpbGUuIFRoZSBvcmlnaW5hbCB2YWx1ZSdzIHF1b3RhdGlvbiBzZXR0aW5nXG5cdCAgICogdXNlZCBmb3Igc3RyaW5naWZpY2F0aW9uIGlzIGxlZnQgdW5jaGFuZ2VkLiBTZWUgYHNldFZhbHVlKHZhbHVlLCBvcHRpb25zKWBcblx0ICAgKiBpZiB5b3Ugd2FudCB0byBjb250cm9sIHRoZSBxdW90ZSBzZXR0aW5ncyBvZiBhIG5ldyB2YWx1ZSBmb3IgdGhlIGF0dHJpYnV0ZS5cblx0ICAgKlxuXHQgICAqIFlvdSBjYW4gYWxzbyBjaGFuZ2UgdGhlIHF1b3RhdGlvbiB1c2VkIGZvciB0aGUgY3VycmVudCB2YWx1ZSBieSBzZXR0aW5nIHF1b3RlTWFyay5cblx0ICAgKlxuXHQgICAqIE9wdGlvbnM6XG5cdCAgICogICAqIHF1b3RlTWFyayB7J1wiJyB8IFwiJ1wiIHwgbnVsbH0gLSBVc2UgdGhpcyB2YWx1ZSB0byBxdW90ZSB0aGUgdmFsdWUuIElmIHRoaXNcblx0ICAgKiAgICAgb3B0aW9uIGlzIG5vdCBzZXQsIHRoZSBvcmlnaW5hbCB2YWx1ZSBmb3IgcXVvdGVNYXJrIHdpbGwgYmUgdXNlZC4gSWZcblx0ICAgKiAgICAgaW5kZXRlcm1pbmF0ZSwgYSBkb3VibGUgcXVvdGUgaXMgdXNlZC4gVGhlIGxlZ2FsIHZhbHVlcyBhcmU6XG5cdCAgICogICAgICogYG51bGxgIC0gdGhlIHZhbHVlIHdpbGwgYmUgdW5xdW90ZWQgYW5kIGNoYXJhY3RlcnMgd2lsbCBiZSBlc2NhcGVkIGFzIG5lY2Vzc2FyeS5cblx0ICAgKiAgICAgKiBgJ2AgLSB0aGUgdmFsdWUgd2lsbCBiZSBxdW90ZWQgd2l0aCBhIHNpbmdsZSBxdW90ZSBhbmQgc2luZ2xlIHF1b3RlcyBhcmUgZXNjYXBlZC5cblx0ICAgKiAgICAgKiBgXCJgIC0gdGhlIHZhbHVlIHdpbGwgYmUgcXVvdGVkIHdpdGggYSBkb3VibGUgcXVvdGUgYW5kIGRvdWJsZSBxdW90ZXMgYXJlIGVzY2FwZWQuXG5cdCAgICogICAqIHByZWZlckN1cnJlbnRRdW90ZU1hcmsge2Jvb2xlYW59IC0gaWYgdHJ1ZSwgcHJlZmVyIHRoZSBzb3VyY2UgcXVvdGUgbWFya1xuXHQgICAqICAgICBvdmVyIHRoZSBxdW90ZU1hcmsgb3B0aW9uIHZhbHVlLlxuXHQgICAqICAgKiBzbWFydCB7Ym9vbGVhbn0gLSBpZiB0cnVlLCB3aWxsIHNlbGVjdCBhIHF1b3RlIG1hcmsgYmFzZWQgb24gdGhlIHZhbHVlXG5cdCAgICogICAgIGFuZCB0aGUgb3RoZXIgb3B0aW9ucyBzcGVjaWZpZWQgaGVyZS4gU2VlIHRoZSBgc21hcnRRdW90ZU1hcmsoKWBcblx0ICAgKiAgICAgbWV0aG9kLlxuXHQgICAqKi9cblxuXG5cdCAgdmFyIF9wcm90byA9IEF0dHJpYnV0ZS5wcm90b3R5cGU7XG5cblx0ICBfcHJvdG8uZ2V0UXVvdGVkVmFsdWUgPSBmdW5jdGlvbiBnZXRRdW90ZWRWYWx1ZShvcHRpb25zKSB7XG5cdCAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHF1b3RlTWFyayA9IHRoaXMuX2RldGVybWluZVF1b3RlTWFyayhvcHRpb25zKTtcblxuXHQgICAgdmFyIGNzc2VzY29wdHMgPSBDU1NFU0NfUVVPVEVfT1BUSU9OU1txdW90ZU1hcmtdO1xuXHQgICAgdmFyIGVzY2FwZWQgPSAoMCwgX2Nzc2VzY1tcImRlZmF1bHRcIl0pKHRoaXMuX3ZhbHVlLCBjc3Nlc2NvcHRzKTtcblx0ICAgIHJldHVybiBlc2NhcGVkO1xuXHQgIH07XG5cblx0ICBfcHJvdG8uX2RldGVybWluZVF1b3RlTWFyayA9IGZ1bmN0aW9uIF9kZXRlcm1pbmVRdW90ZU1hcmsob3B0aW9ucykge1xuXHQgICAgcmV0dXJuIG9wdGlvbnMuc21hcnQgPyB0aGlzLnNtYXJ0UXVvdGVNYXJrKG9wdGlvbnMpIDogdGhpcy5wcmVmZXJyZWRRdW90ZU1hcmsob3B0aW9ucyk7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFNldCB0aGUgdW5lc2NhcGVkIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCBxdW90YXRpb24gb3B0aW9ucy4gVGhlIHZhbHVlXG5cdCAgICogcHJvdmlkZWQgbXVzdCBub3QgaW5jbHVkZSBhbnkgd3JhcHBpbmcgcXVvdGUgbWFya3MgLS0gdGhvc2UgcXVvdGVzIHdpbGxcblx0ICAgKiBiZSBpbnRlcnByZXRlZCBhcyBwYXJ0IG9mIHRoZSB2YWx1ZSBhbmQgZXNjYXBlZCBhY2NvcmRpbmdseS5cblx0ICAgKi9cblx0ICA7XG5cblx0ICBfcHJvdG8uc2V0VmFsdWUgPSBmdW5jdGlvbiBzZXRWYWx1ZSh2YWx1ZSwgb3B0aW9ucykge1xuXHQgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuXHQgICAgICBvcHRpb25zID0ge307XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG5cdCAgICB0aGlzLl9xdW90ZU1hcmsgPSB0aGlzLl9kZXRlcm1pbmVRdW90ZU1hcmsob3B0aW9ucyk7XG5cblx0ICAgIHRoaXMuX3N5bmNSYXdWYWx1ZSgpO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBJbnRlbGxpZ2VudGx5IHNlbGVjdCBhIHF1b3RlTWFyayB2YWx1ZSBiYXNlZCBvbiB0aGUgdmFsdWUncyBjb250ZW50cy4gSWZcblx0ICAgKiB0aGUgdmFsdWUgaXMgYSBsZWdhbCBDU1MgaWRlbnQsIGl0IHdpbGwgbm90IGJlIHF1b3RlZC4gT3RoZXJ3aXNlIGEgcXVvdGVcblx0ICAgKiBtYXJrIHdpbGwgYmUgcGlja2VkIHRoYXQgbWluaW1pemVzIHRoZSBudW1iZXIgb2YgZXNjYXBlcy5cblx0ICAgKlxuXHQgICAqIElmIHRoZXJlJ3Mgbm8gY2xlYXIgd2lubmVyLCB0aGUgcXVvdGUgbWFyayBmcm9tIHRoZXNlIG9wdGlvbnMgaXMgdXNlZCxcblx0ICAgKiB0aGVuIHRoZSBzb3VyY2UgcXVvdGUgbWFyayAodGhpcyBpcyBpbnZlcnRlZCBpZiBgcHJlZmVyQ3VycmVudFF1b3RlTWFya2AgaXNcblx0ICAgKiB0cnVlKS4gSWYgdGhlIHF1b3RlTWFyayBpcyB1bnNwZWNpZmllZCwgYSBkb3VibGUgcXVvdGUgaXMgdXNlZC5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSBvcHRpb25zIFRoaXMgdGFrZXMgdGhlIHF1b3RlTWFyayBhbmQgcHJlZmVyQ3VycmVudFF1b3RlTWFyayBvcHRpb25zXG5cdCAgICogZnJvbSB0aGUgcXVvdGVWYWx1ZSBtZXRob2QuXG5cdCAgICovXG5cdCAgO1xuXG5cdCAgX3Byb3RvLnNtYXJ0UXVvdGVNYXJrID0gZnVuY3Rpb24gc21hcnRRdW90ZU1hcmsob3B0aW9ucykge1xuXHQgICAgdmFyIHYgPSB0aGlzLnZhbHVlO1xuXHQgICAgdmFyIG51bVNpbmdsZVF1b3RlcyA9IHYucmVwbGFjZSgvW14nXS9nLCAnJykubGVuZ3RoO1xuXHQgICAgdmFyIG51bURvdWJsZVF1b3RlcyA9IHYucmVwbGFjZSgvW15cIl0vZywgJycpLmxlbmd0aDtcblxuXHQgICAgaWYgKG51bVNpbmdsZVF1b3RlcyArIG51bURvdWJsZVF1b3RlcyA9PT0gMCkge1xuXHQgICAgICB2YXIgZXNjYXBlZCA9ICgwLCBfY3NzZXNjW1wiZGVmYXVsdFwiXSkodiwge1xuXHQgICAgICAgIGlzSWRlbnRpZmllcjogdHJ1ZVxuXHQgICAgICB9KTtcblxuXHQgICAgICBpZiAoZXNjYXBlZCA9PT0gdikge1xuXHQgICAgICAgIHJldHVybiBBdHRyaWJ1dGUuTk9fUVVPVEU7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdmFyIHByZWYgPSB0aGlzLnByZWZlcnJlZFF1b3RlTWFyayhvcHRpb25zKTtcblxuXHQgICAgICAgIGlmIChwcmVmID09PSBBdHRyaWJ1dGUuTk9fUVVPVEUpIHtcblx0ICAgICAgICAgIC8vIHBpY2sgYSBxdW90ZSBtYXJrIHRoYXQgaXNuJ3Qgbm9uZSBhbmQgc2VlIGlmIGl0J3Mgc21hbGxlclxuXHQgICAgICAgICAgdmFyIHF1b3RlID0gdGhpcy5xdW90ZU1hcmsgfHwgb3B0aW9ucy5xdW90ZU1hcmsgfHwgQXR0cmlidXRlLkRPVUJMRV9RVU9URTtcblx0ICAgICAgICAgIHZhciBvcHRzID0gQ1NTRVNDX1FVT1RFX09QVElPTlNbcXVvdGVdO1xuXHQgICAgICAgICAgdmFyIHF1b3RlVmFsdWUgPSAoMCwgX2Nzc2VzY1tcImRlZmF1bHRcIl0pKHYsIG9wdHMpO1xuXG5cdCAgICAgICAgICBpZiAocXVvdGVWYWx1ZS5sZW5ndGggPCBlc2NhcGVkLmxlbmd0aCkge1xuXHQgICAgICAgICAgICByZXR1cm4gcXVvdGU7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHByZWY7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAobnVtRG91YmxlUXVvdGVzID09PSBudW1TaW5nbGVRdW90ZXMpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMucHJlZmVycmVkUXVvdGVNYXJrKG9wdGlvbnMpO1xuXHQgICAgfSBlbHNlIGlmIChudW1Eb3VibGVRdW90ZXMgPCBudW1TaW5nbGVRdW90ZXMpIHtcblx0ICAgICAgcmV0dXJuIEF0dHJpYnV0ZS5ET1VCTEVfUVVPVEU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gQXR0cmlidXRlLlNJTkdMRV9RVU9URTtcblx0ICAgIH1cblx0ICB9XG5cdCAgLyoqXG5cdCAgICogU2VsZWN0cyB0aGUgcHJlZmVycmVkIHF1b3RlIG1hcmsgYmFzZWQgb24gdGhlIG9wdGlvbnMgYW5kIHRoZSBjdXJyZW50IHF1b3RlIG1hcmsgdmFsdWUuXG5cdCAgICogSWYgeW91IHdhbnQgdGhlIHF1b3RlIG1hcmsgdG8gZGVwZW5kIG9uIHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgYHNtYXJ0UXVvdGVNYXJrKG9wdHMpYFxuXHQgICAqIGluc3RlYWQuXG5cdCAgICovXG5cdCAgO1xuXG5cdCAgX3Byb3RvLnByZWZlcnJlZFF1b3RlTWFyayA9IGZ1bmN0aW9uIHByZWZlcnJlZFF1b3RlTWFyayhvcHRpb25zKSB7XG5cdCAgICB2YXIgcXVvdGVNYXJrID0gb3B0aW9ucy5wcmVmZXJDdXJyZW50UXVvdGVNYXJrID8gdGhpcy5xdW90ZU1hcmsgOiBvcHRpb25zLnF1b3RlTWFyaztcblxuXHQgICAgaWYgKHF1b3RlTWFyayA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIHF1b3RlTWFyayA9IG9wdGlvbnMucHJlZmVyQ3VycmVudFF1b3RlTWFyayA/IG9wdGlvbnMucXVvdGVNYXJrIDogdGhpcy5xdW90ZU1hcms7XG5cdCAgICB9XG5cblx0ICAgIGlmIChxdW90ZU1hcmsgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICBxdW90ZU1hcmsgPSBBdHRyaWJ1dGUuRE9VQkxFX1FVT1RFO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcXVvdGVNYXJrO1xuXHQgIH07XG5cblx0ICBfcHJvdG8uX3N5bmNSYXdWYWx1ZSA9IGZ1bmN0aW9uIF9zeW5jUmF3VmFsdWUoKSB7XG5cdCAgICB2YXIgcmF3VmFsdWUgPSAoMCwgX2Nzc2VzY1tcImRlZmF1bHRcIl0pKHRoaXMuX3ZhbHVlLCBDU1NFU0NfUVVPVEVfT1BUSU9OU1t0aGlzLnF1b3RlTWFya10pO1xuXG5cdCAgICBpZiAocmF3VmFsdWUgPT09IHRoaXMuX3ZhbHVlKSB7XG5cdCAgICAgIGlmICh0aGlzLnJhd3MpIHtcblx0ICAgICAgICBkZWxldGUgdGhpcy5yYXdzLnZhbHVlO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLnJhd3MudmFsdWUgPSByYXdWYWx1ZTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgX3Byb3RvLl9oYW5kbGVFc2NhcGVzID0gZnVuY3Rpb24gX2hhbmRsZUVzY2FwZXMocHJvcCwgdmFsdWUpIHtcblx0ICAgIGlmICh0aGlzLl9jb25zdHJ1Y3RlZCkge1xuXHQgICAgICB2YXIgZXNjYXBlZCA9ICgwLCBfY3NzZXNjW1wiZGVmYXVsdFwiXSkodmFsdWUsIHtcblx0ICAgICAgICBpc0lkZW50aWZpZXI6IHRydWVcblx0ICAgICAgfSk7XG5cblx0ICAgICAgaWYgKGVzY2FwZWQgIT09IHZhbHVlKSB7XG5cdCAgICAgICAgdGhpcy5yYXdzW3Byb3BdID0gZXNjYXBlZDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBkZWxldGUgdGhpcy5yYXdzW3Byb3BdO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIF9wcm90by5fc3BhY2VzRm9yID0gZnVuY3Rpb24gX3NwYWNlc0ZvcihuYW1lKSB7XG5cdCAgICB2YXIgYXR0clNwYWNlcyA9IHtcblx0ICAgICAgYmVmb3JlOiAnJyxcblx0ICAgICAgYWZ0ZXI6ICcnXG5cdCAgICB9O1xuXHQgICAgdmFyIHNwYWNlcyA9IHRoaXMuc3BhY2VzW25hbWVdIHx8IHt9O1xuXHQgICAgdmFyIHJhd1NwYWNlcyA9IHRoaXMucmF3cy5zcGFjZXMgJiYgdGhpcy5yYXdzLnNwYWNlc1tuYW1lXSB8fCB7fTtcblx0ICAgIHJldHVybiBPYmplY3QuYXNzaWduKGF0dHJTcGFjZXMsIHNwYWNlcywgcmF3U3BhY2VzKTtcblx0ICB9O1xuXG5cdCAgX3Byb3RvLl9zdHJpbmdGb3IgPSBmdW5jdGlvbiBfc3RyaW5nRm9yKG5hbWUsIHNwYWNlTmFtZSwgY29uY2F0KSB7XG5cdCAgICBpZiAoc3BhY2VOYW1lID09PSB2b2lkIDApIHtcblx0ICAgICAgc3BhY2VOYW1lID0gbmFtZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGNvbmNhdCA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIGNvbmNhdCA9IGRlZmF1bHRBdHRyQ29uY2F0O1xuXHQgICAgfVxuXG5cdCAgICB2YXIgYXR0clNwYWNlcyA9IHRoaXMuX3NwYWNlc0ZvcihzcGFjZU5hbWUpO1xuXG5cdCAgICByZXR1cm4gY29uY2F0KHRoaXMuc3RyaW5naWZ5UHJvcGVydHkobmFtZSksIGF0dHJTcGFjZXMpO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiByZXR1cm5zIHRoZSBvZmZzZXQgb2YgdGhlIGF0dHJpYnV0ZSBwYXJ0IHNwZWNpZmllZCByZWxhdGl2ZSB0byB0aGVcblx0ICAgKiBzdGFydCBvZiB0aGUgbm9kZSBvZiB0aGUgb3V0cHV0IHN0cmluZy5cblx0ICAgKlxuXHQgICAqICogXCJuc1wiIC0gYWxpYXMgZm9yIFwibmFtZXNwYWNlXCJcblx0ICAgKiAqIFwibmFtZXNwYWNlXCIgLSB0aGUgbmFtZXNwYWNlIGlmIGl0IGV4aXN0cy5cblx0ICAgKiAqIFwiYXR0cmlidXRlXCIgLSB0aGUgYXR0cmlidXRlIG5hbWVcblx0ICAgKiAqIFwiYXR0cmlidXRlTlNcIiAtIHRoZSBzdGFydCBvZiB0aGUgYXR0cmlidXRlIG9yIGl0cyBuYW1lc3BhY2Vcblx0ICAgKiAqIFwib3BlcmF0b3JcIiAtIHRoZSBtYXRjaCBvcGVyYXRvciBvZiB0aGUgYXR0cmlidXRlXG5cdCAgICogKiBcInZhbHVlXCIgLSBUaGUgdmFsdWUgKHN0cmluZyBvciBpZGVudGlmaWVyKVxuXHQgICAqICogXCJpbnNlbnNpdGl2ZVwiIC0gdGhlIGNhc2UgaW5zZW5zaXRpdml0eSBmbGFnO1xuXHQgICAqIEBwYXJhbSBwYXJ0IE9uZSBvZiB0aGUgcG9zc2libGUgdmFsdWVzIGluc2lkZSBhbiBhdHRyaWJ1dGUuXG5cdCAgICogQHJldHVybnMgLTEgaWYgdGhlIG5hbWUgaXMgaW52YWxpZCBvciB0aGUgdmFsdWUgZG9lc24ndCBleGlzdCBpbiB0aGlzIGF0dHJpYnV0ZS5cblx0ICAgKi9cblx0ICA7XG5cblx0ICBfcHJvdG8ub2Zmc2V0T2YgPSBmdW5jdGlvbiBvZmZzZXRPZihuYW1lKSB7XG5cdCAgICB2YXIgY291bnQgPSAxO1xuXG5cdCAgICB2YXIgYXR0cmlidXRlU3BhY2VzID0gdGhpcy5fc3BhY2VzRm9yKFwiYXR0cmlidXRlXCIpO1xuXG5cdCAgICBjb3VudCArPSBhdHRyaWJ1dGVTcGFjZXMuYmVmb3JlLmxlbmd0aDtcblxuXHQgICAgaWYgKG5hbWUgPT09IFwibmFtZXNwYWNlXCIgfHwgbmFtZSA9PT0gXCJuc1wiKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLm5hbWVzcGFjZSA/IGNvdW50IDogLTE7XG5cdCAgICB9XG5cblx0ICAgIGlmIChuYW1lID09PSBcImF0dHJpYnV0ZU5TXCIpIHtcblx0ICAgICAgcmV0dXJuIGNvdW50O1xuXHQgICAgfVxuXG5cdCAgICBjb3VudCArPSB0aGlzLm5hbWVzcGFjZVN0cmluZy5sZW5ndGg7XG5cblx0ICAgIGlmICh0aGlzLm5hbWVzcGFjZSkge1xuXHQgICAgICBjb3VudCArPSAxO1xuXHQgICAgfVxuXG5cdCAgICBpZiAobmFtZSA9PT0gXCJhdHRyaWJ1dGVcIikge1xuXHQgICAgICByZXR1cm4gY291bnQ7XG5cdCAgICB9XG5cblx0ICAgIGNvdW50ICs9IHRoaXMuc3RyaW5naWZ5UHJvcGVydHkoXCJhdHRyaWJ1dGVcIikubGVuZ3RoO1xuXHQgICAgY291bnQgKz0gYXR0cmlidXRlU3BhY2VzLmFmdGVyLmxlbmd0aDtcblxuXHQgICAgdmFyIG9wZXJhdG9yU3BhY2VzID0gdGhpcy5fc3BhY2VzRm9yKFwib3BlcmF0b3JcIik7XG5cblx0ICAgIGNvdW50ICs9IG9wZXJhdG9yU3BhY2VzLmJlZm9yZS5sZW5ndGg7XG5cdCAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLnN0cmluZ2lmeVByb3BlcnR5KFwib3BlcmF0b3JcIik7XG5cblx0ICAgIGlmIChuYW1lID09PSBcIm9wZXJhdG9yXCIpIHtcblx0ICAgICAgcmV0dXJuIG9wZXJhdG9yID8gY291bnQgOiAtMTtcblx0ICAgIH1cblxuXHQgICAgY291bnQgKz0gb3BlcmF0b3IubGVuZ3RoO1xuXHQgICAgY291bnQgKz0gb3BlcmF0b3JTcGFjZXMuYWZ0ZXIubGVuZ3RoO1xuXG5cdCAgICB2YXIgdmFsdWVTcGFjZXMgPSB0aGlzLl9zcGFjZXNGb3IoXCJ2YWx1ZVwiKTtcblxuXHQgICAgY291bnQgKz0gdmFsdWVTcGFjZXMuYmVmb3JlLmxlbmd0aDtcblx0ICAgIHZhciB2YWx1ZSA9IHRoaXMuc3RyaW5naWZ5UHJvcGVydHkoXCJ2YWx1ZVwiKTtcblxuXHQgICAgaWYgKG5hbWUgPT09IFwidmFsdWVcIikge1xuXHQgICAgICByZXR1cm4gdmFsdWUgPyBjb3VudCA6IC0xO1xuXHQgICAgfVxuXG5cdCAgICBjb3VudCArPSB2YWx1ZS5sZW5ndGg7XG5cdCAgICBjb3VudCArPSB2YWx1ZVNwYWNlcy5hZnRlci5sZW5ndGg7XG5cblx0ICAgIHZhciBpbnNlbnNpdGl2ZVNwYWNlcyA9IHRoaXMuX3NwYWNlc0ZvcihcImluc2Vuc2l0aXZlXCIpO1xuXG5cdCAgICBjb3VudCArPSBpbnNlbnNpdGl2ZVNwYWNlcy5iZWZvcmUubGVuZ3RoO1xuXG5cdCAgICBpZiAobmFtZSA9PT0gXCJpbnNlbnNpdGl2ZVwiKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmluc2Vuc2l0aXZlID8gY291bnQgOiAtMTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIC0xO1xuXHQgIH07XG5cblx0ICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0ICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG5cdCAgICB2YXIgc2VsZWN0b3IgPSBbdGhpcy5yYXdTcGFjZUJlZm9yZSwgJ1snXTtcblx0ICAgIHNlbGVjdG9yLnB1c2godGhpcy5fc3RyaW5nRm9yKCdxdWFsaWZpZWRBdHRyaWJ1dGUnLCAnYXR0cmlidXRlJykpO1xuXG5cdCAgICBpZiAodGhpcy5vcGVyYXRvciAmJiAodGhpcy52YWx1ZSB8fCB0aGlzLnZhbHVlID09PSAnJykpIHtcblx0ICAgICAgc2VsZWN0b3IucHVzaCh0aGlzLl9zdHJpbmdGb3IoJ29wZXJhdG9yJykpO1xuXHQgICAgICBzZWxlY3Rvci5wdXNoKHRoaXMuX3N0cmluZ0ZvcigndmFsdWUnKSk7XG5cdCAgICAgIHNlbGVjdG9yLnB1c2godGhpcy5fc3RyaW5nRm9yKCdpbnNlbnNpdGl2ZUZsYWcnLCAnaW5zZW5zaXRpdmUnLCBmdW5jdGlvbiAoYXR0clZhbHVlLCBhdHRyU3BhY2VzKSB7XG5cdCAgICAgICAgaWYgKGF0dHJWYWx1ZS5sZW5ndGggPiAwICYmICFfdGhpczIucXVvdGVkICYmIGF0dHJTcGFjZXMuYmVmb3JlLmxlbmd0aCA9PT0gMCAmJiAhKF90aGlzMi5zcGFjZXMudmFsdWUgJiYgX3RoaXMyLnNwYWNlcy52YWx1ZS5hZnRlcikpIHtcblx0ICAgICAgICAgIGF0dHJTcGFjZXMuYmVmb3JlID0gXCIgXCI7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGRlZmF1bHRBdHRyQ29uY2F0KGF0dHJWYWx1ZSwgYXR0clNwYWNlcyk7XG5cdCAgICAgIH0pKTtcblx0ICAgIH1cblxuXHQgICAgc2VsZWN0b3IucHVzaCgnXScpO1xuXHQgICAgc2VsZWN0b3IucHVzaCh0aGlzLnJhd1NwYWNlQWZ0ZXIpO1xuXHQgICAgcmV0dXJuIHNlbGVjdG9yLmpvaW4oJycpO1xuXHQgIH07XG5cblx0ICBfY3JlYXRlQ2xhc3MoQXR0cmlidXRlLCBbe1xuXHQgICAga2V5OiBcInF1b3RlZFwiLFxuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgIHZhciBxbSA9IHRoaXMucXVvdGVNYXJrO1xuXHQgICAgICByZXR1cm4gcW0gPT09IFwiJ1wiIHx8IHFtID09PSAnXCInO1xuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG5cdCAgICAgIHdhcm5PZkRlcHJlY2F0ZWRRdW90ZWRBc3NpZ25tZW50KCk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIHJldHVybnMgYSBzaW5nbGUgKGAnYCkgb3IgZG91YmxlIChgXCJgKSBxdW90ZSBjaGFyYWN0ZXIgaWYgdGhlIHZhbHVlIGlzIHF1b3RlZC5cblx0ICAgICAqIHJldHVybnMgYG51bGxgIGlmIHRoZSB2YWx1ZSBpcyBub3QgcXVvdGVkLlxuXHQgICAgICogcmV0dXJucyBgdW5kZWZpbmVkYCBpZiB0aGUgcXVvdGF0aW9uIHN0YXRlIGlzIHVua25vd24gKHRoaXMgY2FuIGhhcHBlbiB3aGVuXG5cdCAgICAgKiB0aGUgYXR0cmlidXRlIGlzIGNvbnN0cnVjdGVkIHdpdGhvdXQgc3BlY2lmeWluZyBhIHF1b3RlIG1hcmsuKVxuXHQgICAgICovXG5cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwicXVvdGVNYXJrXCIsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX3F1b3RlTWFyaztcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogU2V0IHRoZSBxdW90ZSBtYXJrIHRvIGJlIHVzZWQgYnkgdGhpcyBhdHRyaWJ1dGUncyB2YWx1ZS5cblx0ICAgICAqIElmIHRoZSBxdW90ZSBtYXJrIGNoYW5nZXMsIHRoZSByYXcgKGVzY2FwZWQpIHZhbHVlIGF0IGBhdHRyLnJhd3MudmFsdWVgIG9mIHRoZSBhdHRyaWJ1dGVcblx0ICAgICAqIHZhbHVlIGlzIHVwZGF0ZWQgYWNjb3JkaW5nbHkuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtcIidcIiB8ICdcIicgfCBudWxsfSBxdW90ZU1hcmsgVGhlIHF1b3RlIG1hcmsgb3IgYG51bGxgIGlmIHRoZSB2YWx1ZSBzaG91bGQgYmUgdW5xdW90ZWQuXG5cdCAgICAgKi9cblx0ICAgICxcblx0ICAgIHNldDogZnVuY3Rpb24gc2V0KHF1b3RlTWFyaykge1xuXHQgICAgICBpZiAoIXRoaXMuX2NvbnN0cnVjdGVkKSB7XG5cdCAgICAgICAgdGhpcy5fcXVvdGVNYXJrID0gcXVvdGVNYXJrO1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh0aGlzLl9xdW90ZU1hcmsgIT09IHF1b3RlTWFyaykge1xuXHQgICAgICAgIHRoaXMuX3F1b3RlTWFyayA9IHF1b3RlTWFyaztcblxuXHQgICAgICAgIHRoaXMuX3N5bmNSYXdWYWx1ZSgpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiBcInF1YWxpZmllZEF0dHJpYnV0ZVwiLFxuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnF1YWxpZmllZE5hbWUodGhpcy5yYXdzLmF0dHJpYnV0ZSB8fCB0aGlzLmF0dHJpYnV0ZSk7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiBcImluc2Vuc2l0aXZlRmxhZ1wiLFxuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmluc2Vuc2l0aXZlID8gJ2knIDogJyc7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiBcInZhbHVlXCIsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBCZWZvcmUgMy4wLCB0aGUgdmFsdWUgaGFkIHRvIGJlIHNldCB0byBhbiBlc2NhcGVkIHZhbHVlIGluY2x1ZGluZyBhbnkgd3JhcHBlZFxuXHQgICAgICogcXVvdGUgbWFya3MuIEluIDMuMCwgdGhlIHNlbWFudGljcyBvZiBgQXR0cmlidXRlLnZhbHVlYCBjaGFuZ2VkIHNvIHRoYXQgdGhlIHZhbHVlXG5cdCAgICAgKiBpcyB1bmVzY2FwZWQgZHVyaW5nIHBhcnNpbmcgYW5kIGFueSBxdW90ZSBtYXJrcyBhcmUgcmVtb3ZlZC5cblx0ICAgICAqXG5cdCAgICAgKiBCZWNhdXNlIHRoZSBhbWJpZ3VpdHkgb2YgdGhpcyBzZW1hbnRpYyBjaGFuZ2UsIGlmIHlvdSBzZXQgYGF0dHIudmFsdWUgPSBuZXdWYWx1ZWAsXG5cdCAgICAgKiBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgaXMgcmFpc2VkIHdoZW4gdGhlIG5ldyB2YWx1ZSBjb250YWlucyBhbnkgY2hhcmFjdGVycyB0aGF0IHdvdWxkXG5cdCAgICAgKiByZXF1aXJlIGVzY2FwaW5nIChpbmNsdWRpbmcgaWYgaXQgY29udGFpbnMgd3JhcHBlZCBxdW90ZXMpLlxuXHQgICAgICpcblx0ICAgICAqIEluc3RlYWQsIHlvdSBzaG91bGQgY2FsbCBgYXR0ci5zZXRWYWx1ZShuZXdWYWx1ZSwgb3B0cylgIGFuZCBwYXNzIG9wdGlvbnMgdGhhdCBkZXNjcmliZVxuXHQgICAgICogaG93IHRoZSBuZXcgdmFsdWUgaXMgcXVvdGVkLlxuXHQgICAgICovXG5cdCAgICAsXG5cdCAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2KSB7XG5cdCAgICAgIGlmICh0aGlzLl9jb25zdHJ1Y3RlZCkge1xuXHQgICAgICAgIHZhciBfdW5lc2NhcGVWYWx1ZTIgPSB1bmVzY2FwZVZhbHVlKHYpLFxuXHQgICAgICAgICAgICBkZXByZWNhdGVkVXNhZ2UgPSBfdW5lc2NhcGVWYWx1ZTIuZGVwcmVjYXRlZFVzYWdlLFxuXHQgICAgICAgICAgICB1bmVzY2FwZWQgPSBfdW5lc2NhcGVWYWx1ZTIudW5lc2NhcGVkLFxuXHQgICAgICAgICAgICBxdW90ZU1hcmsgPSBfdW5lc2NhcGVWYWx1ZTIucXVvdGVNYXJrO1xuXG5cdCAgICAgICAgaWYgKGRlcHJlY2F0ZWRVc2FnZSkge1xuXHQgICAgICAgICAgd2Fybk9mRGVwcmVjYXRlZFZhbHVlQXNzaWdubWVudCgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh1bmVzY2FwZWQgPT09IHRoaXMuX3ZhbHVlICYmIHF1b3RlTWFyayA9PT0gdGhpcy5fcXVvdGVNYXJrKSB7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhpcy5fdmFsdWUgPSB1bmVzY2FwZWQ7XG5cdCAgICAgICAgdGhpcy5fcXVvdGVNYXJrID0gcXVvdGVNYXJrO1xuXG5cdCAgICAgICAgdGhpcy5fc3luY1Jhd1ZhbHVlKCk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy5fdmFsdWUgPSB2O1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiBcImF0dHJpYnV0ZVwiLFxuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9hdHRyaWJ1dGU7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbiBzZXQobmFtZSkge1xuXHQgICAgICB0aGlzLl9oYW5kbGVFc2NhcGVzKFwiYXR0cmlidXRlXCIsIG5hbWUpO1xuXG5cdCAgICAgIHRoaXMuX2F0dHJpYnV0ZSA9IG5hbWU7XG5cdCAgICB9XG5cdCAgfV0pO1xuXG5cdCAgcmV0dXJuIEF0dHJpYnV0ZTtcblx0fShfbmFtZXNwYWNlW1wiZGVmYXVsdFwiXSk7XG5cblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBBdHRyaWJ1dGU7XG5cdEF0dHJpYnV0ZS5OT19RVU9URSA9IG51bGw7XG5cdEF0dHJpYnV0ZS5TSU5HTEVfUVVPVEUgPSBcIidcIjtcblx0QXR0cmlidXRlLkRPVUJMRV9RVU9URSA9ICdcIic7XG5cdHZhciBDU1NFU0NfUVVPVEVfT1BUSU9OUyA9IChfQ1NTRVNDX1FVT1RFX09QVElPTlMgPSB7XG5cdCAgXCInXCI6IHtcblx0ICAgIHF1b3RlczogJ3NpbmdsZScsXG5cdCAgICB3cmFwOiB0cnVlXG5cdCAgfSxcblx0ICAnXCInOiB7XG5cdCAgICBxdW90ZXM6ICdkb3VibGUnLFxuXHQgICAgd3JhcDogdHJ1ZVxuXHQgIH1cblx0fSwgX0NTU0VTQ19RVU9URV9PUFRJT05TW251bGxdID0ge1xuXHQgIGlzSWRlbnRpZmllcjogdHJ1ZVxuXHR9LCBfQ1NTRVNDX1FVT1RFX09QVElPTlMpO1xuXG5cdGZ1bmN0aW9uIGRlZmF1bHRBdHRyQ29uY2F0KGF0dHJWYWx1ZSwgYXR0clNwYWNlcykge1xuXHQgIHJldHVybiBcIlwiICsgYXR0clNwYWNlcy5iZWZvcmUgKyBhdHRyVmFsdWUgKyBhdHRyU3BhY2VzLmFmdGVyO1xuXHR9XG59IChhdHRyaWJ1dGUkMSkpO1xuXG52YXIgdW5pdmVyc2FsJDEgPSB7ZXhwb3J0czoge319O1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG5cdHZhciBfbmFtZXNwYWNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChuYW1lc3BhY2UuZXhwb3J0cyk7XG5cblx0dmFyIF90eXBlcyA9IHR5cGVzO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5cdGZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5cdGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cblx0dmFyIFVuaXZlcnNhbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05hbWVzcGFjZSkge1xuXHQgIF9pbmhlcml0c0xvb3NlKFVuaXZlcnNhbCwgX05hbWVzcGFjZSk7XG5cblx0ICBmdW5jdGlvbiBVbml2ZXJzYWwob3B0cykge1xuXHQgICAgdmFyIF90aGlzO1xuXG5cdCAgICBfdGhpcyA9IF9OYW1lc3BhY2UuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuXHQgICAgX3RoaXMudHlwZSA9IF90eXBlcy5VTklWRVJTQUw7XG5cdCAgICBfdGhpcy52YWx1ZSA9ICcqJztcblx0ICAgIHJldHVybiBfdGhpcztcblx0ICB9XG5cblx0ICByZXR1cm4gVW5pdmVyc2FsO1xuXHR9KF9uYW1lc3BhY2VbXCJkZWZhdWx0XCJdKTtcblxuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IFVuaXZlcnNhbDtcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59ICh1bml2ZXJzYWwkMSwgdW5pdmVyc2FsJDEuZXhwb3J0cykpO1xuXG52YXIgY29tYmluYXRvciQyID0ge2V4cG9ydHM6IHt9fTtcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxuXHR2YXIgX25vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG5vZGUkMS5leHBvcnRzKTtcblxuXHR2YXIgX3R5cGVzID0gdHlwZXM7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cblx0ZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cblx0ZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuXHR2YXIgQ29tYmluYXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUpIHtcblx0ICBfaW5oZXJpdHNMb29zZShDb21iaW5hdG9yLCBfTm9kZSk7XG5cblx0ICBmdW5jdGlvbiBDb21iaW5hdG9yKG9wdHMpIHtcblx0ICAgIHZhciBfdGhpcztcblxuXHQgICAgX3RoaXMgPSBfTm9kZS5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG5cdCAgICBfdGhpcy50eXBlID0gX3R5cGVzLkNPTUJJTkFUT1I7XG5cdCAgICByZXR1cm4gX3RoaXM7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIENvbWJpbmF0b3I7XG5cdH0oX25vZGVbXCJkZWZhdWx0XCJdKTtcblxuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IENvbWJpbmF0b3I7XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufSAoY29tYmluYXRvciQyLCBjb21iaW5hdG9yJDIuZXhwb3J0cykpO1xuXG52YXIgbmVzdGluZyQxID0ge2V4cG9ydHM6IHt9fTtcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxuXHR2YXIgX25vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG5vZGUkMS5leHBvcnRzKTtcblxuXHR2YXIgX3R5cGVzID0gdHlwZXM7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cblx0ZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cblx0ZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuXHR2YXIgTmVzdGluZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUpIHtcblx0ICBfaW5oZXJpdHNMb29zZShOZXN0aW5nLCBfTm9kZSk7XG5cblx0ICBmdW5jdGlvbiBOZXN0aW5nKG9wdHMpIHtcblx0ICAgIHZhciBfdGhpcztcblxuXHQgICAgX3RoaXMgPSBfTm9kZS5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG5cdCAgICBfdGhpcy50eXBlID0gX3R5cGVzLk5FU1RJTkc7XG5cdCAgICBfdGhpcy52YWx1ZSA9ICcmJztcblx0ICAgIHJldHVybiBfdGhpcztcblx0ICB9XG5cblx0ICByZXR1cm4gTmVzdGluZztcblx0fShfbm9kZVtcImRlZmF1bHRcIl0pO1xuXG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gTmVzdGluZztcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59IChuZXN0aW5nJDEsIG5lc3RpbmckMS5leHBvcnRzKSk7XG5cbnZhciBzb3J0QXNjZW5kaW5nID0ge2V4cG9ydHM6IHt9fTtcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHNvcnRBc2NlbmRpbmc7XG5cblx0ZnVuY3Rpb24gc29ydEFzY2VuZGluZyhsaXN0KSB7XG5cdCAgcmV0dXJuIGxpc3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHQgICAgcmV0dXJuIGEgLSBiO1xuXHQgIH0pO1xuXHR9XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufSAoc29ydEFzY2VuZGluZywgc29ydEFzY2VuZGluZy5leHBvcnRzKSk7XG5cbnZhciB0b2tlbml6ZSA9IHt9O1xuXG52YXIgdG9rZW5UeXBlcyA9IHt9O1xuXG50b2tlblR5cGVzLl9fZXNNb2R1bGUgPSB0cnVlO1xudG9rZW5UeXBlcy5jb21iaW5hdG9yID0gdG9rZW5UeXBlcy53b3JkID0gdG9rZW5UeXBlcy5jb21tZW50ID0gdG9rZW5UeXBlcy5zdHIgPSB0b2tlblR5cGVzLnRhYiA9IHRva2VuVHlwZXMubmV3bGluZSA9IHRva2VuVHlwZXMuZmVlZCA9IHRva2VuVHlwZXMuY3IgPSB0b2tlblR5cGVzLmJhY2tzbGFzaCA9IHRva2VuVHlwZXMuYmFuZyA9IHRva2VuVHlwZXMuc2xhc2ggPSB0b2tlblR5cGVzLmRvdWJsZVF1b3RlID0gdG9rZW5UeXBlcy5zaW5nbGVRdW90ZSA9IHRva2VuVHlwZXMuc3BhY2UgPSB0b2tlblR5cGVzLmdyZWF0ZXJUaGFuID0gdG9rZW5UeXBlcy5waXBlID0gdG9rZW5UeXBlcy5lcXVhbHMgPSB0b2tlblR5cGVzLnBsdXMgPSB0b2tlblR5cGVzLmNhcmV0ID0gdG9rZW5UeXBlcy50aWxkZSA9IHRva2VuVHlwZXMuZG9sbGFyID0gdG9rZW5UeXBlcy5jbG9zZVNxdWFyZSA9IHRva2VuVHlwZXMub3BlblNxdWFyZSA9IHRva2VuVHlwZXMuY2xvc2VQYXJlbnRoZXNpcyA9IHRva2VuVHlwZXMub3BlblBhcmVudGhlc2lzID0gdG9rZW5UeXBlcy5zZW1pY29sb24gPSB0b2tlblR5cGVzLmNvbG9uID0gdG9rZW5UeXBlcy5jb21tYSA9IHRva2VuVHlwZXMuYXQgPSB0b2tlblR5cGVzLmFzdGVyaXNrID0gdG9rZW5UeXBlcy5hbXBlcnNhbmQgPSB2b2lkIDA7XG52YXIgYW1wZXJzYW5kID0gMzg7IC8vIGAmYC5jaGFyQ29kZUF0KDApO1xuXG50b2tlblR5cGVzLmFtcGVyc2FuZCA9IGFtcGVyc2FuZDtcbnZhciBhc3RlcmlzayA9IDQyOyAvLyBgKmAuY2hhckNvZGVBdCgwKTtcblxudG9rZW5UeXBlcy5hc3RlcmlzayA9IGFzdGVyaXNrO1xudmFyIGF0ID0gNjQ7IC8vIGBAYC5jaGFyQ29kZUF0KDApO1xuXG50b2tlblR5cGVzLmF0ID0gYXQ7XG52YXIgY29tbWEgPSA0NDsgLy8gYCxgLmNoYXJDb2RlQXQoMCk7XG5cbnRva2VuVHlwZXMuY29tbWEgPSBjb21tYTtcbnZhciBjb2xvbiA9IDU4OyAvLyBgOmAuY2hhckNvZGVBdCgwKTtcblxudG9rZW5UeXBlcy5jb2xvbiA9IGNvbG9uO1xudmFyIHNlbWljb2xvbiA9IDU5OyAvLyBgO2AuY2hhckNvZGVBdCgwKTtcblxudG9rZW5UeXBlcy5zZW1pY29sb24gPSBzZW1pY29sb247XG52YXIgb3BlblBhcmVudGhlc2lzID0gNDA7IC8vIGAoYC5jaGFyQ29kZUF0KDApO1xuXG50b2tlblR5cGVzLm9wZW5QYXJlbnRoZXNpcyA9IG9wZW5QYXJlbnRoZXNpcztcbnZhciBjbG9zZVBhcmVudGhlc2lzID0gNDE7IC8vIGApYC5jaGFyQ29kZUF0KDApO1xuXG50b2tlblR5cGVzLmNsb3NlUGFyZW50aGVzaXMgPSBjbG9zZVBhcmVudGhlc2lzO1xudmFyIG9wZW5TcXVhcmUgPSA5MTsgLy8gYFtgLmNoYXJDb2RlQXQoMCk7XG5cbnRva2VuVHlwZXMub3BlblNxdWFyZSA9IG9wZW5TcXVhcmU7XG52YXIgY2xvc2VTcXVhcmUgPSA5MzsgLy8gYF1gLmNoYXJDb2RlQXQoMCk7XG5cbnRva2VuVHlwZXMuY2xvc2VTcXVhcmUgPSBjbG9zZVNxdWFyZTtcbnZhciBkb2xsYXIgPSAzNjsgLy8gYCRgLmNoYXJDb2RlQXQoMCk7XG5cbnRva2VuVHlwZXMuZG9sbGFyID0gZG9sbGFyO1xudmFyIHRpbGRlID0gMTI2OyAvLyBgfmAuY2hhckNvZGVBdCgwKTtcblxudG9rZW5UeXBlcy50aWxkZSA9IHRpbGRlO1xudmFyIGNhcmV0ID0gOTQ7IC8vIGBeYC5jaGFyQ29kZUF0KDApO1xuXG50b2tlblR5cGVzLmNhcmV0ID0gY2FyZXQ7XG52YXIgcGx1cyA9IDQzOyAvLyBgK2AuY2hhckNvZGVBdCgwKTtcblxudG9rZW5UeXBlcy5wbHVzID0gcGx1cztcbnZhciBlcXVhbHMgPSA2MTsgLy8gYD1gLmNoYXJDb2RlQXQoMCk7XG5cbnRva2VuVHlwZXMuZXF1YWxzID0gZXF1YWxzO1xudmFyIHBpcGUgPSAxMjQ7IC8vIGB8YC5jaGFyQ29kZUF0KDApO1xuXG50b2tlblR5cGVzLnBpcGUgPSBwaXBlO1xudmFyIGdyZWF0ZXJUaGFuID0gNjI7IC8vIGA+YC5jaGFyQ29kZUF0KDApO1xuXG50b2tlblR5cGVzLmdyZWF0ZXJUaGFuID0gZ3JlYXRlclRoYW47XG52YXIgc3BhY2UgPSAzMjsgLy8gYCBgLmNoYXJDb2RlQXQoMCk7XG5cbnRva2VuVHlwZXMuc3BhY2UgPSBzcGFjZTtcbnZhciBzaW5nbGVRdW90ZSA9IDM5OyAvLyBgJ2AuY2hhckNvZGVBdCgwKTtcblxudG9rZW5UeXBlcy5zaW5nbGVRdW90ZSA9IHNpbmdsZVF1b3RlO1xudmFyIGRvdWJsZVF1b3RlID0gMzQ7IC8vIGBcImAuY2hhckNvZGVBdCgwKTtcblxudG9rZW5UeXBlcy5kb3VibGVRdW90ZSA9IGRvdWJsZVF1b3RlO1xudmFyIHNsYXNoID0gNDc7IC8vIGAvYC5jaGFyQ29kZUF0KDApO1xuXG50b2tlblR5cGVzLnNsYXNoID0gc2xhc2g7XG52YXIgYmFuZyA9IDMzOyAvLyBgIWAuY2hhckNvZGVBdCgwKTtcblxudG9rZW5UeXBlcy5iYW5nID0gYmFuZztcbnZhciBiYWNrc2xhc2ggPSA5MjsgLy8gJ1xcXFwnLmNoYXJDb2RlQXQoMCk7XG5cbnRva2VuVHlwZXMuYmFja3NsYXNoID0gYmFja3NsYXNoO1xudmFyIGNyID0gMTM7IC8vICdcXHInLmNoYXJDb2RlQXQoMCk7XG5cbnRva2VuVHlwZXMuY3IgPSBjcjtcbnZhciBmZWVkID0gMTI7IC8vICdcXGYnLmNoYXJDb2RlQXQoMCk7XG5cbnRva2VuVHlwZXMuZmVlZCA9IGZlZWQ7XG52YXIgbmV3bGluZSA9IDEwOyAvLyAnXFxuJy5jaGFyQ29kZUF0KDApO1xuXG50b2tlblR5cGVzLm5ld2xpbmUgPSBuZXdsaW5lO1xudmFyIHRhYiA9IDk7IC8vICdcXHQnLmNoYXJDb2RlQXQoMCk7XG4vLyBFeHBvc2UgYWxpYXNlcyBwcmltYXJpbHkgZm9yIHJlYWRhYmlsaXR5LlxuXG50b2tlblR5cGVzLnRhYiA9IHRhYjtcbnZhciBzdHIgPSBzaW5nbGVRdW90ZTsgLy8gTm8gZ29vZCBzaW5nbGUgY2hhcmFjdGVyIHJlcHJlc2VudGF0aW9uIVxuXG50b2tlblR5cGVzLnN0ciA9IHN0cjtcbnZhciBjb21tZW50JDEgPSAtMTtcbnRva2VuVHlwZXMuY29tbWVudCA9IGNvbW1lbnQkMTtcbnZhciB3b3JkID0gLTI7XG50b2tlblR5cGVzLndvcmQgPSB3b3JkO1xudmFyIGNvbWJpbmF0b3IkMSA9IC0zO1xudG9rZW5UeXBlcy5jb21iaW5hdG9yID0gY29tYmluYXRvciQxO1xuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHRva2VuaXplO1xuXHRleHBvcnRzLkZJRUxEUyA9IHZvaWQgMDtcblxuXHR2YXIgdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHRva2VuVHlwZXMpO1xuXG5cdHZhciBfdW5lc2NhcGFibGUsIF93b3JkRGVsaW1pdGVycztcblxuXHRmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5cdHZhciB1bmVzY2FwYWJsZSA9IChfdW5lc2NhcGFibGUgPSB7fSwgX3VuZXNjYXBhYmxlW3QudGFiXSA9IHRydWUsIF91bmVzY2FwYWJsZVt0Lm5ld2xpbmVdID0gdHJ1ZSwgX3VuZXNjYXBhYmxlW3QuY3JdID0gdHJ1ZSwgX3VuZXNjYXBhYmxlW3QuZmVlZF0gPSB0cnVlLCBfdW5lc2NhcGFibGUpO1xuXHR2YXIgd29yZERlbGltaXRlcnMgPSAoX3dvcmREZWxpbWl0ZXJzID0ge30sIF93b3JkRGVsaW1pdGVyc1t0LnNwYWNlXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0LnRhYl0gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5uZXdsaW5lXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0LmNyXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0LmZlZWRdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QuYW1wZXJzYW5kXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0LmFzdGVyaXNrXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0LmJhbmddID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QuY29tbWFdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QuY29sb25dID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3Quc2VtaWNvbG9uXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0Lm9wZW5QYXJlbnRoZXNpc10gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5jbG9zZVBhcmVudGhlc2lzXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0Lm9wZW5TcXVhcmVdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QuY2xvc2VTcXVhcmVdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3Quc2luZ2xlUXVvdGVdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QuZG91YmxlUXVvdGVdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QucGx1c10gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5waXBlXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0LnRpbGRlXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0LmdyZWF0ZXJUaGFuXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0LmVxdWFsc10gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5kb2xsYXJdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QuY2FyZXRdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3Quc2xhc2hdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzKTtcblx0dmFyIGhleCA9IHt9O1xuXHR2YXIgaGV4Q2hhcnMgPSBcIjAxMjM0NTY3ODlhYmNkZWZBQkNERUZcIjtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGhleENoYXJzLmxlbmd0aDsgaSsrKSB7XG5cdCAgaGV4W2hleENoYXJzLmNoYXJDb2RlQXQoaSldID0gdHJ1ZTtcblx0fVxuXHQvKipcblx0ICogIFJldHVybnMgdGhlIGxhc3QgaW5kZXggb2YgdGhlIGJhciBjc3Mgd29yZFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY3NzIFRoZSBzdHJpbmcgaW4gd2hpY2ggdGhlIHdvcmQgYmVnaW5zXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgaW5kZXggaW50byB0aGUgc3RyaW5nIHdoZXJlIHdvcmQncyBmaXJzdCBsZXR0ZXIgb2NjdXJzXG5cdCAqL1xuXG5cblx0ZnVuY3Rpb24gY29uc3VtZVdvcmQoY3NzLCBzdGFydCkge1xuXHQgIHZhciBuZXh0ID0gc3RhcnQ7XG5cdCAgdmFyIGNvZGU7XG5cblx0ICBkbyB7XG5cdCAgICBjb2RlID0gY3NzLmNoYXJDb2RlQXQobmV4dCk7XG5cblx0ICAgIGlmICh3b3JkRGVsaW1pdGVyc1tjb2RlXSkge1xuXHQgICAgICByZXR1cm4gbmV4dCAtIDE7XG5cdCAgICB9IGVsc2UgaWYgKGNvZGUgPT09IHQuYmFja3NsYXNoKSB7XG5cdCAgICAgIG5leHQgPSBjb25zdW1lRXNjYXBlKGNzcywgbmV4dCkgKyAxO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gQWxsIG90aGVyIGNoYXJhY3RlcnMgYXJlIHBhcnQgb2YgdGhlIHdvcmRcblx0ICAgICAgbmV4dCsrO1xuXHQgICAgfVxuXHQgIH0gd2hpbGUgKG5leHQgPCBjc3MubGVuZ3RoKTtcblxuXHQgIHJldHVybiBuZXh0IC0gMTtcblx0fVxuXHQvKipcblx0ICogIFJldHVybnMgdGhlIGxhc3QgaW5kZXggb2YgdGhlIGVzY2FwZSBzZXF1ZW5jZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY3NzIFRoZSBzdHJpbmcgaW4gd2hpY2ggdGhlIHNlcXVlbmNlIGJlZ2luc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIGluZGV4IGludG8gdGhlIHN0cmluZyB3aGVyZSBlc2NhcGUgY2hhcmFjdGVyIChgXFxgKSBvY2N1cnMuXG5cdCAqL1xuXG5cblx0ZnVuY3Rpb24gY29uc3VtZUVzY2FwZShjc3MsIHN0YXJ0KSB7XG5cdCAgdmFyIG5leHQgPSBzdGFydDtcblx0ICB2YXIgY29kZSA9IGNzcy5jaGFyQ29kZUF0KG5leHQgKyAxKTtcblxuXHQgIGlmICh1bmVzY2FwYWJsZVtjb2RlXSkgOyBlbHNlIGlmIChoZXhbY29kZV0pIHtcblx0ICAgIHZhciBoZXhEaWdpdHMgPSAwOyAvLyBjb25zdW1lIHVwIHRvIDYgaGV4IGNoYXJzXG5cblx0ICAgIGRvIHtcblx0ICAgICAgbmV4dCsrO1xuXHQgICAgICBoZXhEaWdpdHMrKztcblx0ICAgICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KG5leHQgKyAxKTtcblx0ICAgIH0gd2hpbGUgKGhleFtjb2RlXSAmJiBoZXhEaWdpdHMgPCA2KTsgLy8gaWYgZmV3ZXIgdGhhbiA2IGhleCBjaGFycywgYSB0cmFpbGluZyBzcGFjZSBlbmRzIHRoZSBlc2NhcGVcblxuXG5cdCAgICBpZiAoaGV4RGlnaXRzIDwgNiAmJiBjb2RlID09PSB0LnNwYWNlKSB7XG5cdCAgICAgIG5leHQrKztcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gdGhlIG5leHQgY2hhciBpcyBwYXJ0IG9mIHRoZSBjdXJyZW50IHdvcmRcblx0ICAgIG5leHQrKztcblx0ICB9XG5cblx0ICByZXR1cm4gbmV4dDtcblx0fVxuXG5cdHZhciBGSUVMRFMgPSB7XG5cdCAgVFlQRTogMCxcblx0ICBTVEFSVF9MSU5FOiAxLFxuXHQgIFNUQVJUX0NPTDogMixcblx0ICBFTkRfTElORTogMyxcblx0ICBFTkRfQ09MOiA0LFxuXHQgIFNUQVJUX1BPUzogNSxcblx0ICBFTkRfUE9TOiA2XG5cdH07XG5cdGV4cG9ydHMuRklFTERTID0gRklFTERTO1xuXG5cdGZ1bmN0aW9uIHRva2VuaXplKGlucHV0KSB7XG5cdCAgdmFyIHRva2VucyA9IFtdO1xuXHQgIHZhciBjc3MgPSBpbnB1dC5jc3MudmFsdWVPZigpO1xuXHQgIHZhciBfY3NzID0gY3NzLFxuXHQgICAgICBsZW5ndGggPSBfY3NzLmxlbmd0aDtcblx0ICB2YXIgb2Zmc2V0ID0gLTE7XG5cdCAgdmFyIGxpbmUgPSAxO1xuXHQgIHZhciBzdGFydCA9IDA7XG5cdCAgdmFyIGVuZCA9IDA7XG5cdCAgdmFyIGNvZGUsIGNvbnRlbnQsIGVuZENvbHVtbiwgZW5kTGluZSwgZXNjYXBlZCwgZXNjYXBlUG9zLCBsYXN0LCBsaW5lcywgbmV4dCwgbmV4dExpbmUsIG5leHRPZmZzZXQsIHF1b3RlLCB0b2tlblR5cGU7XG5cblx0ICBmdW5jdGlvbiB1bmNsb3NlZCh3aGF0LCBmaXgpIHtcblx0ICAgIGlmIChpbnB1dC5zYWZlKSB7XG5cdCAgICAgIC8vIGZ5aTogdGhpcyBpcyBuZXZlciBzZXQgdG8gdHJ1ZS5cblx0ICAgICAgY3NzICs9IGZpeDtcblx0ICAgICAgbmV4dCA9IGNzcy5sZW5ndGggLSAxO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhyb3cgaW5wdXQuZXJyb3IoJ1VuY2xvc2VkICcgKyB3aGF0LCBsaW5lLCBzdGFydCAtIG9mZnNldCwgc3RhcnQpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHdoaWxlIChzdGFydCA8IGxlbmd0aCkge1xuXHQgICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KHN0YXJ0KTtcblxuXHQgICAgaWYgKGNvZGUgPT09IHQubmV3bGluZSkge1xuXHQgICAgICBvZmZzZXQgPSBzdGFydDtcblx0ICAgICAgbGluZSArPSAxO1xuXHQgICAgfVxuXG5cdCAgICBzd2l0Y2ggKGNvZGUpIHtcblx0ICAgICAgY2FzZSB0LnNwYWNlOlxuXHQgICAgICBjYXNlIHQudGFiOlxuXHQgICAgICBjYXNlIHQubmV3bGluZTpcblx0ICAgICAgY2FzZSB0LmNyOlxuXHQgICAgICBjYXNlIHQuZmVlZDpcblx0ICAgICAgICBuZXh0ID0gc3RhcnQ7XG5cblx0ICAgICAgICBkbyB7XG5cdCAgICAgICAgICBuZXh0ICs9IDE7XG5cdCAgICAgICAgICBjb2RlID0gY3NzLmNoYXJDb2RlQXQobmV4dCk7XG5cblx0ICAgICAgICAgIGlmIChjb2RlID09PSB0Lm5ld2xpbmUpIHtcblx0ICAgICAgICAgICAgb2Zmc2V0ID0gbmV4dDtcblx0ICAgICAgICAgICAgbGluZSArPSAxO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gd2hpbGUgKGNvZGUgPT09IHQuc3BhY2UgfHwgY29kZSA9PT0gdC5uZXdsaW5lIHx8IGNvZGUgPT09IHQudGFiIHx8IGNvZGUgPT09IHQuY3IgfHwgY29kZSA9PT0gdC5mZWVkKTtcblxuXHQgICAgICAgIHRva2VuVHlwZSA9IHQuc3BhY2U7XG5cdCAgICAgICAgZW5kTGluZSA9IGxpbmU7XG5cdCAgICAgICAgZW5kQ29sdW1uID0gbmV4dCAtIG9mZnNldCAtIDE7XG5cdCAgICAgICAgZW5kID0gbmV4dDtcblx0ICAgICAgICBicmVhaztcblxuXHQgICAgICBjYXNlIHQucGx1czpcblx0ICAgICAgY2FzZSB0LmdyZWF0ZXJUaGFuOlxuXHQgICAgICBjYXNlIHQudGlsZGU6XG5cdCAgICAgIGNhc2UgdC5waXBlOlxuXHQgICAgICAgIG5leHQgPSBzdGFydDtcblxuXHQgICAgICAgIGRvIHtcblx0ICAgICAgICAgIG5leHQgKz0gMTtcblx0ICAgICAgICAgIGNvZGUgPSBjc3MuY2hhckNvZGVBdChuZXh0KTtcblx0ICAgICAgICB9IHdoaWxlIChjb2RlID09PSB0LnBsdXMgfHwgY29kZSA9PT0gdC5ncmVhdGVyVGhhbiB8fCBjb2RlID09PSB0LnRpbGRlIHx8IGNvZGUgPT09IHQucGlwZSk7XG5cblx0ICAgICAgICB0b2tlblR5cGUgPSB0LmNvbWJpbmF0b3I7XG5cdCAgICAgICAgZW5kTGluZSA9IGxpbmU7XG5cdCAgICAgICAgZW5kQ29sdW1uID0gc3RhcnQgLSBvZmZzZXQ7XG5cdCAgICAgICAgZW5kID0gbmV4dDtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgLy8gQ29uc3VtZSB0aGVzZSBjaGFyYWN0ZXJzIGFzIHNpbmdsZSB0b2tlbnMuXG5cblx0ICAgICAgY2FzZSB0LmFzdGVyaXNrOlxuXHQgICAgICBjYXNlIHQuYW1wZXJzYW5kOlxuXHQgICAgICBjYXNlIHQuYmFuZzpcblx0ICAgICAgY2FzZSB0LmNvbW1hOlxuXHQgICAgICBjYXNlIHQuZXF1YWxzOlxuXHQgICAgICBjYXNlIHQuZG9sbGFyOlxuXHQgICAgICBjYXNlIHQuY2FyZXQ6XG5cdCAgICAgIGNhc2UgdC5vcGVuU3F1YXJlOlxuXHQgICAgICBjYXNlIHQuY2xvc2VTcXVhcmU6XG5cdCAgICAgIGNhc2UgdC5jb2xvbjpcblx0ICAgICAgY2FzZSB0LnNlbWljb2xvbjpcblx0ICAgICAgY2FzZSB0Lm9wZW5QYXJlbnRoZXNpczpcblx0ICAgICAgY2FzZSB0LmNsb3NlUGFyZW50aGVzaXM6XG5cdCAgICAgICAgbmV4dCA9IHN0YXJ0O1xuXHQgICAgICAgIHRva2VuVHlwZSA9IGNvZGU7XG5cdCAgICAgICAgZW5kTGluZSA9IGxpbmU7XG5cdCAgICAgICAgZW5kQ29sdW1uID0gc3RhcnQgLSBvZmZzZXQ7XG5cdCAgICAgICAgZW5kID0gbmV4dCArIDE7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgY2FzZSB0LnNpbmdsZVF1b3RlOlxuXHQgICAgICBjYXNlIHQuZG91YmxlUXVvdGU6XG5cdCAgICAgICAgcXVvdGUgPSBjb2RlID09PSB0LnNpbmdsZVF1b3RlID8gXCInXCIgOiAnXCInO1xuXHQgICAgICAgIG5leHQgPSBzdGFydDtcblxuXHQgICAgICAgIGRvIHtcblx0ICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcblx0ICAgICAgICAgIG5leHQgPSBjc3MuaW5kZXhPZihxdW90ZSwgbmV4dCArIDEpO1xuXG5cdCAgICAgICAgICBpZiAobmV4dCA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgdW5jbG9zZWQoJ3F1b3RlJywgcXVvdGUpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBlc2NhcGVQb3MgPSBuZXh0O1xuXG5cdCAgICAgICAgICB3aGlsZSAoY3NzLmNoYXJDb2RlQXQoZXNjYXBlUG9zIC0gMSkgPT09IHQuYmFja3NsYXNoKSB7XG5cdCAgICAgICAgICAgIGVzY2FwZVBvcyAtPSAxO1xuXHQgICAgICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQ7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSB3aGlsZSAoZXNjYXBlZCk7XG5cblx0ICAgICAgICB0b2tlblR5cGUgPSB0LnN0cjtcblx0ICAgICAgICBlbmRMaW5lID0gbGluZTtcblx0ICAgICAgICBlbmRDb2x1bW4gPSBzdGFydCAtIG9mZnNldDtcblx0ICAgICAgICBlbmQgPSBuZXh0ICsgMTtcblx0ICAgICAgICBicmVhaztcblxuXHQgICAgICBkZWZhdWx0OlxuXHQgICAgICAgIGlmIChjb2RlID09PSB0LnNsYXNoICYmIGNzcy5jaGFyQ29kZUF0KHN0YXJ0ICsgMSkgPT09IHQuYXN0ZXJpc2spIHtcblx0ICAgICAgICAgIG5leHQgPSBjc3MuaW5kZXhPZignKi8nLCBzdGFydCArIDIpICsgMTtcblxuXHQgICAgICAgICAgaWYgKG5leHQgPT09IDApIHtcblx0ICAgICAgICAgICAgdW5jbG9zZWQoJ2NvbW1lbnQnLCAnKi8nKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgY29udGVudCA9IGNzcy5zbGljZShzdGFydCwgbmV4dCArIDEpO1xuXHQgICAgICAgICAgbGluZXMgPSBjb250ZW50LnNwbGl0KCdcXG4nKTtcblx0ICAgICAgICAgIGxhc3QgPSBsaW5lcy5sZW5ndGggLSAxO1xuXG5cdCAgICAgICAgICBpZiAobGFzdCA+IDApIHtcblx0ICAgICAgICAgICAgbmV4dExpbmUgPSBsaW5lICsgbGFzdDtcblx0ICAgICAgICAgICAgbmV4dE9mZnNldCA9IG5leHQgLSBsaW5lc1tsYXN0XS5sZW5ndGg7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBuZXh0TGluZSA9IGxpbmU7XG5cdCAgICAgICAgICAgIG5leHRPZmZzZXQgPSBvZmZzZXQ7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHRva2VuVHlwZSA9IHQuY29tbWVudDtcblx0ICAgICAgICAgIGxpbmUgPSBuZXh0TGluZTtcblx0ICAgICAgICAgIGVuZExpbmUgPSBuZXh0TGluZTtcblx0ICAgICAgICAgIGVuZENvbHVtbiA9IG5leHQgLSBuZXh0T2Zmc2V0O1xuXHQgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gdC5zbGFzaCkge1xuXHQgICAgICAgICAgbmV4dCA9IHN0YXJ0O1xuXHQgICAgICAgICAgdG9rZW5UeXBlID0gY29kZTtcblx0ICAgICAgICAgIGVuZExpbmUgPSBsaW5lO1xuXHQgICAgICAgICAgZW5kQ29sdW1uID0gc3RhcnQgLSBvZmZzZXQ7XG5cdCAgICAgICAgICBlbmQgPSBuZXh0ICsgMTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgbmV4dCA9IGNvbnN1bWVXb3JkKGNzcywgc3RhcnQpO1xuXHQgICAgICAgICAgdG9rZW5UeXBlID0gdC53b3JkO1xuXHQgICAgICAgICAgZW5kTGluZSA9IGxpbmU7XG5cdCAgICAgICAgICBlbmRDb2x1bW4gPSBuZXh0IC0gb2Zmc2V0O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGVuZCA9IG5leHQgKyAxO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgfSAvLyBFbnN1cmUgdGhhdCB0aGUgdG9rZW4gc3RydWN0dXJlIHJlbWFpbnMgY29uc2lzdGVudFxuXG5cblx0ICAgIHRva2Vucy5wdXNoKFt0b2tlblR5cGUsIC8vIFswXSBUb2tlbiB0eXBlXG5cdCAgICBsaW5lLCAvLyBbMV0gU3RhcnRpbmcgbGluZVxuXHQgICAgc3RhcnQgLSBvZmZzZXQsIC8vIFsyXSBTdGFydGluZyBjb2x1bW5cblx0ICAgIGVuZExpbmUsIC8vIFszXSBFbmRpbmcgbGluZVxuXHQgICAgZW5kQ29sdW1uLCAvLyBbNF0gRW5kaW5nIGNvbHVtblxuXHQgICAgc3RhcnQsIC8vIFs1XSBTdGFydCBwb3NpdGlvbiAvIFNvdXJjZSBpbmRleFxuXHQgICAgZW5kIC8vIFs2XSBFbmQgcG9zaXRpb25cblx0ICAgIF0pOyAvLyBSZXNldCBvZmZzZXQgZm9yIHRoZSBuZXh0IHRva2VuXG5cblx0ICAgIGlmIChuZXh0T2Zmc2V0KSB7XG5cdCAgICAgIG9mZnNldCA9IG5leHRPZmZzZXQ7XG5cdCAgICAgIG5leHRPZmZzZXQgPSBudWxsO1xuXHQgICAgfVxuXG5cdCAgICBzdGFydCA9IGVuZDtcblx0ICB9XG5cblx0ICByZXR1cm4gdG9rZW5zO1xuXHR9XG59ICh0b2tlbml6ZSkpO1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG5cdHZhciBfcm9vdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocm9vdCQxLmV4cG9ydHMpO1xuXG5cdHZhciBfc2VsZWN0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHNlbGVjdG9yJDEuZXhwb3J0cyk7XG5cblx0dmFyIF9jbGFzc05hbWUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGNsYXNzTmFtZSQxLmV4cG9ydHMpO1xuXG5cdHZhciBfY29tbWVudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoY29tbWVudCQyLmV4cG9ydHMpO1xuXG5cdHZhciBfaWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGlkJDEuZXhwb3J0cyk7XG5cblx0dmFyIF90YWcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHRhZyQxLmV4cG9ydHMpO1xuXG5cdHZhciBfc3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChzdHJpbmckMS5leHBvcnRzKTtcblxuXHR2YXIgX3BzZXVkbyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocHNldWRvJDEuZXhwb3J0cyk7XG5cblx0dmFyIF9hdHRyaWJ1dGUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChhdHRyaWJ1dGUkMSk7XG5cblx0dmFyIF91bml2ZXJzYWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHVuaXZlcnNhbCQxLmV4cG9ydHMpO1xuXG5cdHZhciBfY29tYmluYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoY29tYmluYXRvciQyLmV4cG9ydHMpO1xuXG5cdHZhciBfbmVzdGluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQobmVzdGluZyQxLmV4cG9ydHMpO1xuXG5cdHZhciBfc29ydEFzY2VuZGluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoc29ydEFzY2VuZGluZy5leHBvcnRzKTtcblxuXHR2YXIgX3Rva2VuaXplID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQodG9rZW5pemUpO1xuXG5cdHZhciB0b2tlbnMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCh0b2tlblR5cGVzKTtcblxuXHR2YXIgdHlwZXMkMSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHR5cGVzKTtcblxuXHR2YXIgX3V0aWwgPSB1dGlsO1xuXG5cdHZhciBfV0hJVEVTUEFDRV9UT0tFTlMsIF9PYmplY3QkYXNzaWduO1xuXG5cdGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cblx0ZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5cdGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cblx0dmFyIFdISVRFU1BBQ0VfVE9LRU5TID0gKF9XSElURVNQQUNFX1RPS0VOUyA9IHt9LCBfV0hJVEVTUEFDRV9UT0tFTlNbdG9rZW5zLnNwYWNlXSA9IHRydWUsIF9XSElURVNQQUNFX1RPS0VOU1t0b2tlbnMuY3JdID0gdHJ1ZSwgX1dISVRFU1BBQ0VfVE9LRU5TW3Rva2Vucy5mZWVkXSA9IHRydWUsIF9XSElURVNQQUNFX1RPS0VOU1t0b2tlbnMubmV3bGluZV0gPSB0cnVlLCBfV0hJVEVTUEFDRV9UT0tFTlNbdG9rZW5zLnRhYl0gPSB0cnVlLCBfV0hJVEVTUEFDRV9UT0tFTlMpO1xuXHR2YXIgV0hJVEVTUEFDRV9FUVVJVl9UT0tFTlMgPSBPYmplY3QuYXNzaWduKHt9LCBXSElURVNQQUNFX1RPS0VOUywgKF9PYmplY3QkYXNzaWduID0ge30sIF9PYmplY3QkYXNzaWduW3Rva2Vucy5jb21tZW50XSA9IHRydWUsIF9PYmplY3QkYXNzaWduKSk7XG5cblx0ZnVuY3Rpb24gdG9rZW5TdGFydCh0b2tlbikge1xuXHQgIHJldHVybiB7XG5cdCAgICBsaW5lOiB0b2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX0xJTkVdLFxuXHQgICAgY29sdW1uOiB0b2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX0NPTF1cblx0ICB9O1xuXHR9XG5cblx0ZnVuY3Rpb24gdG9rZW5FbmQodG9rZW4pIHtcblx0ICByZXR1cm4ge1xuXHQgICAgbGluZTogdG9rZW5bX3Rva2VuaXplLkZJRUxEUy5FTkRfTElORV0sXG5cdCAgICBjb2x1bW46IHRva2VuW190b2tlbml6ZS5GSUVMRFMuRU5EX0NPTF1cblx0ICB9O1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0U291cmNlKHN0YXJ0TGluZSwgc3RhcnRDb2x1bW4sIGVuZExpbmUsIGVuZENvbHVtbikge1xuXHQgIHJldHVybiB7XG5cdCAgICBzdGFydDoge1xuXHQgICAgICBsaW5lOiBzdGFydExpbmUsXG5cdCAgICAgIGNvbHVtbjogc3RhcnRDb2x1bW5cblx0ICAgIH0sXG5cdCAgICBlbmQ6IHtcblx0ICAgICAgbGluZTogZW5kTGluZSxcblx0ICAgICAgY29sdW1uOiBlbmRDb2x1bW5cblx0ICAgIH1cblx0ICB9O1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0VG9rZW5Tb3VyY2UodG9rZW4pIHtcblx0ICByZXR1cm4gZ2V0U291cmNlKHRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfTElORV0sIHRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfQ09MXSwgdG9rZW5bX3Rva2VuaXplLkZJRUxEUy5FTkRfTElORV0sIHRva2VuW190b2tlbml6ZS5GSUVMRFMuRU5EX0NPTF0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0VG9rZW5Tb3VyY2VTcGFuKHN0YXJ0VG9rZW4sIGVuZFRva2VuKSB7XG5cdCAgaWYgKCFzdGFydFRva2VuKSB7XG5cdCAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgIH1cblxuXHQgIHJldHVybiBnZXRTb3VyY2Uoc3RhcnRUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX0xJTkVdLCBzdGFydFRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfQ09MXSwgZW5kVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5FTkRfTElORV0sIGVuZFRva2VuW190b2tlbml6ZS5GSUVMRFMuRU5EX0NPTF0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gdW5lc2NhcGVQcm9wKG5vZGUsIHByb3ApIHtcblx0ICB2YXIgdmFsdWUgPSBub2RlW3Byb3BdO1xuXG5cdCAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblxuXHQgIGlmICh2YWx1ZS5pbmRleE9mKFwiXFxcXFwiKSAhPT0gLTEpIHtcblx0ICAgICgwLCBfdXRpbC5lbnN1cmVPYmplY3QpKG5vZGUsICdyYXdzJyk7XG5cdCAgICBub2RlW3Byb3BdID0gKDAsIF91dGlsLnVuZXNjKSh2YWx1ZSk7XG5cblx0ICAgIGlmIChub2RlLnJhd3NbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICBub2RlLnJhd3NbcHJvcF0gPSB2YWx1ZTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gbm9kZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGluZGV4ZXNPZihhcnJheSwgaXRlbSkge1xuXHQgIHZhciBpID0gLTE7XG5cdCAgdmFyIGluZGV4ZXMgPSBbXTtcblxuXHQgIHdoaWxlICgoaSA9IGFycmF5LmluZGV4T2YoaXRlbSwgaSArIDEpKSAhPT0gLTEpIHtcblx0ICAgIGluZGV4ZXMucHVzaChpKTtcblx0ICB9XG5cblx0ICByZXR1cm4gaW5kZXhlcztcblx0fVxuXG5cdGZ1bmN0aW9uIHVuaXFzKCkge1xuXHQgIHZhciBsaXN0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgYXJndW1lbnRzKTtcblx0ICByZXR1cm4gbGlzdC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0sIGkpIHtcblx0ICAgIHJldHVybiBpID09PSBsaXN0LmluZGV4T2YoaXRlbSk7XG5cdCAgfSk7XG5cdH1cblxuXHR2YXIgUGFyc2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBQYXJzZXIocnVsZSwgb3B0aW9ucykge1xuXHQgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuXHQgICAgICBvcHRpb25zID0ge307XG5cdCAgICB9XG5cblx0ICAgIHRoaXMucnVsZSA9IHJ1bGU7XG5cdCAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0ICAgICAgbG9zc3k6IGZhbHNlLFxuXHQgICAgICBzYWZlOiBmYWxzZVxuXHQgICAgfSwgb3B0aW9ucyk7XG5cdCAgICB0aGlzLnBvc2l0aW9uID0gMDtcblx0ICAgIHRoaXMuY3NzID0gdHlwZW9mIHRoaXMucnVsZSA9PT0gJ3N0cmluZycgPyB0aGlzLnJ1bGUgOiB0aGlzLnJ1bGUuc2VsZWN0b3I7XG5cdCAgICB0aGlzLnRva2VucyA9ICgwLCBfdG9rZW5pemVbXCJkZWZhdWx0XCJdKSh7XG5cdCAgICAgIGNzczogdGhpcy5jc3MsXG5cdCAgICAgIGVycm9yOiB0aGlzLl9lcnJvckdlbmVyYXRvcigpLFxuXHQgICAgICBzYWZlOiB0aGlzLm9wdGlvbnMuc2FmZVxuXHQgICAgfSk7XG5cdCAgICB2YXIgcm9vdFNvdXJjZSA9IGdldFRva2VuU291cmNlU3Bhbih0aGlzLnRva2Vuc1swXSwgdGhpcy50b2tlbnNbdGhpcy50b2tlbnMubGVuZ3RoIC0gMV0pO1xuXHQgICAgdGhpcy5yb290ID0gbmV3IF9yb290W1wiZGVmYXVsdFwiXSh7XG5cdCAgICAgIHNvdXJjZTogcm9vdFNvdXJjZVxuXHQgICAgfSk7XG5cdCAgICB0aGlzLnJvb3QuZXJyb3JHZW5lcmF0b3IgPSB0aGlzLl9lcnJvckdlbmVyYXRvcigpO1xuXHQgICAgdmFyIHNlbGVjdG9yID0gbmV3IF9zZWxlY3RvcltcImRlZmF1bHRcIl0oe1xuXHQgICAgICBzb3VyY2U6IHtcblx0ICAgICAgICBzdGFydDoge1xuXHQgICAgICAgICAgbGluZTogMSxcblx0ICAgICAgICAgIGNvbHVtbjogMVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICB0aGlzLnJvb3QuYXBwZW5kKHNlbGVjdG9yKTtcblx0ICAgIHRoaXMuY3VycmVudCA9IHNlbGVjdG9yO1xuXHQgICAgdGhpcy5sb29wKCk7XG5cdCAgfVxuXG5cdCAgdmFyIF9wcm90byA9IFBhcnNlci5wcm90b3R5cGU7XG5cblx0ICBfcHJvdG8uX2Vycm9yR2VuZXJhdG9yID0gZnVuY3Rpb24gX2Vycm9yR2VuZXJhdG9yKCkge1xuXHQgICAgdmFyIF90aGlzID0gdGhpcztcblxuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBlcnJvck9wdGlvbnMpIHtcblx0ICAgICAgaWYgKHR5cGVvZiBfdGhpcy5ydWxlID09PSAnc3RyaW5nJykge1xuXHQgICAgICAgIHJldHVybiBuZXcgRXJyb3IobWVzc2FnZSk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gX3RoaXMucnVsZS5lcnJvcihtZXNzYWdlLCBlcnJvck9wdGlvbnMpO1xuXHQgICAgfTtcblx0ICB9O1xuXG5cdCAgX3Byb3RvLmF0dHJpYnV0ZSA9IGZ1bmN0aW9uIGF0dHJpYnV0ZSgpIHtcblx0ICAgIHZhciBhdHRyID0gW107XG5cdCAgICB2YXIgc3RhcnRpbmdUb2tlbiA9IHRoaXMuY3VyclRva2VuO1xuXHQgICAgdGhpcy5wb3NpdGlvbisrO1xuXG5cdCAgICB3aGlsZSAodGhpcy5wb3NpdGlvbiA8IHRoaXMudG9rZW5zLmxlbmd0aCAmJiB0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdICE9PSB0b2tlbnMuY2xvc2VTcXVhcmUpIHtcblx0ICAgICAgYXR0ci5wdXNoKHRoaXMuY3VyclRva2VuKTtcblx0ICAgICAgdGhpcy5wb3NpdGlvbisrO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSAhPT0gdG9rZW5zLmNsb3NlU3F1YXJlKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmV4cGVjdGVkKCdjbG9zaW5nIHNxdWFyZSBicmFja2V0JywgdGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGxlbiA9IGF0dHIubGVuZ3RoO1xuXHQgICAgdmFyIG5vZGUgPSB7XG5cdCAgICAgIHNvdXJjZTogZ2V0U291cmNlKHN0YXJ0aW5nVG9rZW5bMV0sIHN0YXJ0aW5nVG9rZW5bMl0sIHRoaXMuY3VyclRva2VuWzNdLCB0aGlzLmN1cnJUb2tlbls0XSksXG5cdCAgICAgIHNvdXJjZUluZGV4OiBzdGFydGluZ1Rva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXVxuXHQgICAgfTtcblxuXHQgICAgaWYgKGxlbiA9PT0gMSAmJiAhflt0b2tlbnMud29yZF0uaW5kZXhPZihhdHRyWzBdW190b2tlbml6ZS5GSUVMRFMuVFlQRV0pKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmV4cGVjdGVkKCdhdHRyaWJ1dGUnLCBhdHRyWzBdW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBwb3MgPSAwO1xuXHQgICAgdmFyIHNwYWNlQmVmb3JlID0gJyc7XG5cdCAgICB2YXIgY29tbWVudEJlZm9yZSA9ICcnO1xuXHQgICAgdmFyIGxhc3RBZGRlZCA9IG51bGw7XG5cdCAgICB2YXIgc3BhY2VBZnRlck1lYW5pbmdmdWxUb2tlbiA9IGZhbHNlO1xuXG5cdCAgICB3aGlsZSAocG9zIDwgbGVuKSB7XG5cdCAgICAgIHZhciB0b2tlbiA9IGF0dHJbcG9zXTtcblx0ICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQodG9rZW4pO1xuXHQgICAgICB2YXIgbmV4dCA9IGF0dHJbcG9zICsgMV07XG5cblx0ICAgICAgc3dpdGNoICh0b2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdKSB7XG5cdCAgICAgICAgY2FzZSB0b2tlbnMuc3BhY2U6XG5cdCAgICAgICAgICAvLyBpZiAoXG5cdCAgICAgICAgICAvLyAgICAgbGVuID09PSAxIHx8XG5cdCAgICAgICAgICAvLyAgICAgcG9zID09PSAwICYmIHRoaXMuY29udGVudChuZXh0KSA9PT0gJ3wnXG5cdCAgICAgICAgICAvLyApIHtcblx0ICAgICAgICAgIC8vICAgICByZXR1cm4gdGhpcy5leHBlY3RlZCgnYXR0cmlidXRlJywgdG9rZW5bVE9LRU4uU1RBUlRfUE9TXSwgY29udGVudCk7XG5cdCAgICAgICAgICAvLyB9XG5cdCAgICAgICAgICBzcGFjZUFmdGVyTWVhbmluZ2Z1bFRva2VuID0gdHJ1ZTtcblxuXHQgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb3NzeSkge1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgaWYgKGxhc3RBZGRlZCkge1xuXHQgICAgICAgICAgICAoMCwgX3V0aWwuZW5zdXJlT2JqZWN0KShub2RlLCAnc3BhY2VzJywgbGFzdEFkZGVkKTtcblx0ICAgICAgICAgICAgdmFyIHByZXZDb250ZW50ID0gbm9kZS5zcGFjZXNbbGFzdEFkZGVkXS5hZnRlciB8fCAnJztcblx0ICAgICAgICAgICAgbm9kZS5zcGFjZXNbbGFzdEFkZGVkXS5hZnRlciA9IHByZXZDb250ZW50ICsgY29udGVudDtcblx0ICAgICAgICAgICAgdmFyIGV4aXN0aW5nQ29tbWVudCA9ICgwLCBfdXRpbC5nZXRQcm9wKShub2RlLCAncmF3cycsICdzcGFjZXMnLCBsYXN0QWRkZWQsICdhZnRlcicpIHx8IG51bGw7XG5cblx0ICAgICAgICAgICAgaWYgKGV4aXN0aW5nQ29tbWVudCkge1xuXHQgICAgICAgICAgICAgIG5vZGUucmF3cy5zcGFjZXNbbGFzdEFkZGVkXS5hZnRlciA9IGV4aXN0aW5nQ29tbWVudCArIGNvbnRlbnQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHNwYWNlQmVmb3JlID0gc3BhY2VCZWZvcmUgKyBjb250ZW50O1xuXHQgICAgICAgICAgICBjb21tZW50QmVmb3JlID0gY29tbWVudEJlZm9yZSArIGNvbnRlbnQ7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgY2FzZSB0b2tlbnMuYXN0ZXJpc2s6XG5cdCAgICAgICAgICBpZiAobmV4dFtfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMuZXF1YWxzKSB7XG5cdCAgICAgICAgICAgIG5vZGUub3BlcmF0b3IgPSBjb250ZW50O1xuXHQgICAgICAgICAgICBsYXN0QWRkZWQgPSAnb3BlcmF0b3InO1xuXHQgICAgICAgICAgfSBlbHNlIGlmICgoIW5vZGUubmFtZXNwYWNlIHx8IGxhc3RBZGRlZCA9PT0gXCJuYW1lc3BhY2VcIiAmJiAhc3BhY2VBZnRlck1lYW5pbmdmdWxUb2tlbikgJiYgbmV4dCkge1xuXHQgICAgICAgICAgICBpZiAoc3BhY2VCZWZvcmUpIHtcblx0ICAgICAgICAgICAgICAoMCwgX3V0aWwuZW5zdXJlT2JqZWN0KShub2RlLCAnc3BhY2VzJywgJ2F0dHJpYnV0ZScpO1xuXHQgICAgICAgICAgICAgIG5vZGUuc3BhY2VzLmF0dHJpYnV0ZS5iZWZvcmUgPSBzcGFjZUJlZm9yZTtcblx0ICAgICAgICAgICAgICBzcGFjZUJlZm9yZSA9ICcnO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKGNvbW1lbnRCZWZvcmUpIHtcblx0ICAgICAgICAgICAgICAoMCwgX3V0aWwuZW5zdXJlT2JqZWN0KShub2RlLCAncmF3cycsICdzcGFjZXMnLCAnYXR0cmlidXRlJyk7XG5cdCAgICAgICAgICAgICAgbm9kZS5yYXdzLnNwYWNlcy5hdHRyaWJ1dGUuYmVmb3JlID0gc3BhY2VCZWZvcmU7XG5cdCAgICAgICAgICAgICAgY29tbWVudEJlZm9yZSA9ICcnO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgbm9kZS5uYW1lc3BhY2UgPSAobm9kZS5uYW1lc3BhY2UgfHwgXCJcIikgKyBjb250ZW50O1xuXHQgICAgICAgICAgICB2YXIgcmF3VmFsdWUgPSAoMCwgX3V0aWwuZ2V0UHJvcCkobm9kZSwgJ3Jhd3MnLCAnbmFtZXNwYWNlJykgfHwgbnVsbDtcblxuXHQgICAgICAgICAgICBpZiAocmF3VmFsdWUpIHtcblx0ICAgICAgICAgICAgICBub2RlLnJhd3MubmFtZXNwYWNlICs9IGNvbnRlbnQ7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBsYXN0QWRkZWQgPSAnbmFtZXNwYWNlJztcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgc3BhY2VBZnRlck1lYW5pbmdmdWxUb2tlbiA9IGZhbHNlO1xuXHQgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICBjYXNlIHRva2Vucy5kb2xsYXI6XG5cdCAgICAgICAgICBpZiAobGFzdEFkZGVkID09PSBcInZhbHVlXCIpIHtcblx0ICAgICAgICAgICAgdmFyIG9sZFJhd1ZhbHVlID0gKDAsIF91dGlsLmdldFByb3ApKG5vZGUsICdyYXdzJywgJ3ZhbHVlJyk7XG5cdCAgICAgICAgICAgIG5vZGUudmFsdWUgKz0gXCIkXCI7XG5cblx0ICAgICAgICAgICAgaWYgKG9sZFJhd1ZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgbm9kZS5yYXdzLnZhbHVlID0gb2xkUmF3VmFsdWUgKyBcIiRcIjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gRmFsbHMgdGhyb3VnaFxuXG5cdCAgICAgICAgY2FzZSB0b2tlbnMuY2FyZXQ6XG5cdCAgICAgICAgICBpZiAobmV4dFtfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMuZXF1YWxzKSB7XG5cdCAgICAgICAgICAgIG5vZGUub3BlcmF0b3IgPSBjb250ZW50O1xuXHQgICAgICAgICAgICBsYXN0QWRkZWQgPSAnb3BlcmF0b3InO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBzcGFjZUFmdGVyTWVhbmluZ2Z1bFRva2VuID0gZmFsc2U7XG5cdCAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgIGNhc2UgdG9rZW5zLmNvbWJpbmF0b3I6XG5cdCAgICAgICAgICBpZiAoY29udGVudCA9PT0gJ34nICYmIG5leHRbX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLmVxdWFscykge1xuXHQgICAgICAgICAgICBub2RlLm9wZXJhdG9yID0gY29udGVudDtcblx0ICAgICAgICAgICAgbGFzdEFkZGVkID0gJ29wZXJhdG9yJztcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgaWYgKGNvbnRlbnQgIT09ICd8Jykge1xuXHQgICAgICAgICAgICBzcGFjZUFmdGVyTWVhbmluZ2Z1bFRva2VuID0gZmFsc2U7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBpZiAobmV4dFtfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMuZXF1YWxzKSB7XG5cdCAgICAgICAgICAgIG5vZGUub3BlcmF0b3IgPSBjb250ZW50O1xuXHQgICAgICAgICAgICBsYXN0QWRkZWQgPSAnb3BlcmF0b3InO1xuXHQgICAgICAgICAgfSBlbHNlIGlmICghbm9kZS5uYW1lc3BhY2UgJiYgIW5vZGUuYXR0cmlidXRlKSB7XG5cdCAgICAgICAgICAgIG5vZGUubmFtZXNwYWNlID0gdHJ1ZTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgc3BhY2VBZnRlck1lYW5pbmdmdWxUb2tlbiA9IGZhbHNlO1xuXHQgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICBjYXNlIHRva2Vucy53b3JkOlxuXHQgICAgICAgICAgaWYgKG5leHQgJiYgdGhpcy5jb250ZW50KG5leHQpID09PSAnfCcgJiYgYXR0cltwb3MgKyAyXSAmJiBhdHRyW3BvcyArIDJdW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gIT09IHRva2Vucy5lcXVhbHMgJiYgLy8gdGhpcyBsb29rLWFoZWFkIHByb2JhYmx5IGZhaWxzIHdpdGggY29tbWVudCBub2RlcyBpbnZvbHZlZC5cblx0ICAgICAgICAgICFub2RlLm9wZXJhdG9yICYmICFub2RlLm5hbWVzcGFjZSkge1xuXHQgICAgICAgICAgICBub2RlLm5hbWVzcGFjZSA9IGNvbnRlbnQ7XG5cdCAgICAgICAgICAgIGxhc3RBZGRlZCA9ICduYW1lc3BhY2UnO1xuXHQgICAgICAgICAgfSBlbHNlIGlmICghbm9kZS5hdHRyaWJ1dGUgfHwgbGFzdEFkZGVkID09PSBcImF0dHJpYnV0ZVwiICYmICFzcGFjZUFmdGVyTWVhbmluZ2Z1bFRva2VuKSB7XG5cdCAgICAgICAgICAgIGlmIChzcGFjZUJlZm9yZSkge1xuXHQgICAgICAgICAgICAgICgwLCBfdXRpbC5lbnN1cmVPYmplY3QpKG5vZGUsICdzcGFjZXMnLCAnYXR0cmlidXRlJyk7XG5cdCAgICAgICAgICAgICAgbm9kZS5zcGFjZXMuYXR0cmlidXRlLmJlZm9yZSA9IHNwYWNlQmVmb3JlO1xuXHQgICAgICAgICAgICAgIHNwYWNlQmVmb3JlID0gJyc7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoY29tbWVudEJlZm9yZSkge1xuXHQgICAgICAgICAgICAgICgwLCBfdXRpbC5lbnN1cmVPYmplY3QpKG5vZGUsICdyYXdzJywgJ3NwYWNlcycsICdhdHRyaWJ1dGUnKTtcblx0ICAgICAgICAgICAgICBub2RlLnJhd3Muc3BhY2VzLmF0dHJpYnV0ZS5iZWZvcmUgPSBjb21tZW50QmVmb3JlO1xuXHQgICAgICAgICAgICAgIGNvbW1lbnRCZWZvcmUgPSAnJztcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIG5vZGUuYXR0cmlidXRlID0gKG5vZGUuYXR0cmlidXRlIHx8IFwiXCIpICsgY29udGVudDtcblxuXHQgICAgICAgICAgICB2YXIgX3Jhd1ZhbHVlID0gKDAsIF91dGlsLmdldFByb3ApKG5vZGUsICdyYXdzJywgJ2F0dHJpYnV0ZScpIHx8IG51bGw7XG5cblx0ICAgICAgICAgICAgaWYgKF9yYXdWYWx1ZSkge1xuXHQgICAgICAgICAgICAgIG5vZGUucmF3cy5hdHRyaWJ1dGUgKz0gY29udGVudDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGxhc3RBZGRlZCA9ICdhdHRyaWJ1dGUnO1xuXHQgICAgICAgICAgfSBlbHNlIGlmICghbm9kZS52YWx1ZSAmJiBub2RlLnZhbHVlICE9PSBcIlwiIHx8IGxhc3RBZGRlZCA9PT0gXCJ2YWx1ZVwiICYmICFzcGFjZUFmdGVyTWVhbmluZ2Z1bFRva2VuKSB7XG5cdCAgICAgICAgICAgIHZhciBfdW5lc2NhcGVkID0gKDAsIF91dGlsLnVuZXNjKShjb250ZW50KTtcblxuXHQgICAgICAgICAgICB2YXIgX29sZFJhd1ZhbHVlID0gKDAsIF91dGlsLmdldFByb3ApKG5vZGUsICdyYXdzJywgJ3ZhbHVlJykgfHwgJyc7XG5cblx0ICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gbm9kZS52YWx1ZSB8fCAnJztcblx0ICAgICAgICAgICAgbm9kZS52YWx1ZSA9IG9sZFZhbHVlICsgX3VuZXNjYXBlZDtcblx0ICAgICAgICAgICAgbm9kZS5xdW90ZU1hcmsgPSBudWxsO1xuXG5cdCAgICAgICAgICAgIGlmIChfdW5lc2NhcGVkICE9PSBjb250ZW50IHx8IF9vbGRSYXdWYWx1ZSkge1xuXHQgICAgICAgICAgICAgICgwLCBfdXRpbC5lbnN1cmVPYmplY3QpKG5vZGUsICdyYXdzJyk7XG5cdCAgICAgICAgICAgICAgbm9kZS5yYXdzLnZhbHVlID0gKF9vbGRSYXdWYWx1ZSB8fCBvbGRWYWx1ZSkgKyBjb250ZW50O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgbGFzdEFkZGVkID0gJ3ZhbHVlJztcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBpbnNlbnNpdGl2ZSA9IGNvbnRlbnQgPT09ICdpJyB8fCBjb250ZW50ID09PSBcIklcIjtcblxuXHQgICAgICAgICAgICBpZiAoKG5vZGUudmFsdWUgfHwgbm9kZS52YWx1ZSA9PT0gJycpICYmIChub2RlLnF1b3RlTWFyayB8fCBzcGFjZUFmdGVyTWVhbmluZ2Z1bFRva2VuKSkge1xuXHQgICAgICAgICAgICAgIG5vZGUuaW5zZW5zaXRpdmUgPSBpbnNlbnNpdGl2ZTtcblxuXHQgICAgICAgICAgICAgIGlmICghaW5zZW5zaXRpdmUgfHwgY29udGVudCA9PT0gXCJJXCIpIHtcblx0ICAgICAgICAgICAgICAgICgwLCBfdXRpbC5lbnN1cmVPYmplY3QpKG5vZGUsICdyYXdzJyk7XG5cdCAgICAgICAgICAgICAgICBub2RlLnJhd3MuaW5zZW5zaXRpdmVGbGFnID0gY29udGVudDtcblx0ICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICBsYXN0QWRkZWQgPSAnaW5zZW5zaXRpdmUnO1xuXG5cdCAgICAgICAgICAgICAgaWYgKHNwYWNlQmVmb3JlKSB7XG5cdCAgICAgICAgICAgICAgICAoMCwgX3V0aWwuZW5zdXJlT2JqZWN0KShub2RlLCAnc3BhY2VzJywgJ2luc2Vuc2l0aXZlJyk7XG5cdCAgICAgICAgICAgICAgICBub2RlLnNwYWNlcy5pbnNlbnNpdGl2ZS5iZWZvcmUgPSBzcGFjZUJlZm9yZTtcblx0ICAgICAgICAgICAgICAgIHNwYWNlQmVmb3JlID0gJyc7XG5cdCAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgaWYgKGNvbW1lbnRCZWZvcmUpIHtcblx0ICAgICAgICAgICAgICAgICgwLCBfdXRpbC5lbnN1cmVPYmplY3QpKG5vZGUsICdyYXdzJywgJ3NwYWNlcycsICdpbnNlbnNpdGl2ZScpO1xuXHQgICAgICAgICAgICAgICAgbm9kZS5yYXdzLnNwYWNlcy5pbnNlbnNpdGl2ZS5iZWZvcmUgPSBjb21tZW50QmVmb3JlO1xuXHQgICAgICAgICAgICAgICAgY29tbWVudEJlZm9yZSA9ICcnO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLnZhbHVlIHx8IG5vZGUudmFsdWUgPT09ICcnKSB7XG5cdCAgICAgICAgICAgICAgbGFzdEFkZGVkID0gJ3ZhbHVlJztcblx0ICAgICAgICAgICAgICBub2RlLnZhbHVlICs9IGNvbnRlbnQ7XG5cblx0ICAgICAgICAgICAgICBpZiAobm9kZS5yYXdzLnZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICBub2RlLnJhd3MudmFsdWUgKz0gY29udGVudDtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgc3BhY2VBZnRlck1lYW5pbmdmdWxUb2tlbiA9IGZhbHNlO1xuXHQgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICBjYXNlIHRva2Vucy5zdHI6XG5cdCAgICAgICAgICBpZiAoIW5vZGUuYXR0cmlidXRlIHx8ICFub2RlLm9wZXJhdG9yKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKFwiRXhwZWN0ZWQgYW4gYXR0cmlidXRlIGZvbGxvd2VkIGJ5IGFuIG9wZXJhdG9yIHByZWNlZGluZyB0aGUgc3RyaW5nLlwiLCB7XG5cdCAgICAgICAgICAgICAgaW5kZXg6IHRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgdmFyIF91bmVzY2FwZVZhbHVlID0gKDAsIF9hdHRyaWJ1dGUudW5lc2NhcGVWYWx1ZSkoY29udGVudCksXG5cdCAgICAgICAgICAgICAgdW5lc2NhcGVkID0gX3VuZXNjYXBlVmFsdWUudW5lc2NhcGVkLFxuXHQgICAgICAgICAgICAgIHF1b3RlTWFyayA9IF91bmVzY2FwZVZhbHVlLnF1b3RlTWFyaztcblxuXHQgICAgICAgICAgbm9kZS52YWx1ZSA9IHVuZXNjYXBlZDtcblx0ICAgICAgICAgIG5vZGUucXVvdGVNYXJrID0gcXVvdGVNYXJrO1xuXHQgICAgICAgICAgbGFzdEFkZGVkID0gJ3ZhbHVlJztcblx0ICAgICAgICAgICgwLCBfdXRpbC5lbnN1cmVPYmplY3QpKG5vZGUsICdyYXdzJyk7XG5cdCAgICAgICAgICBub2RlLnJhd3MudmFsdWUgPSBjb250ZW50O1xuXHQgICAgICAgICAgc3BhY2VBZnRlck1lYW5pbmdmdWxUb2tlbiA9IGZhbHNlO1xuXHQgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICBjYXNlIHRva2Vucy5lcXVhbHM6XG5cdCAgICAgICAgICBpZiAoIW5vZGUuYXR0cmlidXRlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGVjdGVkKCdhdHRyaWJ1dGUnLCB0b2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU10sIGNvbnRlbnQpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBpZiAobm9kZS52YWx1ZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcignVW5leHBlY3RlZCBcIj1cIiBmb3VuZDsgYW4gb3BlcmF0b3Igd2FzIGFscmVhZHkgZGVmaW5lZC4nLCB7XG5cdCAgICAgICAgICAgICAgaW5kZXg6IHRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgbm9kZS5vcGVyYXRvciA9IG5vZGUub3BlcmF0b3IgPyBub2RlLm9wZXJhdG9yICsgY29udGVudCA6IGNvbnRlbnQ7XG5cdCAgICAgICAgICBsYXN0QWRkZWQgPSAnb3BlcmF0b3InO1xuXHQgICAgICAgICAgc3BhY2VBZnRlck1lYW5pbmdmdWxUb2tlbiA9IGZhbHNlO1xuXHQgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICBjYXNlIHRva2Vucy5jb21tZW50OlxuXHQgICAgICAgICAgaWYgKGxhc3RBZGRlZCkge1xuXHQgICAgICAgICAgICBpZiAoc3BhY2VBZnRlck1lYW5pbmdmdWxUb2tlbiB8fCBuZXh0ICYmIG5leHRbX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLnNwYWNlIHx8IGxhc3RBZGRlZCA9PT0gJ2luc2Vuc2l0aXZlJykge1xuXHQgICAgICAgICAgICAgIHZhciBsYXN0Q29tbWVudCA9ICgwLCBfdXRpbC5nZXRQcm9wKShub2RlLCAnc3BhY2VzJywgbGFzdEFkZGVkLCAnYWZ0ZXInKSB8fCAnJztcblx0ICAgICAgICAgICAgICB2YXIgcmF3TGFzdENvbW1lbnQgPSAoMCwgX3V0aWwuZ2V0UHJvcCkobm9kZSwgJ3Jhd3MnLCAnc3BhY2VzJywgbGFzdEFkZGVkLCAnYWZ0ZXInKSB8fCBsYXN0Q29tbWVudDtcblx0ICAgICAgICAgICAgICAoMCwgX3V0aWwuZW5zdXJlT2JqZWN0KShub2RlLCAncmF3cycsICdzcGFjZXMnLCBsYXN0QWRkZWQpO1xuXHQgICAgICAgICAgICAgIG5vZGUucmF3cy5zcGFjZXNbbGFzdEFkZGVkXS5hZnRlciA9IHJhd0xhc3RDb21tZW50ICsgY29udGVudDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICB2YXIgbGFzdFZhbHVlID0gbm9kZVtsYXN0QWRkZWRdIHx8ICcnO1xuXHQgICAgICAgICAgICAgIHZhciByYXdMYXN0VmFsdWUgPSAoMCwgX3V0aWwuZ2V0UHJvcCkobm9kZSwgJ3Jhd3MnLCBsYXN0QWRkZWQpIHx8IGxhc3RWYWx1ZTtcblx0ICAgICAgICAgICAgICAoMCwgX3V0aWwuZW5zdXJlT2JqZWN0KShub2RlLCAncmF3cycpO1xuXHQgICAgICAgICAgICAgIG5vZGUucmF3c1tsYXN0QWRkZWRdID0gcmF3TGFzdFZhbHVlICsgY29udGVudDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgY29tbWVudEJlZm9yZSA9IGNvbW1lbnRCZWZvcmUgKyBjb250ZW50O1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgXFxcIlwiICsgY29udGVudCArIFwiXFxcIiBmb3VuZC5cIiwge1xuXHQgICAgICAgICAgICBpbmRleDogdG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdXG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHBvcysrO1xuXHQgICAgfVxuXG5cdCAgICB1bmVzY2FwZVByb3Aobm9kZSwgXCJhdHRyaWJ1dGVcIik7XG5cdCAgICB1bmVzY2FwZVByb3Aobm9kZSwgXCJuYW1lc3BhY2VcIik7XG5cdCAgICB0aGlzLm5ld05vZGUobmV3IF9hdHRyaWJ1dGVbXCJkZWZhdWx0XCJdKG5vZGUpKTtcblx0ICAgIHRoaXMucG9zaXRpb24rKztcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogcmV0dXJuIGEgbm9kZSBjb250YWluaW5nIG1lYW5pbmdsZXNzIGdhcmJhZ2UgdXAgdG8gKGJ1dCBub3QgaW5jbHVkaW5nKSB0aGUgc3BlY2lmaWVkIHRva2VuIHBvc2l0aW9uLlxuXHQgICAqIGlmIHRoZSB0b2tlbiBwb3NpdGlvbiBpcyBuZWdhdGl2ZSwgYWxsIHJlbWFpbmluZyB0b2tlbnMgYXJlIGNvbnN1bWVkLlxuXHQgICAqXG5cdCAgICogVGhpcyByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgYSBzaW5nbGUgc3RyaW5nIG5vZGUgaWYgYWxsIHdoaXRlc3BhY2UsXG5cdCAgICogb3RoZXJ3aXNlIGFuIGFycmF5IG9mIGNvbW1lbnQgbm9kZXMgd2l0aCBzcGFjZSBiZWZvcmUgYW5kIGFmdGVyLlxuXHQgICAqXG5cdCAgICogVGhlc2UgdG9rZW5zIGFyZSBub3QgYWRkZWQgdG8gdGhlIGN1cnJlbnQgc2VsZWN0b3IsIHRoZSBjYWxsZXIgY2FuIGFkZCB0aGVtIG9yIHVzZSB0aGVtIHRvIGFtZW5kXG5cdCAgICogYSBwcmV2aW91cyBub2RlJ3Mgc3BhY2UgbWV0YWRhdGEuXG5cdCAgICpcblx0ICAgKiBJbiBsb3NzeSBtb2RlLCB0aGlzIHJldHVybnMgb25seSBjb21tZW50cy5cblx0ICAgKi9cblx0ICA7XG5cblx0ICBfcHJvdG8ucGFyc2VXaGl0ZXNwYWNlRXF1aXZhbGVudFRva2VucyA9IGZ1bmN0aW9uIHBhcnNlV2hpdGVzcGFjZUVxdWl2YWxlbnRUb2tlbnMoc3RvcFBvc2l0aW9uKSB7XG5cdCAgICBpZiAoc3RvcFBvc2l0aW9uIDwgMCkge1xuXHQgICAgICBzdG9wUG9zaXRpb24gPSB0aGlzLnRva2Vucy5sZW5ndGg7XG5cdCAgICB9XG5cblx0ICAgIHZhciBzdGFydFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcblx0ICAgIHZhciBub2RlcyA9IFtdO1xuXHQgICAgdmFyIHNwYWNlID0gXCJcIjtcblx0ICAgIHZhciBsYXN0Q29tbWVudCA9IHVuZGVmaW5lZDtcblxuXHQgICAgZG8ge1xuXHQgICAgICBpZiAoV0hJVEVTUEFDRV9UT0tFTlNbdGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXV0pIHtcblx0ICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5sb3NzeSkge1xuXHQgICAgICAgICAgc3BhY2UgKz0gdGhpcy5jb250ZW50KCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2UgaWYgKHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5jb21tZW50KSB7XG5cdCAgICAgICAgdmFyIHNwYWNlcyA9IHt9O1xuXG5cdCAgICAgICAgaWYgKHNwYWNlKSB7XG5cdCAgICAgICAgICBzcGFjZXMuYmVmb3JlID0gc3BhY2U7XG5cdCAgICAgICAgICBzcGFjZSA9IFwiXCI7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgbGFzdENvbW1lbnQgPSBuZXcgX2NvbW1lbnRbXCJkZWZhdWx0XCJdKHtcblx0ICAgICAgICAgIHZhbHVlOiB0aGlzLmNvbnRlbnQoKSxcblx0ICAgICAgICAgIHNvdXJjZTogZ2V0VG9rZW5Tb3VyY2UodGhpcy5jdXJyVG9rZW4pLFxuXHQgICAgICAgICAgc291cmNlSW5kZXg6IHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXSxcblx0ICAgICAgICAgIHNwYWNlczogc3BhY2VzXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgbm9kZXMucHVzaChsYXN0Q29tbWVudCk7XG5cdCAgICAgIH1cblx0ICAgIH0gd2hpbGUgKCsrdGhpcy5wb3NpdGlvbiA8IHN0b3BQb3NpdGlvbik7XG5cblx0ICAgIGlmIChzcGFjZSkge1xuXHQgICAgICBpZiAobGFzdENvbW1lbnQpIHtcblx0ICAgICAgICBsYXN0Q29tbWVudC5zcGFjZXMuYWZ0ZXIgPSBzcGFjZTtcblx0ICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLmxvc3N5KSB7XG5cdCAgICAgICAgdmFyIGZpcnN0VG9rZW4gPSB0aGlzLnRva2Vuc1tzdGFydFBvc2l0aW9uXTtcblx0ICAgICAgICB2YXIgbGFzdFRva2VuID0gdGhpcy50b2tlbnNbdGhpcy5wb3NpdGlvbiAtIDFdO1xuXHQgICAgICAgIG5vZGVzLnB1c2gobmV3IF9zdHJpbmdbXCJkZWZhdWx0XCJdKHtcblx0ICAgICAgICAgIHZhbHVlOiAnJyxcblx0ICAgICAgICAgIHNvdXJjZTogZ2V0U291cmNlKGZpcnN0VG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9MSU5FXSwgZmlyc3RUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX0NPTF0sIGxhc3RUb2tlbltfdG9rZW5pemUuRklFTERTLkVORF9MSU5FXSwgbGFzdFRva2VuW190b2tlbml6ZS5GSUVMRFMuRU5EX0NPTF0pLFxuXHQgICAgICAgICAgc291cmNlSW5kZXg6IGZpcnN0VG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdLFxuXHQgICAgICAgICAgc3BhY2VzOiB7XG5cdCAgICAgICAgICAgIGJlZm9yZTogc3BhY2UsXG5cdCAgICAgICAgICAgIGFmdGVyOiAnJ1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbm9kZXM7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFxuXHQgICAqIEBwYXJhbSB7Kn0gbm9kZXMgXG5cdCAgICovXG5cdCAgO1xuXG5cdCAgX3Byb3RvLmNvbnZlcnRXaGl0ZXNwYWNlTm9kZXNUb1NwYWNlID0gZnVuY3Rpb24gY29udmVydFdoaXRlc3BhY2VOb2Rlc1RvU3BhY2Uobm9kZXMsIHJlcXVpcmVkU3BhY2UpIHtcblx0ICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG5cdCAgICBpZiAocmVxdWlyZWRTcGFjZSA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIHJlcXVpcmVkU3BhY2UgPSBmYWxzZTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHNwYWNlID0gXCJcIjtcblx0ICAgIHZhciByYXdTcGFjZSA9IFwiXCI7XG5cdCAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG5cdCAgICAgIHZhciBzcGFjZUJlZm9yZSA9IF90aGlzMi5sb3NzeVNwYWNlKG4uc3BhY2VzLmJlZm9yZSwgcmVxdWlyZWRTcGFjZSk7XG5cblx0ICAgICAgdmFyIHJhd1NwYWNlQmVmb3JlID0gX3RoaXMyLmxvc3N5U3BhY2Uobi5yYXdTcGFjZUJlZm9yZSwgcmVxdWlyZWRTcGFjZSk7XG5cblx0ICAgICAgc3BhY2UgKz0gc3BhY2VCZWZvcmUgKyBfdGhpczIubG9zc3lTcGFjZShuLnNwYWNlcy5hZnRlciwgcmVxdWlyZWRTcGFjZSAmJiBzcGFjZUJlZm9yZS5sZW5ndGggPT09IDApO1xuXHQgICAgICByYXdTcGFjZSArPSBzcGFjZUJlZm9yZSArIG4udmFsdWUgKyBfdGhpczIubG9zc3lTcGFjZShuLnJhd1NwYWNlQWZ0ZXIsIHJlcXVpcmVkU3BhY2UgJiYgcmF3U3BhY2VCZWZvcmUubGVuZ3RoID09PSAwKTtcblx0ICAgIH0pO1xuXG5cdCAgICBpZiAocmF3U3BhY2UgPT09IHNwYWNlKSB7XG5cdCAgICAgIHJhd1NwYWNlID0gdW5kZWZpbmVkO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgcmVzdWx0ID0ge1xuXHQgICAgICBzcGFjZTogc3BhY2UsXG5cdCAgICAgIHJhd1NwYWNlOiByYXdTcGFjZVxuXHQgICAgfTtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfTtcblxuXHQgIF9wcm90by5pc05hbWVkQ29tYmluYXRvciA9IGZ1bmN0aW9uIGlzTmFtZWRDb21iaW5hdG9yKHBvc2l0aW9uKSB7XG5cdCAgICBpZiAocG9zaXRpb24gPT09IHZvaWQgMCkge1xuXHQgICAgICBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLnRva2Vuc1twb3NpdGlvbiArIDBdICYmIHRoaXMudG9rZW5zW3Bvc2l0aW9uICsgMF1bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLnNsYXNoICYmIHRoaXMudG9rZW5zW3Bvc2l0aW9uICsgMV0gJiYgdGhpcy50b2tlbnNbcG9zaXRpb24gKyAxXVtfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMud29yZCAmJiB0aGlzLnRva2Vuc1twb3NpdGlvbiArIDJdICYmIHRoaXMudG9rZW5zW3Bvc2l0aW9uICsgMl1bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLnNsYXNoO1xuXHQgIH07XG5cblx0ICBfcHJvdG8ubmFtZWRDb21iaW5hdG9yID0gZnVuY3Rpb24gbmFtZWRDb21iaW5hdG9yKCkge1xuXHQgICAgaWYgKHRoaXMuaXNOYW1lZENvbWJpbmF0b3IoKSkge1xuXHQgICAgICB2YXIgbmFtZVJhdyA9IHRoaXMuY29udGVudCh0aGlzLnRva2Vuc1t0aGlzLnBvc2l0aW9uICsgMV0pO1xuXHQgICAgICB2YXIgbmFtZSA9ICgwLCBfdXRpbC51bmVzYykobmFtZVJhdykudG9Mb3dlckNhc2UoKTtcblx0ICAgICAgdmFyIHJhd3MgPSB7fTtcblxuXHQgICAgICBpZiAobmFtZSAhPT0gbmFtZVJhdykge1xuXHQgICAgICAgIHJhd3MudmFsdWUgPSBcIi9cIiArIG5hbWVSYXcgKyBcIi9cIjtcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBub2RlID0gbmV3IF9jb21iaW5hdG9yW1wiZGVmYXVsdFwiXSh7XG5cdCAgICAgICAgdmFsdWU6IFwiL1wiICsgbmFtZSArIFwiL1wiLFxuXHQgICAgICAgIHNvdXJjZTogZ2V0U291cmNlKHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfTElORV0sIHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfQ09MXSwgdGhpcy50b2tlbnNbdGhpcy5wb3NpdGlvbiArIDJdW190b2tlbml6ZS5GSUVMRFMuRU5EX0xJTkVdLCB0aGlzLnRva2Vuc1t0aGlzLnBvc2l0aW9uICsgMl1bX3Rva2VuaXplLkZJRUxEUy5FTkRfQ09MXSksXG5cdCAgICAgICAgc291cmNlSW5kZXg6IHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXSxcblx0ICAgICAgICByYXdzOiByYXdzXG5cdCAgICAgIH0pO1xuXHQgICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbiArIDM7XG5cdCAgICAgIHJldHVybiBub2RlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIF9wcm90by5jb21iaW5hdG9yID0gZnVuY3Rpb24gY29tYmluYXRvcigpIHtcblx0ICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG5cdCAgICBpZiAodGhpcy5jb250ZW50KCkgPT09ICd8Jykge1xuXHQgICAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2UoKTtcblx0ICAgIH0gLy8gV2UgbmVlZCB0byBkZWNpZGUgYmV0d2VlbiBhIHNwYWNlIHRoYXQncyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciBhbmQgbWVhbmluZ2xlc3Mgd2hpdGVzcGFjZSBhdCB0aGUgZW5kIG9mIGEgc2VsZWN0b3IuXG5cblxuXHQgICAgdmFyIG5leHRTaWdUb2tlblBvcyA9IHRoaXMubG9jYXRlTmV4dE1lYW5pbmdmdWxUb2tlbih0aGlzLnBvc2l0aW9uKTtcblxuXHQgICAgaWYgKG5leHRTaWdUb2tlblBvcyA8IDAgfHwgdGhpcy50b2tlbnNbbmV4dFNpZ1Rva2VuUG9zXVtfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMuY29tbWEpIHtcblx0ICAgICAgdmFyIG5vZGVzID0gdGhpcy5wYXJzZVdoaXRlc3BhY2VFcXVpdmFsZW50VG9rZW5zKG5leHRTaWdUb2tlblBvcyk7XG5cblx0ICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICB2YXIgbGFzdCA9IHRoaXMuY3VycmVudC5sYXN0O1xuXG5cdCAgICAgICAgaWYgKGxhc3QpIHtcblx0ICAgICAgICAgIHZhciBfdGhpcyRjb252ZXJ0V2hpdGVzcGEgPSB0aGlzLmNvbnZlcnRXaGl0ZXNwYWNlTm9kZXNUb1NwYWNlKG5vZGVzKSxcblx0ICAgICAgICAgICAgICBzcGFjZSA9IF90aGlzJGNvbnZlcnRXaGl0ZXNwYS5zcGFjZSxcblx0ICAgICAgICAgICAgICByYXdTcGFjZSA9IF90aGlzJGNvbnZlcnRXaGl0ZXNwYS5yYXdTcGFjZTtcblxuXHQgICAgICAgICAgaWYgKHJhd1NwYWNlICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgbGFzdC5yYXdTcGFjZUFmdGVyICs9IHJhd1NwYWNlO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBsYXN0LnNwYWNlcy5hZnRlciArPSBzcGFjZTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobikge1xuXHQgICAgICAgICAgICByZXR1cm4gX3RoaXMzLm5ld05vZGUobik7XG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIHZhciBmaXJzdFRva2VuID0gdGhpcy5jdXJyVG9rZW47XG5cdCAgICB2YXIgc3BhY2VPckRlc2NlbmRhbnRTZWxlY3Rvck5vZGVzID0gdW5kZWZpbmVkO1xuXG5cdCAgICBpZiAobmV4dFNpZ1Rva2VuUG9zID4gdGhpcy5wb3NpdGlvbikge1xuXHQgICAgICBzcGFjZU9yRGVzY2VuZGFudFNlbGVjdG9yTm9kZXMgPSB0aGlzLnBhcnNlV2hpdGVzcGFjZUVxdWl2YWxlbnRUb2tlbnMobmV4dFNpZ1Rva2VuUG9zKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIG5vZGU7XG5cblx0ICAgIGlmICh0aGlzLmlzTmFtZWRDb21iaW5hdG9yKCkpIHtcblx0ICAgICAgbm9kZSA9IHRoaXMubmFtZWRDb21iaW5hdG9yKCk7XG5cdCAgICB9IGVsc2UgaWYgKHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5jb21iaW5hdG9yKSB7XG5cdCAgICAgIG5vZGUgPSBuZXcgX2NvbWJpbmF0b3JbXCJkZWZhdWx0XCJdKHtcblx0ICAgICAgICB2YWx1ZTogdGhpcy5jb250ZW50KCksXG5cdCAgICAgICAgc291cmNlOiBnZXRUb2tlblNvdXJjZSh0aGlzLmN1cnJUb2tlbiksXG5cdCAgICAgICAgc291cmNlSW5kZXg6IHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXVxuXHQgICAgICB9KTtcblx0ICAgICAgdGhpcy5wb3NpdGlvbisrO1xuXHQgICAgfSBlbHNlIGlmIChXSElURVNQQUNFX1RPS0VOU1t0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdXSkgOyBlbHNlIGlmICghc3BhY2VPckRlc2NlbmRhbnRTZWxlY3Rvck5vZGVzKSB7XG5cdCAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAobm9kZSkge1xuXHQgICAgICBpZiAoc3BhY2VPckRlc2NlbmRhbnRTZWxlY3Rvck5vZGVzKSB7XG5cdCAgICAgICAgdmFyIF90aGlzJGNvbnZlcnRXaGl0ZXNwYTIgPSB0aGlzLmNvbnZlcnRXaGl0ZXNwYWNlTm9kZXNUb1NwYWNlKHNwYWNlT3JEZXNjZW5kYW50U2VsZWN0b3JOb2RlcyksXG5cdCAgICAgICAgICAgIF9zcGFjZSA9IF90aGlzJGNvbnZlcnRXaGl0ZXNwYTIuc3BhY2UsXG5cdCAgICAgICAgICAgIF9yYXdTcGFjZSA9IF90aGlzJGNvbnZlcnRXaGl0ZXNwYTIucmF3U3BhY2U7XG5cblx0ICAgICAgICBub2RlLnNwYWNlcy5iZWZvcmUgPSBfc3BhY2U7XG5cdCAgICAgICAgbm9kZS5yYXdTcGFjZUJlZm9yZSA9IF9yYXdTcGFjZTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gZGVzY2VuZGFudCBjb21iaW5hdG9yXG5cdCAgICAgIHZhciBfdGhpcyRjb252ZXJ0V2hpdGVzcGEzID0gdGhpcy5jb252ZXJ0V2hpdGVzcGFjZU5vZGVzVG9TcGFjZShzcGFjZU9yRGVzY2VuZGFudFNlbGVjdG9yTm9kZXMsIHRydWUpLFxuXHQgICAgICAgICAgX3NwYWNlMiA9IF90aGlzJGNvbnZlcnRXaGl0ZXNwYTMuc3BhY2UsXG5cdCAgICAgICAgICBfcmF3U3BhY2UyID0gX3RoaXMkY29udmVydFdoaXRlc3BhMy5yYXdTcGFjZTtcblxuXHQgICAgICBpZiAoIV9yYXdTcGFjZTIpIHtcblx0ICAgICAgICBfcmF3U3BhY2UyID0gX3NwYWNlMjtcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBzcGFjZXMgPSB7fTtcblx0ICAgICAgdmFyIHJhd3MgPSB7XG5cdCAgICAgICAgc3BhY2VzOiB7fVxuXHQgICAgICB9O1xuXG5cdCAgICAgIGlmIChfc3BhY2UyLmVuZHNXaXRoKCcgJykgJiYgX3Jhd1NwYWNlMi5lbmRzV2l0aCgnICcpKSB7XG5cdCAgICAgICAgc3BhY2VzLmJlZm9yZSA9IF9zcGFjZTIuc2xpY2UoMCwgX3NwYWNlMi5sZW5ndGggLSAxKTtcblx0ICAgICAgICByYXdzLnNwYWNlcy5iZWZvcmUgPSBfcmF3U3BhY2UyLnNsaWNlKDAsIF9yYXdTcGFjZTIubGVuZ3RoIC0gMSk7XG5cdCAgICAgIH0gZWxzZSBpZiAoX3NwYWNlMi5zdGFydHNXaXRoKCcgJykgJiYgX3Jhd1NwYWNlMi5zdGFydHNXaXRoKCcgJykpIHtcblx0ICAgICAgICBzcGFjZXMuYWZ0ZXIgPSBfc3BhY2UyLnNsaWNlKDEpO1xuXHQgICAgICAgIHJhd3Muc3BhY2VzLmFmdGVyID0gX3Jhd1NwYWNlMi5zbGljZSgxKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByYXdzLnZhbHVlID0gX3Jhd1NwYWNlMjtcblx0ICAgICAgfVxuXG5cdCAgICAgIG5vZGUgPSBuZXcgX2NvbWJpbmF0b3JbXCJkZWZhdWx0XCJdKHtcblx0ICAgICAgICB2YWx1ZTogJyAnLFxuXHQgICAgICAgIHNvdXJjZTogZ2V0VG9rZW5Tb3VyY2VTcGFuKGZpcnN0VG9rZW4sIHRoaXMudG9rZW5zW3RoaXMucG9zaXRpb24gLSAxXSksXG5cdCAgICAgICAgc291cmNlSW5kZXg6IGZpcnN0VG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdLFxuXHQgICAgICAgIHNwYWNlczogc3BhY2VzLFxuXHQgICAgICAgIHJhd3M6IHJhd3Ncblx0ICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLmN1cnJUb2tlbiAmJiB0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMuc3BhY2UpIHtcblx0ICAgICAgbm9kZS5zcGFjZXMuYWZ0ZXIgPSB0aGlzLm9wdGlvbmFsU3BhY2UodGhpcy5jb250ZW50KCkpO1xuXHQgICAgICB0aGlzLnBvc2l0aW9uKys7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLm5ld05vZGUobm9kZSk7XG5cdCAgfTtcblxuXHQgIF9wcm90by5jb21tYSA9IGZ1bmN0aW9uIGNvbW1hKCkge1xuXHQgICAgaWYgKHRoaXMucG9zaXRpb24gPT09IHRoaXMudG9rZW5zLmxlbmd0aCAtIDEpIHtcblx0ICAgICAgdGhpcy5yb290LnRyYWlsaW5nQ29tbWEgPSB0cnVlO1xuXHQgICAgICB0aGlzLnBvc2l0aW9uKys7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5jdXJyZW50Ll9pbmZlckVuZFBvc2l0aW9uKCk7XG5cblx0ICAgIHZhciBzZWxlY3RvciA9IG5ldyBfc2VsZWN0b3JbXCJkZWZhdWx0XCJdKHtcblx0ICAgICAgc291cmNlOiB7XG5cdCAgICAgICAgc3RhcnQ6IHRva2VuU3RhcnQodGhpcy50b2tlbnNbdGhpcy5wb3NpdGlvbiArIDFdKVxuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIHRoaXMuY3VycmVudC5wYXJlbnQuYXBwZW5kKHNlbGVjdG9yKTtcblx0ICAgIHRoaXMuY3VycmVudCA9IHNlbGVjdG9yO1xuXHQgICAgdGhpcy5wb3NpdGlvbisrO1xuXHQgIH07XG5cblx0ICBfcHJvdG8uY29tbWVudCA9IGZ1bmN0aW9uIGNvbW1lbnQoKSB7XG5cdCAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VyclRva2VuO1xuXHQgICAgdGhpcy5uZXdOb2RlKG5ldyBfY29tbWVudFtcImRlZmF1bHRcIl0oe1xuXHQgICAgICB2YWx1ZTogdGhpcy5jb250ZW50KCksXG5cdCAgICAgIHNvdXJjZTogZ2V0VG9rZW5Tb3VyY2UoY3VycmVudCksXG5cdCAgICAgIHNvdXJjZUluZGV4OiBjdXJyZW50W190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXVxuXHQgICAgfSkpO1xuXHQgICAgdGhpcy5wb3NpdGlvbisrO1xuXHQgIH07XG5cblx0ICBfcHJvdG8uZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihtZXNzYWdlLCBvcHRzKSB7XG5cdCAgICB0aHJvdyB0aGlzLnJvb3QuZXJyb3IobWVzc2FnZSwgb3B0cyk7XG5cdCAgfTtcblxuXHQgIF9wcm90by5taXNzaW5nQmFja3NsYXNoID0gZnVuY3Rpb24gbWlzc2luZ0JhY2tzbGFzaCgpIHtcblx0ICAgIHJldHVybiB0aGlzLmVycm9yKCdFeHBlY3RlZCBhIGJhY2tzbGFzaCBwcmVjZWRpbmcgdGhlIHNlbWljb2xvbi4nLCB7XG5cdCAgICAgIGluZGV4OiB0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU11cblx0ICAgIH0pO1xuXHQgIH07XG5cblx0ICBfcHJvdG8ubWlzc2luZ1BhcmVudGhlc2lzID0gZnVuY3Rpb24gbWlzc2luZ1BhcmVudGhlc2lzKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuZXhwZWN0ZWQoJ29wZW5pbmcgcGFyZW50aGVzaXMnLCB0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU10pO1xuXHQgIH07XG5cblx0ICBfcHJvdG8ubWlzc2luZ1NxdWFyZUJyYWNrZXQgPSBmdW5jdGlvbiBtaXNzaW5nU3F1YXJlQnJhY2tldCgpIHtcblx0ICAgIHJldHVybiB0aGlzLmV4cGVjdGVkKCdvcGVuaW5nIHNxdWFyZSBicmFja2V0JywgdGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdKTtcblx0ICB9O1xuXG5cdCAgX3Byb3RvLnVuZXhwZWN0ZWQgPSBmdW5jdGlvbiB1bmV4cGVjdGVkKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkICdcIiArIHRoaXMuY29udGVudCgpICsgXCInLiBFc2NhcGluZyBzcGVjaWFsIGNoYXJhY3RlcnMgd2l0aCBcXFxcIG1heSBoZWxwLlwiLCB0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU10pO1xuXHQgIH07XG5cblx0ICBfcHJvdG8ubmFtZXNwYWNlID0gZnVuY3Rpb24gbmFtZXNwYWNlKCkge1xuXHQgICAgdmFyIGJlZm9yZSA9IHRoaXMucHJldlRva2VuICYmIHRoaXMuY29udGVudCh0aGlzLnByZXZUb2tlbikgfHwgdHJ1ZTtcblxuXHQgICAgaWYgKHRoaXMubmV4dFRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy53b3JkKSB7XG5cdCAgICAgIHRoaXMucG9zaXRpb24rKztcblx0ICAgICAgcmV0dXJuIHRoaXMud29yZChiZWZvcmUpO1xuXHQgICAgfSBlbHNlIGlmICh0aGlzLm5leHRUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMuYXN0ZXJpc2spIHtcblx0ICAgICAgdGhpcy5wb3NpdGlvbisrO1xuXHQgICAgICByZXR1cm4gdGhpcy51bml2ZXJzYWwoYmVmb3JlKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgX3Byb3RvLm5lc3RpbmcgPSBmdW5jdGlvbiBuZXN0aW5nKCkge1xuXHQgICAgaWYgKHRoaXMubmV4dFRva2VuKSB7XG5cdCAgICAgIHZhciBuZXh0Q29udGVudCA9IHRoaXMuY29udGVudCh0aGlzLm5leHRUb2tlbik7XG5cblx0ICAgICAgaWYgKG5leHRDb250ZW50ID09PSBcInxcIikge1xuXHQgICAgICAgIHRoaXMucG9zaXRpb24rKztcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJUb2tlbjtcblx0ICAgIHRoaXMubmV3Tm9kZShuZXcgX25lc3RpbmdbXCJkZWZhdWx0XCJdKHtcblx0ICAgICAgdmFsdWU6IHRoaXMuY29udGVudCgpLFxuXHQgICAgICBzb3VyY2U6IGdldFRva2VuU291cmNlKGN1cnJlbnQpLFxuXHQgICAgICBzb3VyY2VJbmRleDogY3VycmVudFtfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU11cblx0ICAgIH0pKTtcblx0ICAgIHRoaXMucG9zaXRpb24rKztcblx0ICB9O1xuXG5cdCAgX3Byb3RvLnBhcmVudGhlc2VzID0gZnVuY3Rpb24gcGFyZW50aGVzZXMoKSB7XG5cdCAgICB2YXIgbGFzdCA9IHRoaXMuY3VycmVudC5sYXN0O1xuXHQgICAgdmFyIHVuYmFsYW5jZWQgPSAxO1xuXHQgICAgdGhpcy5wb3NpdGlvbisrO1xuXG5cdCAgICBpZiAobGFzdCAmJiBsYXN0LnR5cGUgPT09IHR5cGVzJDEuUFNFVURPKSB7XG5cdCAgICAgIHZhciBzZWxlY3RvciA9IG5ldyBfc2VsZWN0b3JbXCJkZWZhdWx0XCJdKHtcblx0ICAgICAgICBzb3VyY2U6IHtcblx0ICAgICAgICAgIHN0YXJ0OiB0b2tlblN0YXJ0KHRoaXMudG9rZW5zW3RoaXMucG9zaXRpb24gLSAxXSlcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgICB2YXIgY2FjaGUgPSB0aGlzLmN1cnJlbnQ7XG5cdCAgICAgIGxhc3QuYXBwZW5kKHNlbGVjdG9yKTtcblx0ICAgICAgdGhpcy5jdXJyZW50ID0gc2VsZWN0b3I7XG5cblx0ICAgICAgd2hpbGUgKHRoaXMucG9zaXRpb24gPCB0aGlzLnRva2Vucy5sZW5ndGggJiYgdW5iYWxhbmNlZCkge1xuXHQgICAgICAgIGlmICh0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMub3BlblBhcmVudGhlc2lzKSB7XG5cdCAgICAgICAgICB1bmJhbGFuY2VkKys7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5jbG9zZVBhcmVudGhlc2lzKSB7XG5cdCAgICAgICAgICB1bmJhbGFuY2VkLS07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHVuYmFsYW5jZWQpIHtcblx0ICAgICAgICAgIHRoaXMucGFyc2UoKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgdGhpcy5jdXJyZW50LnNvdXJjZS5lbmQgPSB0b2tlbkVuZCh0aGlzLmN1cnJUb2tlbik7XG5cdCAgICAgICAgICB0aGlzLmN1cnJlbnQucGFyZW50LnNvdXJjZS5lbmQgPSB0b2tlbkVuZCh0aGlzLmN1cnJUb2tlbik7XG5cdCAgICAgICAgICB0aGlzLnBvc2l0aW9uKys7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5jdXJyZW50ID0gY2FjaGU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyBJIHRoaW5rIHRoaXMgY2FzZSBzaG91bGQgYmUgYW4gZXJyb3IuIEl0J3MgdXNlZCB0byBpbXBsZW1lbnQgYSBiYXNpYyBwYXJzZSBvZiBtZWRpYSBxdWVyaWVzXG5cdCAgICAgIC8vIGJ1dCBJIGRvbid0IHRoaW5rIGl0J3MgYSBnb29kIGlkZWEuXG5cdCAgICAgIHZhciBwYXJlblN0YXJ0ID0gdGhpcy5jdXJyVG9rZW47XG5cdCAgICAgIHZhciBwYXJlblZhbHVlID0gXCIoXCI7XG5cdCAgICAgIHZhciBwYXJlbkVuZDtcblxuXHQgICAgICB3aGlsZSAodGhpcy5wb3NpdGlvbiA8IHRoaXMudG9rZW5zLmxlbmd0aCAmJiB1bmJhbGFuY2VkKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5vcGVuUGFyZW50aGVzaXMpIHtcblx0ICAgICAgICAgIHVuYmFsYW5jZWQrKztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAodGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLmNsb3NlUGFyZW50aGVzaXMpIHtcblx0ICAgICAgICAgIHVuYmFsYW5jZWQtLTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBwYXJlbkVuZCA9IHRoaXMuY3VyclRva2VuO1xuXHQgICAgICAgIHBhcmVuVmFsdWUgKz0gdGhpcy5wYXJzZVBhcmVudGhlc2lzVG9rZW4odGhpcy5jdXJyVG9rZW4pO1xuXHQgICAgICAgIHRoaXMucG9zaXRpb24rKztcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChsYXN0KSB7XG5cdCAgICAgICAgbGFzdC5hcHBlbmRUb1Byb3BlcnR5QW5kRXNjYXBlKFwidmFsdWVcIiwgcGFyZW5WYWx1ZSwgcGFyZW5WYWx1ZSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy5uZXdOb2RlKG5ldyBfc3RyaW5nW1wiZGVmYXVsdFwiXSh7XG5cdCAgICAgICAgICB2YWx1ZTogcGFyZW5WYWx1ZSxcblx0ICAgICAgICAgIHNvdXJjZTogZ2V0U291cmNlKHBhcmVuU3RhcnRbX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9MSU5FXSwgcGFyZW5TdGFydFtfdG9rZW5pemUuRklFTERTLlNUQVJUX0NPTF0sIHBhcmVuRW5kW190b2tlbml6ZS5GSUVMRFMuRU5EX0xJTkVdLCBwYXJlbkVuZFtfdG9rZW5pemUuRklFTERTLkVORF9DT0xdKSxcblx0ICAgICAgICAgIHNvdXJjZUluZGV4OiBwYXJlblN0YXJ0W190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXVxuXHQgICAgICAgIH0pKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAodW5iYWxhbmNlZCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5leHBlY3RlZCgnY2xvc2luZyBwYXJlbnRoZXNpcycsIHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXSk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIF9wcm90by5wc2V1ZG8gPSBmdW5jdGlvbiBwc2V1ZG8oKSB7XG5cdCAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuXHQgICAgdmFyIHBzZXVkb1N0ciA9ICcnO1xuXHQgICAgdmFyIHN0YXJ0aW5nVG9rZW4gPSB0aGlzLmN1cnJUb2tlbjtcblxuXHQgICAgd2hpbGUgKHRoaXMuY3VyclRva2VuICYmIHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5jb2xvbikge1xuXHQgICAgICBwc2V1ZG9TdHIgKz0gdGhpcy5jb250ZW50KCk7XG5cdCAgICAgIHRoaXMucG9zaXRpb24rKztcblx0ICAgIH1cblxuXHQgICAgaWYgKCF0aGlzLmN1cnJUb2tlbikge1xuXHQgICAgICByZXR1cm4gdGhpcy5leHBlY3RlZChbJ3BzZXVkby1jbGFzcycsICdwc2V1ZG8tZWxlbWVudCddLCB0aGlzLnBvc2l0aW9uIC0gMSk7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMud29yZCkge1xuXHQgICAgICB0aGlzLnNwbGl0V29yZChmYWxzZSwgZnVuY3Rpb24gKGZpcnN0LCBsZW5ndGgpIHtcblx0ICAgICAgICBwc2V1ZG9TdHIgKz0gZmlyc3Q7XG5cblx0ICAgICAgICBfdGhpczQubmV3Tm9kZShuZXcgX3BzZXVkb1tcImRlZmF1bHRcIl0oe1xuXHQgICAgICAgICAgdmFsdWU6IHBzZXVkb1N0cixcblx0ICAgICAgICAgIHNvdXJjZTogZ2V0VG9rZW5Tb3VyY2VTcGFuKHN0YXJ0aW5nVG9rZW4sIF90aGlzNC5jdXJyVG9rZW4pLFxuXHQgICAgICAgICAgc291cmNlSW5kZXg6IHN0YXJ0aW5nVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdXG5cdCAgICAgICAgfSkpO1xuXG5cdCAgICAgICAgaWYgKGxlbmd0aCA+IDEgJiYgX3RoaXM0Lm5leHRUb2tlbiAmJiBfdGhpczQubmV4dFRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5vcGVuUGFyZW50aGVzaXMpIHtcblx0ICAgICAgICAgIF90aGlzNC5lcnJvcignTWlzcGxhY2VkIHBhcmVudGhlc2lzLicsIHtcblx0ICAgICAgICAgICAgaW5kZXg6IF90aGlzNC5uZXh0VG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdXG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuZXhwZWN0ZWQoWydwc2V1ZG8tY2xhc3MnLCAncHNldWRvLWVsZW1lbnQnXSwgdGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgX3Byb3RvLnNwYWNlID0gZnVuY3Rpb24gc3BhY2UoKSB7XG5cdCAgICB2YXIgY29udGVudCA9IHRoaXMuY29udGVudCgpOyAvLyBIYW5kbGUgc3BhY2UgYmVmb3JlIGFuZCBhZnRlciB0aGUgc2VsZWN0b3JcblxuXHQgICAgaWYgKHRoaXMucG9zaXRpb24gPT09IDAgfHwgdGhpcy5wcmV2VG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLmNvbW1hIHx8IHRoaXMucHJldlRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5vcGVuUGFyZW50aGVzaXMgfHwgdGhpcy5jdXJyZW50Lm5vZGVzLmV2ZXJ5KGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdjb21tZW50Jztcblx0ICAgIH0pKSB7XG5cdCAgICAgIHRoaXMuc3BhY2VzID0gdGhpcy5vcHRpb25hbFNwYWNlKGNvbnRlbnQpO1xuXHQgICAgICB0aGlzLnBvc2l0aW9uKys7XG5cdCAgICB9IGVsc2UgaWYgKHRoaXMucG9zaXRpb24gPT09IHRoaXMudG9rZW5zLmxlbmd0aCAtIDEgfHwgdGhpcy5uZXh0VG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLmNvbW1hIHx8IHRoaXMubmV4dFRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5jbG9zZVBhcmVudGhlc2lzKSB7XG5cdCAgICAgIHRoaXMuY3VycmVudC5sYXN0LnNwYWNlcy5hZnRlciA9IHRoaXMub3B0aW9uYWxTcGFjZShjb250ZW50KTtcblx0ICAgICAgdGhpcy5wb3NpdGlvbisrO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy5jb21iaW5hdG9yKCk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIF9wcm90by5zdHJpbmcgPSBmdW5jdGlvbiBzdHJpbmcoKSB7XG5cdCAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VyclRva2VuO1xuXHQgICAgdGhpcy5uZXdOb2RlKG5ldyBfc3RyaW5nW1wiZGVmYXVsdFwiXSh7XG5cdCAgICAgIHZhbHVlOiB0aGlzLmNvbnRlbnQoKSxcblx0ICAgICAgc291cmNlOiBnZXRUb2tlblNvdXJjZShjdXJyZW50KSxcblx0ICAgICAgc291cmNlSW5kZXg6IGN1cnJlbnRbX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdXG5cdCAgICB9KSk7XG5cdCAgICB0aGlzLnBvc2l0aW9uKys7XG5cdCAgfTtcblxuXHQgIF9wcm90by51bml2ZXJzYWwgPSBmdW5jdGlvbiB1bml2ZXJzYWwobmFtZXNwYWNlKSB7XG5cdCAgICB2YXIgbmV4dFRva2VuID0gdGhpcy5uZXh0VG9rZW47XG5cblx0ICAgIGlmIChuZXh0VG9rZW4gJiYgdGhpcy5jb250ZW50KG5leHRUb2tlbikgPT09ICd8Jykge1xuXHQgICAgICB0aGlzLnBvc2l0aW9uKys7XG5cdCAgICAgIHJldHVybiB0aGlzLm5hbWVzcGFjZSgpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VyclRva2VuO1xuXHQgICAgdGhpcy5uZXdOb2RlKG5ldyBfdW5pdmVyc2FsW1wiZGVmYXVsdFwiXSh7XG5cdCAgICAgIHZhbHVlOiB0aGlzLmNvbnRlbnQoKSxcblx0ICAgICAgc291cmNlOiBnZXRUb2tlblNvdXJjZShjdXJyZW50KSxcblx0ICAgICAgc291cmNlSW5kZXg6IGN1cnJlbnRbX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdXG5cdCAgICB9KSwgbmFtZXNwYWNlKTtcblx0ICAgIHRoaXMucG9zaXRpb24rKztcblx0ICB9O1xuXG5cdCAgX3Byb3RvLnNwbGl0V29yZCA9IGZ1bmN0aW9uIHNwbGl0V29yZChuYW1lc3BhY2UsIGZpcnN0Q2FsbGJhY2spIHtcblx0ICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG5cdCAgICB2YXIgbmV4dFRva2VuID0gdGhpcy5uZXh0VG9rZW47XG5cdCAgICB2YXIgd29yZCA9IHRoaXMuY29udGVudCgpO1xuXG5cdCAgICB3aGlsZSAobmV4dFRva2VuICYmIH5bdG9rZW5zLmRvbGxhciwgdG9rZW5zLmNhcmV0LCB0b2tlbnMuZXF1YWxzLCB0b2tlbnMud29yZF0uaW5kZXhPZihuZXh0VG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSkpIHtcblx0ICAgICAgdGhpcy5wb3NpdGlvbisrO1xuXHQgICAgICB2YXIgY3VycmVudCA9IHRoaXMuY29udGVudCgpO1xuXHQgICAgICB3b3JkICs9IGN1cnJlbnQ7XG5cblx0ICAgICAgaWYgKGN1cnJlbnQubGFzdEluZGV4T2YoJ1xcXFwnKSA9PT0gY3VycmVudC5sZW5ndGggLSAxKSB7XG5cdCAgICAgICAgdmFyIG5leHQgPSB0aGlzLm5leHRUb2tlbjtcblxuXHQgICAgICAgIGlmIChuZXh0ICYmIG5leHRbX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLnNwYWNlKSB7XG5cdCAgICAgICAgICB3b3JkICs9IHRoaXMucmVxdWlyZWRTcGFjZSh0aGlzLmNvbnRlbnQobmV4dCkpO1xuXHQgICAgICAgICAgdGhpcy5wb3NpdGlvbisrO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIG5leHRUb2tlbiA9IHRoaXMubmV4dFRva2VuO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgaGFzQ2xhc3MgPSBpbmRleGVzT2Yod29yZCwgJy4nKS5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcblx0ICAgICAgLy8gQWxsb3cgZXNjYXBlZCBkb3Qgd2l0aGluIGNsYXNzIG5hbWVcblx0ICAgICAgdmFyIGVzY2FwZWREb3QgPSB3b3JkW2kgLSAxXSA9PT0gJ1xcXFwnOyAvLyBBbGxvdyBkZWNpbWFsIG51bWJlcnMgcGVyY2VudCBpbiBAa2V5ZnJhbWVzXG5cblx0ICAgICAgdmFyIGlzS2V5ZnJhbWVzUGVyY2VudCA9IC9eXFxkK1xcLlxcZCslJC8udGVzdCh3b3JkKTtcblx0ICAgICAgcmV0dXJuICFlc2NhcGVkRG90ICYmICFpc0tleWZyYW1lc1BlcmNlbnQ7XG5cdCAgICB9KTtcblx0ICAgIHZhciBoYXNJZCA9IGluZGV4ZXNPZih3b3JkLCAnIycpLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuXHQgICAgICByZXR1cm4gd29yZFtpIC0gMV0gIT09ICdcXFxcJztcblx0ICAgIH0pOyAvLyBFbGltaW5hdGUgU2FzcyBpbnRlcnBvbGF0aW9ucyBmcm9tIHRoZSBsaXN0IG9mIGlkIGluZGV4ZXNcblxuXHQgICAgdmFyIGludGVycG9sYXRpb25zID0gaW5kZXhlc09mKHdvcmQsICcjeycpO1xuXG5cdCAgICBpZiAoaW50ZXJwb2xhdGlvbnMubGVuZ3RoKSB7XG5cdCAgICAgIGhhc0lkID0gaGFzSWQuZmlsdGVyKGZ1bmN0aW9uIChoYXNoSW5kZXgpIHtcblx0ICAgICAgICByZXR1cm4gIX5pbnRlcnBvbGF0aW9ucy5pbmRleE9mKGhhc2hJbmRleCk7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgaW5kaWNlcyA9ICgwLCBfc29ydEFzY2VuZGluZ1tcImRlZmF1bHRcIl0pKHVuaXFzKFswXS5jb25jYXQoaGFzQ2xhc3MsIGhhc0lkKSkpO1xuXHQgICAgaW5kaWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmQsIGkpIHtcblx0ICAgICAgdmFyIGluZGV4ID0gaW5kaWNlc1tpICsgMV0gfHwgd29yZC5sZW5ndGg7XG5cdCAgICAgIHZhciB2YWx1ZSA9IHdvcmQuc2xpY2UoaW5kLCBpbmRleCk7XG5cblx0ICAgICAgaWYgKGkgPT09IDAgJiYgZmlyc3RDYWxsYmFjaykge1xuXHQgICAgICAgIHJldHVybiBmaXJzdENhbGxiYWNrLmNhbGwoX3RoaXM1LCB2YWx1ZSwgaW5kaWNlcy5sZW5ndGgpO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIG5vZGU7XG5cdCAgICAgIHZhciBjdXJyZW50ID0gX3RoaXM1LmN1cnJUb2tlbjtcblx0ICAgICAgdmFyIHNvdXJjZUluZGV4ID0gY3VycmVudFtfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU10gKyBpbmRpY2VzW2ldO1xuXHQgICAgICB2YXIgc291cmNlID0gZ2V0U291cmNlKGN1cnJlbnRbMV0sIGN1cnJlbnRbMl0gKyBpbmQsIGN1cnJlbnRbM10sIGN1cnJlbnRbMl0gKyAoaW5kZXggLSAxKSk7XG5cblx0ICAgICAgaWYgKH5oYXNDbGFzcy5pbmRleE9mKGluZCkpIHtcblx0ICAgICAgICB2YXIgY2xhc3NOYW1lT3B0cyA9IHtcblx0ICAgICAgICAgIHZhbHVlOiB2YWx1ZS5zbGljZSgxKSxcblx0ICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuXHQgICAgICAgICAgc291cmNlSW5kZXg6IHNvdXJjZUluZGV4XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBub2RlID0gbmV3IF9jbGFzc05hbWVbXCJkZWZhdWx0XCJdKHVuZXNjYXBlUHJvcChjbGFzc05hbWVPcHRzLCBcInZhbHVlXCIpKTtcblx0ICAgICAgfSBlbHNlIGlmICh+aGFzSWQuaW5kZXhPZihpbmQpKSB7XG5cdCAgICAgICAgdmFyIGlkT3B0cyA9IHtcblx0ICAgICAgICAgIHZhbHVlOiB2YWx1ZS5zbGljZSgxKSxcblx0ICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuXHQgICAgICAgICAgc291cmNlSW5kZXg6IHNvdXJjZUluZGV4XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBub2RlID0gbmV3IF9pZFtcImRlZmF1bHRcIl0odW5lc2NhcGVQcm9wKGlkT3B0cywgXCJ2YWx1ZVwiKSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdmFyIHRhZ09wdHMgPSB7XG5cdCAgICAgICAgICB2YWx1ZTogdmFsdWUsXG5cdCAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcblx0ICAgICAgICAgIHNvdXJjZUluZGV4OiBzb3VyY2VJbmRleFxuXHQgICAgICAgIH07XG5cdCAgICAgICAgdW5lc2NhcGVQcm9wKHRhZ09wdHMsIFwidmFsdWVcIik7XG5cdCAgICAgICAgbm9kZSA9IG5ldyBfdGFnW1wiZGVmYXVsdFwiXSh0YWdPcHRzKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIF90aGlzNS5uZXdOb2RlKG5vZGUsIG5hbWVzcGFjZSk7IC8vIEVuc3VyZSB0aGF0IHRoZSBuYW1lc3BhY2UgaXMgdXNlZCBvbmx5IG9uY2VcblxuXG5cdCAgICAgIG5hbWVzcGFjZSA9IG51bGw7XG5cdCAgICB9KTtcblx0ICAgIHRoaXMucG9zaXRpb24rKztcblx0ICB9O1xuXG5cdCAgX3Byb3RvLndvcmQgPSBmdW5jdGlvbiB3b3JkKG5hbWVzcGFjZSkge1xuXHQgICAgdmFyIG5leHRUb2tlbiA9IHRoaXMubmV4dFRva2VuO1xuXG5cdCAgICBpZiAobmV4dFRva2VuICYmIHRoaXMuY29udGVudChuZXh0VG9rZW4pID09PSAnfCcpIHtcblx0ICAgICAgdGhpcy5wb3NpdGlvbisrO1xuXHQgICAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2UoKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuc3BsaXRXb3JkKG5hbWVzcGFjZSk7XG5cdCAgfTtcblxuXHQgIF9wcm90by5sb29wID0gZnVuY3Rpb24gbG9vcCgpIHtcblx0ICAgIHdoaWxlICh0aGlzLnBvc2l0aW9uIDwgdGhpcy50b2tlbnMubGVuZ3RoKSB7XG5cdCAgICAgIHRoaXMucGFyc2UodHJ1ZSk7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuY3VycmVudC5faW5mZXJFbmRQb3NpdGlvbigpO1xuXG5cdCAgICByZXR1cm4gdGhpcy5yb290O1xuXHQgIH07XG5cblx0ICBfcHJvdG8ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSh0aHJvd09uUGFyZW50aGVzaXMpIHtcblx0ICAgIHN3aXRjaCAodGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSkge1xuXHQgICAgICBjYXNlIHRva2Vucy5zcGFjZTpcblx0ICAgICAgICB0aGlzLnNwYWNlKCk7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgY2FzZSB0b2tlbnMuY29tbWVudDpcblx0ICAgICAgICB0aGlzLmNvbW1lbnQoKTtcblx0ICAgICAgICBicmVhaztcblxuXHQgICAgICBjYXNlIHRva2Vucy5vcGVuUGFyZW50aGVzaXM6XG5cdCAgICAgICAgdGhpcy5wYXJlbnRoZXNlcygpO1xuXHQgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgIGNhc2UgdG9rZW5zLmNsb3NlUGFyZW50aGVzaXM6XG5cdCAgICAgICAgaWYgKHRocm93T25QYXJlbnRoZXNpcykge1xuXHQgICAgICAgICAgdGhpcy5taXNzaW5nUGFyZW50aGVzaXMoKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBicmVhaztcblxuXHQgICAgICBjYXNlIHRva2Vucy5vcGVuU3F1YXJlOlxuXHQgICAgICAgIHRoaXMuYXR0cmlidXRlKCk7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgY2FzZSB0b2tlbnMuZG9sbGFyOlxuXHQgICAgICBjYXNlIHRva2Vucy5jYXJldDpcblx0ICAgICAgY2FzZSB0b2tlbnMuZXF1YWxzOlxuXHQgICAgICBjYXNlIHRva2Vucy53b3JkOlxuXHQgICAgICAgIHRoaXMud29yZCgpO1xuXHQgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgIGNhc2UgdG9rZW5zLmNvbG9uOlxuXHQgICAgICAgIHRoaXMucHNldWRvKCk7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgY2FzZSB0b2tlbnMuY29tbWE6XG5cdCAgICAgICAgdGhpcy5jb21tYSgpO1xuXHQgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgIGNhc2UgdG9rZW5zLmFzdGVyaXNrOlxuXHQgICAgICAgIHRoaXMudW5pdmVyc2FsKCk7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgY2FzZSB0b2tlbnMuYW1wZXJzYW5kOlxuXHQgICAgICAgIHRoaXMubmVzdGluZygpO1xuXHQgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgIGNhc2UgdG9rZW5zLnNsYXNoOlxuXHQgICAgICBjYXNlIHRva2Vucy5jb21iaW5hdG9yOlxuXHQgICAgICAgIHRoaXMuY29tYmluYXRvcigpO1xuXHQgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgIGNhc2UgdG9rZW5zLnN0cjpcblx0ICAgICAgICB0aGlzLnN0cmluZygpO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICAvLyBUaGVzZSBjYXNlcyB0aHJvdzsgbm8gYnJlYWsgbmVlZGVkLlxuXG5cdCAgICAgIGNhc2UgdG9rZW5zLmNsb3NlU3F1YXJlOlxuXHQgICAgICAgIHRoaXMubWlzc2luZ1NxdWFyZUJyYWNrZXQoKTtcblxuXHQgICAgICBjYXNlIHRva2Vucy5zZW1pY29sb246XG5cdCAgICAgICAgdGhpcy5taXNzaW5nQmFja3NsYXNoKCk7XG5cblx0ICAgICAgZGVmYXVsdDpcblx0ICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgLyoqXG5cdCAgICogSGVscGVyc1xuXHQgICAqL1xuXHQgIDtcblxuXHQgIF9wcm90by5leHBlY3RlZCA9IGZ1bmN0aW9uIGV4cGVjdGVkKGRlc2NyaXB0aW9uLCBpbmRleCwgZm91bmQpIHtcblx0ICAgIGlmIChBcnJheS5pc0FycmF5KGRlc2NyaXB0aW9uKSkge1xuXHQgICAgICB2YXIgbGFzdCA9IGRlc2NyaXB0aW9uLnBvcCgpO1xuXHQgICAgICBkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uLmpvaW4oJywgJykgKyBcIiBvciBcIiArIGxhc3Q7XG5cdCAgICB9XG5cblx0ICAgIHZhciBhbiA9IC9eW2FlaW91XS8udGVzdChkZXNjcmlwdGlvblswXSkgPyAnYW4nIDogJ2EnO1xuXG5cdCAgICBpZiAoIWZvdW5kKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmVycm9yKFwiRXhwZWN0ZWQgXCIgKyBhbiArIFwiIFwiICsgZGVzY3JpcHRpb24gKyBcIi5cIiwge1xuXHQgICAgICAgIGluZGV4OiBpbmRleFxuXHQgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuZXJyb3IoXCJFeHBlY3RlZCBcIiArIGFuICsgXCIgXCIgKyBkZXNjcmlwdGlvbiArIFwiLCBmb3VuZCBcXFwiXCIgKyBmb3VuZCArIFwiXFxcIiBpbnN0ZWFkLlwiLCB7XG5cdCAgICAgIGluZGV4OiBpbmRleFxuXHQgICAgfSk7XG5cdCAgfTtcblxuXHQgIF9wcm90by5yZXF1aXJlZFNwYWNlID0gZnVuY3Rpb24gcmVxdWlyZWRTcGFjZShzcGFjZSkge1xuXHQgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sb3NzeSA/ICcgJyA6IHNwYWNlO1xuXHQgIH07XG5cblx0ICBfcHJvdG8ub3B0aW9uYWxTcGFjZSA9IGZ1bmN0aW9uIG9wdGlvbmFsU3BhY2Uoc3BhY2UpIHtcblx0ICAgIHJldHVybiB0aGlzLm9wdGlvbnMubG9zc3kgPyAnJyA6IHNwYWNlO1xuXHQgIH07XG5cblx0ICBfcHJvdG8ubG9zc3lTcGFjZSA9IGZ1bmN0aW9uIGxvc3N5U3BhY2Uoc3BhY2UsIHJlcXVpcmVkKSB7XG5cdCAgICBpZiAodGhpcy5vcHRpb25zLmxvc3N5KSB7XG5cdCAgICAgIHJldHVybiByZXF1aXJlZCA/ICcgJyA6ICcnO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIHNwYWNlO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBfcHJvdG8ucGFyc2VQYXJlbnRoZXNpc1Rva2VuID0gZnVuY3Rpb24gcGFyc2VQYXJlbnRoZXNpc1Rva2VuKHRva2VuKSB7XG5cdCAgICB2YXIgY29udGVudCA9IHRoaXMuY29udGVudCh0b2tlbik7XG5cblx0ICAgIGlmICh0b2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMuc3BhY2UpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMucmVxdWlyZWRTcGFjZShjb250ZW50KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiBjb250ZW50O1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBfcHJvdG8ubmV3Tm9kZSA9IGZ1bmN0aW9uIG5ld05vZGUobm9kZSwgbmFtZXNwYWNlKSB7XG5cdCAgICBpZiAobmFtZXNwYWNlKSB7XG5cdCAgICAgIGlmICgvXiArJC8udGVzdChuYW1lc3BhY2UpKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubG9zc3kpIHtcblx0ICAgICAgICAgIHRoaXMuc3BhY2VzID0gKHRoaXMuc3BhY2VzIHx8ICcnKSArIG5hbWVzcGFjZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBuYW1lc3BhY2UgPSB0cnVlO1xuXHQgICAgICB9XG5cblx0ICAgICAgbm9kZS5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdCAgICAgIHVuZXNjYXBlUHJvcChub2RlLCBcIm5hbWVzcGFjZVwiKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMuc3BhY2VzKSB7XG5cdCAgICAgIG5vZGUuc3BhY2VzLmJlZm9yZSA9IHRoaXMuc3BhY2VzO1xuXHQgICAgICB0aGlzLnNwYWNlcyA9ICcnO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5jdXJyZW50LmFwcGVuZChub2RlKTtcblx0ICB9O1xuXG5cdCAgX3Byb3RvLmNvbnRlbnQgPSBmdW5jdGlvbiBjb250ZW50KHRva2VuKSB7XG5cdCAgICBpZiAodG9rZW4gPT09IHZvaWQgMCkge1xuXHQgICAgICB0b2tlbiA9IHRoaXMuY3VyclRva2VuO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5jc3Muc2xpY2UodG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdLCB0b2tlbltfdG9rZW5pemUuRklFTERTLkVORF9QT1NdKTtcblx0ICB9O1xuXG5cdCAgLyoqXG5cdCAgICogcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG5leHQgbm9uLXdoaXRlc3BhY2UsIG5vbi1jb21tZW50IHRva2VuLlxuXHQgICAqIHJldHVybnMgLTEgaWYgbm8gbWVhbmluZ2Z1bCB0b2tlbiBpcyBmb3VuZC5cblx0ICAgKi9cblx0ICBfcHJvdG8ubG9jYXRlTmV4dE1lYW5pbmdmdWxUb2tlbiA9IGZ1bmN0aW9uIGxvY2F0ZU5leHRNZWFuaW5nZnVsVG9rZW4oc3RhcnRQb3NpdGlvbikge1xuXHQgICAgaWYgKHN0YXJ0UG9zaXRpb24gPT09IHZvaWQgMCkge1xuXHQgICAgICBzdGFydFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbiArIDE7XG5cdCAgICB9XG5cblx0ICAgIHZhciBzZWFyY2hQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG5cblx0ICAgIHdoaWxlIChzZWFyY2hQb3NpdGlvbiA8IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuXHQgICAgICBpZiAoV0hJVEVTUEFDRV9FUVVJVl9UT0tFTlNbdGhpcy50b2tlbnNbc2VhcmNoUG9zaXRpb25dW190b2tlbml6ZS5GSUVMRFMuVFlQRV1dKSB7XG5cdCAgICAgICAgc2VhcmNoUG9zaXRpb24rKztcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gc2VhcmNoUG9zaXRpb247XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIC0xO1xuXHQgIH07XG5cblx0ICBfY3JlYXRlQ2xhc3MoUGFyc2VyLCBbe1xuXHQgICAga2V5OiBcImN1cnJUb2tlblwiLFxuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLnBvc2l0aW9uXTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwibmV4dFRva2VuXCIsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMucG9zaXRpb24gKyAxXTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwicHJldlRva2VuXCIsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMucG9zaXRpb24gLSAxXTtcblx0ICAgIH1cblx0ICB9XSk7XG5cblx0ICByZXR1cm4gUGFyc2VyO1xuXHR9KCk7XG5cblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBQYXJzZXI7XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufSAocGFyc2VyLCBwYXJzZXIuZXhwb3J0cykpO1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG5cdHZhciBfcGFyc2VyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChwYXJzZXIuZXhwb3J0cyk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cblx0dmFyIFByb2Nlc3NvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG5cdCAgZnVuY3Rpb24gUHJvY2Vzc29yKGZ1bmMsIG9wdGlvbnMpIHtcblx0ICAgIHRoaXMuZnVuYyA9IGZ1bmMgfHwgZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG5cdCAgICB0aGlzLmZ1bmNSZXMgPSBudWxsO1xuXHQgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0ICB9XG5cblx0ICB2YXIgX3Byb3RvID0gUHJvY2Vzc29yLnByb3RvdHlwZTtcblxuXHQgIF9wcm90by5fc2hvdWxkVXBkYXRlU2VsZWN0b3IgPSBmdW5jdGlvbiBfc2hvdWxkVXBkYXRlU2VsZWN0b3IocnVsZSwgb3B0aW9ucykge1xuXHQgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuXHQgICAgICBvcHRpb25zID0ge307XG5cdCAgICB9XG5cblx0ICAgIHZhciBtZXJnZWQgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG5cdCAgICBpZiAobWVyZ2VkLnVwZGF0ZVNlbGVjdG9yID09PSBmYWxzZSkge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gdHlwZW9mIHJ1bGUgIT09IFwic3RyaW5nXCI7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIF9wcm90by5faXNMb3NzeSA9IGZ1bmN0aW9uIF9pc0xvc3N5KG9wdGlvbnMpIHtcblx0ICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcblx0ICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgfVxuXG5cdCAgICB2YXIgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuXHQgICAgaWYgKG1lcmdlZC5sb3NzbGVzcyA9PT0gZmFsc2UpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIF9wcm90by5fcm9vdCA9IGZ1bmN0aW9uIF9yb290KHJ1bGUsIG9wdGlvbnMpIHtcblx0ICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcblx0ICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgfVxuXG5cdCAgICB2YXIgcGFyc2VyID0gbmV3IF9wYXJzZXJbXCJkZWZhdWx0XCJdKHJ1bGUsIHRoaXMuX3BhcnNlT3B0aW9ucyhvcHRpb25zKSk7XG5cdCAgICByZXR1cm4gcGFyc2VyLnJvb3Q7XG5cdCAgfTtcblxuXHQgIF9wcm90by5fcGFyc2VPcHRpb25zID0gZnVuY3Rpb24gX3BhcnNlT3B0aW9ucyhvcHRpb25zKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBsb3NzeTogdGhpcy5faXNMb3NzeShvcHRpb25zKVxuXHQgICAgfTtcblx0ICB9O1xuXG5cdCAgX3Byb3RvLl9ydW4gPSBmdW5jdGlvbiBfcnVuKHJ1bGUsIG9wdGlvbnMpIHtcblx0ICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cblx0ICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcblx0ICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHZhciByb290ID0gX3RoaXMuX3Jvb3QocnVsZSwgb3B0aW9ucyk7XG5cblx0ICAgICAgICBQcm9taXNlLnJlc29sdmUoX3RoaXMuZnVuYyhyb290KSkudGhlbihmdW5jdGlvbiAodHJhbnNmb3JtKSB7XG5cdCAgICAgICAgICB2YXIgc3RyaW5nID0gdW5kZWZpbmVkO1xuXG5cdCAgICAgICAgICBpZiAoX3RoaXMuX3Nob3VsZFVwZGF0ZVNlbGVjdG9yKHJ1bGUsIG9wdGlvbnMpKSB7XG5cdCAgICAgICAgICAgIHN0cmluZyA9IHJvb3QudG9TdHJpbmcoKTtcblx0ICAgICAgICAgICAgcnVsZS5zZWxlY3RvciA9IHN0cmluZztcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG5cdCAgICAgICAgICAgIHJvb3Q6IHJvb3QsXG5cdCAgICAgICAgICAgIHN0cmluZzogc3RyaW5nXG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgIH0pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblx0ICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgIHJlamVjdChlKTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH07XG5cblx0ICBfcHJvdG8uX3J1blN5bmMgPSBmdW5jdGlvbiBfcnVuU3luYyhydWxlLCBvcHRpb25zKSB7XG5cdCAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHJvb3QgPSB0aGlzLl9yb290KHJ1bGUsIG9wdGlvbnMpO1xuXG5cdCAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5mdW5jKHJvb3QpO1xuXG5cdCAgICBpZiAodHJhbnNmb3JtICYmIHR5cGVvZiB0cmFuc2Zvcm0udGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlbGVjdG9yIHByb2Nlc3NvciByZXR1cm5lZCBhIHByb21pc2UgdG8gYSBzeW5jaHJvbm91cyBjYWxsLlwiKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHN0cmluZyA9IHVuZGVmaW5lZDtcblxuXHQgICAgaWYgKG9wdGlvbnMudXBkYXRlU2VsZWN0b3IgJiYgdHlwZW9mIHJ1bGUgIT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgc3RyaW5nID0gcm9vdC50b1N0cmluZygpO1xuXHQgICAgICBydWxlLnNlbGVjdG9yID0gc3RyaW5nO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4ge1xuXHQgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcblx0ICAgICAgcm9vdDogcm9vdCxcblx0ICAgICAgc3RyaW5nOiBzdHJpbmdcblx0ICAgIH07XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFByb2Nlc3MgcnVsZSBpbnRvIGEgc2VsZWN0b3IgQVNULlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHJ1bGUge3Bvc3Rjc3MuUnVsZSB8IHN0cmluZ30gVGhlIGNzcyBzZWxlY3RvciB0byBiZSBwcm9jZXNzZWRcblx0ICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgcHJvY2Vzc2luZ1xuXHQgICAqIEByZXR1cm5zIHtQcm9taXNlPHBhcnNlci5Sb290Pn0gVGhlIEFTVCBvZiB0aGUgc2VsZWN0b3IgYWZ0ZXIgcHJvY2Vzc2luZyBpdC5cblx0ICAgKi9cblx0ICA7XG5cblx0ICBfcHJvdG8uYXN0ID0gZnVuY3Rpb24gYXN0KHJ1bGUsIG9wdGlvbnMpIHtcblx0ICAgIHJldHVybiB0aGlzLl9ydW4ocnVsZSwgb3B0aW9ucykudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG5cdCAgICAgIHJldHVybiByZXN1bHQucm9vdDtcblx0ICAgIH0pO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBQcm9jZXNzIHJ1bGUgaW50byBhIHNlbGVjdG9yIEFTVCBzeW5jaHJvbm91c2x5LlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHJ1bGUge3Bvc3Rjc3MuUnVsZSB8IHN0cmluZ30gVGhlIGNzcyBzZWxlY3RvciB0byBiZSBwcm9jZXNzZWRcblx0ICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgcHJvY2Vzc2luZ1xuXHQgICAqIEByZXR1cm5zIHtwYXJzZXIuUm9vdH0gVGhlIEFTVCBvZiB0aGUgc2VsZWN0b3IgYWZ0ZXIgcHJvY2Vzc2luZyBpdC5cblx0ICAgKi9cblx0ICA7XG5cblx0ICBfcHJvdG8uYXN0U3luYyA9IGZ1bmN0aW9uIGFzdFN5bmMocnVsZSwgb3B0aW9ucykge1xuXHQgICAgcmV0dXJuIHRoaXMuX3J1blN5bmMocnVsZSwgb3B0aW9ucykucm9vdDtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogUHJvY2VzcyBhIHNlbGVjdG9yIGludG8gYSB0cmFuc2Zvcm1lZCB2YWx1ZSBhc3luY2hyb25vdXNseVxuXHQgICAqXG5cdCAgICogQHBhcmFtIHJ1bGUge3Bvc3Rjc3MuUnVsZSB8IHN0cmluZ30gVGhlIGNzcyBzZWxlY3RvciB0byBiZSBwcm9jZXNzZWRcblx0ICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgcHJvY2Vzc2luZ1xuXHQgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGUgcHJvY2Vzc29yLlxuXHQgICAqL1xuXHQgIDtcblxuXHQgIF9wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbiB0cmFuc2Zvcm0ocnVsZSwgb3B0aW9ucykge1xuXHQgICAgcmV0dXJuIHRoaXMuX3J1bihydWxlLCBvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgcmV0dXJuIHJlc3VsdC50cmFuc2Zvcm07XG5cdCAgICB9KTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogUHJvY2VzcyBhIHNlbGVjdG9yIGludG8gYSB0cmFuc2Zvcm1lZCB2YWx1ZSBzeW5jaHJvbm91c2x5LlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHJ1bGUge3Bvc3Rjc3MuUnVsZSB8IHN0cmluZ30gVGhlIGNzcyBzZWxlY3RvciB0byBiZSBwcm9jZXNzZWRcblx0ICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgcHJvY2Vzc2luZ1xuXHQgICAqIEByZXR1cm5zIHthbnl9IFRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGUgcHJvY2Vzc29yLlxuXHQgICAqL1xuXHQgIDtcblxuXHQgIF9wcm90by50cmFuc2Zvcm1TeW5jID0gZnVuY3Rpb24gdHJhbnNmb3JtU3luYyhydWxlLCBvcHRpb25zKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fcnVuU3luYyhydWxlLCBvcHRpb25zKS50cmFuc2Zvcm07XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFByb2Nlc3MgYSBzZWxlY3RvciBpbnRvIGEgbmV3IHNlbGVjdG9yIHN0cmluZyBhc3luY2hyb25vdXNseS5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSBydWxlIHtwb3N0Y3NzLlJ1bGUgfCBzdHJpbmd9IFRoZSBjc3Mgc2VsZWN0b3IgdG8gYmUgcHJvY2Vzc2VkXG5cdCAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHByb2Nlc3Npbmdcblx0ICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgc2VsZWN0b3IgYWZ0ZXIgcHJvY2Vzc2luZy5cblx0ICAgKi9cblx0ICA7XG5cblx0ICBfcHJvdG8ucHJvY2VzcyA9IGZ1bmN0aW9uIHByb2Nlc3MocnVsZSwgb3B0aW9ucykge1xuXHQgICAgcmV0dXJuIHRoaXMuX3J1bihydWxlLCBvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgcmV0dXJuIHJlc3VsdC5zdHJpbmcgfHwgcmVzdWx0LnJvb3QudG9TdHJpbmcoKTtcblx0ICAgIH0pO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBQcm9jZXNzIGEgc2VsZWN0b3IgaW50byBhIG5ldyBzZWxlY3RvciBzdHJpbmcgc3luY2hyb25vdXNseS5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSBydWxlIHtwb3N0Y3NzLlJ1bGUgfCBzdHJpbmd9IFRoZSBjc3Mgc2VsZWN0b3IgdG8gYmUgcHJvY2Vzc2VkXG5cdCAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHByb2Nlc3Npbmdcblx0ICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgc2VsZWN0b3IgYWZ0ZXIgcHJvY2Vzc2luZy5cblx0ICAgKi9cblx0ICA7XG5cblx0ICBfcHJvdG8ucHJvY2Vzc1N5bmMgPSBmdW5jdGlvbiBwcm9jZXNzU3luYyhydWxlLCBvcHRpb25zKSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gdGhpcy5fcnVuU3luYyhydWxlLCBvcHRpb25zKTtcblxuXHQgICAgcmV0dXJuIHJlc3VsdC5zdHJpbmcgfHwgcmVzdWx0LnJvb3QudG9TdHJpbmcoKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIFByb2Nlc3Nvcjtcblx0fSgpO1xuXG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUHJvY2Vzc29yO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn0gKHByb2Nlc3NvciwgcHJvY2Vzc29yLmV4cG9ydHMpKTtcblxudmFyIHNlbGVjdG9ycyA9IHt9O1xuXG52YXIgY29uc3RydWN0b3JzID0ge307XG5cbmNvbnN0cnVjdG9ycy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmNvbnN0cnVjdG9ycy51bml2ZXJzYWwgPSBjb25zdHJ1Y3RvcnMudGFnID0gY29uc3RydWN0b3JzLnN0cmluZyA9IGNvbnN0cnVjdG9ycy5zZWxlY3RvciA9IGNvbnN0cnVjdG9ycy5yb290ID0gY29uc3RydWN0b3JzLnBzZXVkbyA9IGNvbnN0cnVjdG9ycy5uZXN0aW5nID0gY29uc3RydWN0b3JzLmlkID0gY29uc3RydWN0b3JzLmNvbW1lbnQgPSBjb25zdHJ1Y3RvcnMuY29tYmluYXRvciA9IGNvbnN0cnVjdG9ycy5jbGFzc05hbWUgPSBjb25zdHJ1Y3RvcnMuYXR0cmlidXRlID0gdm9pZCAwO1xuXG52YXIgX2F0dHJpYnV0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQkMihhdHRyaWJ1dGUkMSk7XG5cbnZhciBfY2xhc3NOYW1lID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCQyKGNsYXNzTmFtZSQxLmV4cG9ydHMpO1xuXG52YXIgX2NvbWJpbmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0JDIoY29tYmluYXRvciQyLmV4cG9ydHMpO1xuXG52YXIgX2NvbW1lbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0JDIoY29tbWVudCQyLmV4cG9ydHMpO1xuXG52YXIgX2lkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCQyKGlkJDEuZXhwb3J0cyk7XG5cbnZhciBfbmVzdGluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQkMihuZXN0aW5nJDEuZXhwb3J0cyk7XG5cbnZhciBfcHNldWRvID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCQyKHBzZXVkbyQxLmV4cG9ydHMpO1xuXG52YXIgX3Jvb3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0JDIocm9vdCQxLmV4cG9ydHMpO1xuXG52YXIgX3NlbGVjdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCQyKHNlbGVjdG9yJDEuZXhwb3J0cyk7XG5cbnZhciBfc3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCQyKHN0cmluZyQxLmV4cG9ydHMpO1xuXG52YXIgX3RhZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQkMih0YWckMS5leHBvcnRzKTtcblxudmFyIF91bml2ZXJzYWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0JDIodW5pdmVyc2FsJDEuZXhwb3J0cyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQkMihvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbnZhciBhdHRyaWJ1dGUgPSBmdW5jdGlvbiBhdHRyaWJ1dGUob3B0cykge1xuICByZXR1cm4gbmV3IF9hdHRyaWJ1dGVbXCJkZWZhdWx0XCJdKG9wdHMpO1xufTtcblxuY29uc3RydWN0b3JzLmF0dHJpYnV0ZSA9IGF0dHJpYnV0ZTtcblxudmFyIGNsYXNzTmFtZSA9IGZ1bmN0aW9uIGNsYXNzTmFtZShvcHRzKSB7XG4gIHJldHVybiBuZXcgX2NsYXNzTmFtZVtcImRlZmF1bHRcIl0ob3B0cyk7XG59O1xuXG5jb25zdHJ1Y3RvcnMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuXG52YXIgY29tYmluYXRvciA9IGZ1bmN0aW9uIGNvbWJpbmF0b3Iob3B0cykge1xuICByZXR1cm4gbmV3IF9jb21iaW5hdG9yW1wiZGVmYXVsdFwiXShvcHRzKTtcbn07XG5cbmNvbnN0cnVjdG9ycy5jb21iaW5hdG9yID0gY29tYmluYXRvcjtcblxudmFyIGNvbW1lbnQgPSBmdW5jdGlvbiBjb21tZW50KG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBfY29tbWVudFtcImRlZmF1bHRcIl0ob3B0cyk7XG59O1xuXG5jb25zdHJ1Y3RvcnMuY29tbWVudCA9IGNvbW1lbnQ7XG5cbnZhciBpZCA9IGZ1bmN0aW9uIGlkKG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBfaWRbXCJkZWZhdWx0XCJdKG9wdHMpO1xufTtcblxuY29uc3RydWN0b3JzLmlkID0gaWQ7XG5cbnZhciBuZXN0aW5nID0gZnVuY3Rpb24gbmVzdGluZyhvcHRzKSB7XG4gIHJldHVybiBuZXcgX25lc3RpbmdbXCJkZWZhdWx0XCJdKG9wdHMpO1xufTtcblxuY29uc3RydWN0b3JzLm5lc3RpbmcgPSBuZXN0aW5nO1xuXG52YXIgcHNldWRvID0gZnVuY3Rpb24gcHNldWRvKG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBfcHNldWRvW1wiZGVmYXVsdFwiXShvcHRzKTtcbn07XG5cbmNvbnN0cnVjdG9ycy5wc2V1ZG8gPSBwc2V1ZG87XG5cbnZhciByb290ID0gZnVuY3Rpb24gcm9vdChvcHRzKSB7XG4gIHJldHVybiBuZXcgX3Jvb3RbXCJkZWZhdWx0XCJdKG9wdHMpO1xufTtcblxuY29uc3RydWN0b3JzLnJvb3QgPSByb290O1xuXG52YXIgc2VsZWN0b3IgPSBmdW5jdGlvbiBzZWxlY3RvcihvcHRzKSB7XG4gIHJldHVybiBuZXcgX3NlbGVjdG9yW1wiZGVmYXVsdFwiXShvcHRzKTtcbn07XG5cbmNvbnN0cnVjdG9ycy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXG52YXIgc3RyaW5nID0gZnVuY3Rpb24gc3RyaW5nKG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBfc3RyaW5nW1wiZGVmYXVsdFwiXShvcHRzKTtcbn07XG5cbmNvbnN0cnVjdG9ycy5zdHJpbmcgPSBzdHJpbmc7XG5cbnZhciB0YWcgPSBmdW5jdGlvbiB0YWcob3B0cykge1xuICByZXR1cm4gbmV3IF90YWdbXCJkZWZhdWx0XCJdKG9wdHMpO1xufTtcblxuY29uc3RydWN0b3JzLnRhZyA9IHRhZztcblxudmFyIHVuaXZlcnNhbCA9IGZ1bmN0aW9uIHVuaXZlcnNhbChvcHRzKSB7XG4gIHJldHVybiBuZXcgX3VuaXZlcnNhbFtcImRlZmF1bHRcIl0ob3B0cyk7XG59O1xuXG5jb25zdHJ1Y3RvcnMudW5pdmVyc2FsID0gdW5pdmVyc2FsO1xuXG52YXIgZ3VhcmRzID0ge307XG5cbmd1YXJkcy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmd1YXJkcy5pc05vZGUgPSBpc05vZGU7XG5ndWFyZHMuaXNQc2V1ZG9FbGVtZW50ID0gaXNQc2V1ZG9FbGVtZW50O1xuZ3VhcmRzLmlzUHNldWRvQ2xhc3MgPSBpc1BzZXVkb0NsYXNzO1xuZ3VhcmRzLmlzQ29udGFpbmVyID0gaXNDb250YWluZXI7XG5ndWFyZHMuaXNOYW1lc3BhY2UgPSBpc05hbWVzcGFjZTtcbmd1YXJkcy5pc1VuaXZlcnNhbCA9IGd1YXJkcy5pc1RhZyA9IGd1YXJkcy5pc1N0cmluZyA9IGd1YXJkcy5pc1NlbGVjdG9yID0gZ3VhcmRzLmlzUm9vdCA9IGd1YXJkcy5pc1BzZXVkbyA9IGd1YXJkcy5pc05lc3RpbmcgPSBndWFyZHMuaXNJZGVudGlmaWVyID0gZ3VhcmRzLmlzQ29tbWVudCA9IGd1YXJkcy5pc0NvbWJpbmF0b3IgPSBndWFyZHMuaXNDbGFzc05hbWUgPSBndWFyZHMuaXNBdHRyaWJ1dGUgPSB2b2lkIDA7XG5cbnZhciBfdHlwZXMgPSB0eXBlcztcblxudmFyIF9JU19UWVBFO1xuXG52YXIgSVNfVFlQRSA9IChfSVNfVFlQRSA9IHt9LCBfSVNfVFlQRVtfdHlwZXMuQVRUUklCVVRFXSA9IHRydWUsIF9JU19UWVBFW190eXBlcy5DTEFTU10gPSB0cnVlLCBfSVNfVFlQRVtfdHlwZXMuQ09NQklOQVRPUl0gPSB0cnVlLCBfSVNfVFlQRVtfdHlwZXMuQ09NTUVOVF0gPSB0cnVlLCBfSVNfVFlQRVtfdHlwZXMuSURdID0gdHJ1ZSwgX0lTX1RZUEVbX3R5cGVzLk5FU1RJTkddID0gdHJ1ZSwgX0lTX1RZUEVbX3R5cGVzLlBTRVVET10gPSB0cnVlLCBfSVNfVFlQRVtfdHlwZXMuUk9PVF0gPSB0cnVlLCBfSVNfVFlQRVtfdHlwZXMuU0VMRUNUT1JdID0gdHJ1ZSwgX0lTX1RZUEVbX3R5cGVzLlNUUklOR10gPSB0cnVlLCBfSVNfVFlQRVtfdHlwZXMuVEFHXSA9IHRydWUsIF9JU19UWVBFW190eXBlcy5VTklWRVJTQUxdID0gdHJ1ZSwgX0lTX1RZUEUpO1xuXG5mdW5jdGlvbiBpc05vZGUobm9kZSkge1xuICByZXR1cm4gdHlwZW9mIG5vZGUgPT09IFwib2JqZWN0XCIgJiYgSVNfVFlQRVtub2RlLnR5cGVdO1xufVxuXG5mdW5jdGlvbiBpc05vZGVUeXBlKHR5cGUsIG5vZGUpIHtcbiAgcmV0dXJuIGlzTm9kZShub2RlKSAmJiBub2RlLnR5cGUgPT09IHR5cGU7XG59XG5cbnZhciBpc0F0dHJpYnV0ZSA9IGlzTm9kZVR5cGUuYmluZChudWxsLCBfdHlwZXMuQVRUUklCVVRFKTtcbmd1YXJkcy5pc0F0dHJpYnV0ZSA9IGlzQXR0cmlidXRlO1xudmFyIGlzQ2xhc3NOYW1lID0gaXNOb2RlVHlwZS5iaW5kKG51bGwsIF90eXBlcy5DTEFTUyk7XG5ndWFyZHMuaXNDbGFzc05hbWUgPSBpc0NsYXNzTmFtZTtcbnZhciBpc0NvbWJpbmF0b3IgPSBpc05vZGVUeXBlLmJpbmQobnVsbCwgX3R5cGVzLkNPTUJJTkFUT1IpO1xuZ3VhcmRzLmlzQ29tYmluYXRvciA9IGlzQ29tYmluYXRvcjtcbnZhciBpc0NvbW1lbnQgPSBpc05vZGVUeXBlLmJpbmQobnVsbCwgX3R5cGVzLkNPTU1FTlQpO1xuZ3VhcmRzLmlzQ29tbWVudCA9IGlzQ29tbWVudDtcbnZhciBpc0lkZW50aWZpZXIgPSBpc05vZGVUeXBlLmJpbmQobnVsbCwgX3R5cGVzLklEKTtcbmd1YXJkcy5pc0lkZW50aWZpZXIgPSBpc0lkZW50aWZpZXI7XG52YXIgaXNOZXN0aW5nID0gaXNOb2RlVHlwZS5iaW5kKG51bGwsIF90eXBlcy5ORVNUSU5HKTtcbmd1YXJkcy5pc05lc3RpbmcgPSBpc05lc3Rpbmc7XG52YXIgaXNQc2V1ZG8gPSBpc05vZGVUeXBlLmJpbmQobnVsbCwgX3R5cGVzLlBTRVVETyk7XG5ndWFyZHMuaXNQc2V1ZG8gPSBpc1BzZXVkbztcbnZhciBpc1Jvb3QgPSBpc05vZGVUeXBlLmJpbmQobnVsbCwgX3R5cGVzLlJPT1QpO1xuZ3VhcmRzLmlzUm9vdCA9IGlzUm9vdDtcbnZhciBpc1NlbGVjdG9yID0gaXNOb2RlVHlwZS5iaW5kKG51bGwsIF90eXBlcy5TRUxFQ1RPUik7XG5ndWFyZHMuaXNTZWxlY3RvciA9IGlzU2VsZWN0b3I7XG52YXIgaXNTdHJpbmcgPSBpc05vZGVUeXBlLmJpbmQobnVsbCwgX3R5cGVzLlNUUklORyk7XG5ndWFyZHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbnZhciBpc1RhZyA9IGlzTm9kZVR5cGUuYmluZChudWxsLCBfdHlwZXMuVEFHKTtcbmd1YXJkcy5pc1RhZyA9IGlzVGFnO1xudmFyIGlzVW5pdmVyc2FsID0gaXNOb2RlVHlwZS5iaW5kKG51bGwsIF90eXBlcy5VTklWRVJTQUwpO1xuZ3VhcmRzLmlzVW5pdmVyc2FsID0gaXNVbml2ZXJzYWw7XG5cbmZ1bmN0aW9uIGlzUHNldWRvRWxlbWVudChub2RlKSB7XG4gIHJldHVybiBpc1BzZXVkbyhub2RlKSAmJiBub2RlLnZhbHVlICYmIChub2RlLnZhbHVlLnN0YXJ0c1dpdGgoXCI6OlwiKSB8fCBub2RlLnZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IFwiOmJlZm9yZVwiIHx8IG5vZGUudmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gXCI6YWZ0ZXJcIiB8fCBub2RlLnZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IFwiOmZpcnN0LWxldHRlclwiIHx8IG5vZGUudmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gXCI6Zmlyc3QtbGluZVwiKTtcbn1cblxuZnVuY3Rpb24gaXNQc2V1ZG9DbGFzcyhub2RlKSB7XG4gIHJldHVybiBpc1BzZXVkbyhub2RlKSAmJiAhaXNQc2V1ZG9FbGVtZW50KG5vZGUpO1xufVxuXG5mdW5jdGlvbiBpc0NvbnRhaW5lcihub2RlKSB7XG4gIHJldHVybiAhIShpc05vZGUobm9kZSkgJiYgbm9kZS53YWxrKTtcbn1cblxuZnVuY3Rpb24gaXNOYW1lc3BhY2Uobm9kZSkge1xuICByZXR1cm4gaXNBdHRyaWJ1dGUobm9kZSkgfHwgaXNUYWcobm9kZSk7XG59XG5cbihmdW5jdGlvbiAoZXhwb3J0cykge1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF90eXBlcyA9IHR5cGVzO1xuXG5cdE9iamVjdC5rZXlzKF90eXBlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuXHQgIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF90eXBlc1trZXldKSByZXR1cm47XG5cdCAgZXhwb3J0c1trZXldID0gX3R5cGVzW2tleV07XG5cdH0pO1xuXG5cdHZhciBfY29uc3RydWN0b3JzID0gY29uc3RydWN0b3JzO1xuXG5cdE9iamVjdC5rZXlzKF9jb25zdHJ1Y3RvcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcblx0ICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfY29uc3RydWN0b3JzW2tleV0pIHJldHVybjtcblx0ICBleHBvcnRzW2tleV0gPSBfY29uc3RydWN0b3JzW2tleV07XG5cdH0pO1xuXG5cdHZhciBfZ3VhcmRzID0gZ3VhcmRzO1xuXG5cdE9iamVjdC5rZXlzKF9ndWFyZHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcblx0ICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfZ3VhcmRzW2tleV0pIHJldHVybjtcblx0ICBleHBvcnRzW2tleV0gPSBfZ3VhcmRzW2tleV07XG5cdH0pO1xufSAoc2VsZWN0b3JzKSk7XG5cbihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cblx0dmFyIF9wcm9jZXNzb3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHByb2Nlc3Nvci5leHBvcnRzKTtcblxuXHR2YXIgc2VsZWN0b3JzJDEgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChzZWxlY3RvcnMpO1xuXG5cdGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cblx0dmFyIHBhcnNlciA9IGZ1bmN0aW9uIHBhcnNlcihwcm9jZXNzb3IpIHtcblx0ICByZXR1cm4gbmV3IF9wcm9jZXNzb3JbXCJkZWZhdWx0XCJdKHByb2Nlc3Nvcik7XG5cdH07XG5cblx0T2JqZWN0LmFzc2lnbihwYXJzZXIsIHNlbGVjdG9ycyQxKTtcblx0ZGVsZXRlIHBhcnNlci5fX2VzTW9kdWxlO1xuXHR2YXIgX2RlZmF1bHQgPSBwYXJzZXI7XG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufSAoZGlzdCwgZGlzdC5leHBvcnRzKSk7XG5cbmNvbnN0IG1hdGNoVmFsdWVOYW1lID0gL1skXT9bXFx3LV0rL2c7XG5cbmNvbnN0IHJlcGxhY2VWYWx1ZVN5bWJvbHMkMiA9ICh2YWx1ZSwgcmVwbGFjZW1lbnRzKSA9PiB7XG4gIGxldCBtYXRjaGVzO1xuXG4gIHdoaWxlICgobWF0Y2hlcyA9IG1hdGNoVmFsdWVOYW1lLmV4ZWModmFsdWUpKSkge1xuICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnRzW21hdGNoZXNbMF1dO1xuXG4gICAgaWYgKHJlcGxhY2VtZW50KSB7XG4gICAgICB2YWx1ZSA9XG4gICAgICAgIHZhbHVlLnNsaWNlKDAsIG1hdGNoZXMuaW5kZXgpICtcbiAgICAgICAgcmVwbGFjZW1lbnQgK1xuICAgICAgICB2YWx1ZS5zbGljZShtYXRjaFZhbHVlTmFtZS5sYXN0SW5kZXgpO1xuXG4gICAgICBtYXRjaFZhbHVlTmFtZS5sYXN0SW5kZXggLT0gbWF0Y2hlc1swXS5sZW5ndGggLSByZXBsYWNlbWVudC5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIHJlcGxhY2VWYWx1ZVN5bWJvbHNfMSA9IHJlcGxhY2VWYWx1ZVN5bWJvbHMkMjtcblxuY29uc3QgcmVwbGFjZVZhbHVlU3ltYm9scyQxID0gcmVwbGFjZVZhbHVlU3ltYm9sc18xO1xuXG5jb25zdCByZXBsYWNlU3ltYm9scyQxID0gKGNzcywgcmVwbGFjZW1lbnRzKSA9PiB7XG4gIGNzcy53YWxrKChub2RlKSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJkZWNsXCIgJiYgbm9kZS52YWx1ZSkge1xuICAgICAgbm9kZS52YWx1ZSA9IHJlcGxhY2VWYWx1ZVN5bWJvbHMkMShub2RlLnZhbHVlLnRvU3RyaW5nKCksIHJlcGxhY2VtZW50cyk7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwicnVsZVwiICYmIG5vZGUuc2VsZWN0b3IpIHtcbiAgICAgIG5vZGUuc2VsZWN0b3IgPSByZXBsYWNlVmFsdWVTeW1ib2xzJDEoXG4gICAgICAgIG5vZGUuc2VsZWN0b3IudG9TdHJpbmcoKSxcbiAgICAgICAgcmVwbGFjZW1lbnRzXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcImF0cnVsZVwiICYmIG5vZGUucGFyYW1zKSB7XG4gICAgICBub2RlLnBhcmFtcyA9IHJlcGxhY2VWYWx1ZVN5bWJvbHMkMShub2RlLnBhcmFtcy50b1N0cmluZygpLCByZXBsYWNlbWVudHMpO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgcmVwbGFjZVN5bWJvbHNfMSA9IHJlcGxhY2VTeW1ib2xzJDE7XG5cbmNvbnN0IGltcG9ydFBhdHRlcm4gPSAvXjppbXBvcnRcXCgoXCJbXlwiXSpcInwnW14nXSonfFteXCInXSspXFwpJC87XG5jb25zdCBiYWxhbmNlZFF1b3RlcyA9IC9eKFwiW15cIl0qXCJ8J1teJ10qJ3xbXlwiJ10rKSQvO1xuXG5jb25zdCBnZXREZWNsc09iamVjdCA9IChydWxlKSA9PiB7XG4gIGNvbnN0IG9iamVjdCA9IHt9O1xuXG4gIHJ1bGUud2Fsa0RlY2xzKChkZWNsKSA9PiB7XG4gICAgY29uc3QgYmVmb3JlID0gZGVjbC5yYXdzLmJlZm9yZSA/IGRlY2wucmF3cy5iZWZvcmUudHJpbSgpIDogXCJcIjtcblxuICAgIG9iamVjdFtiZWZvcmUgKyBkZWNsLnByb3BdID0gZGVjbC52YWx1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIG9iamVjdDtcbn07XG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJlbW92ZVJ1bGVzXG4gKiBAcGFyYW0geydhdXRvJyB8ICdydWxlJyB8ICdhdC1ydWxlJ30gbW9kZVxuICovXG5jb25zdCBleHRyYWN0SUNTUyQyID0gKGNzcywgcmVtb3ZlUnVsZXMgPSB0cnVlLCBtb2RlID0gXCJhdXRvXCIpID0+IHtcbiAgY29uc3QgaWNzc0ltcG9ydHMgPSB7fTtcbiAgY29uc3QgaWNzc0V4cG9ydHMgPSB7fTtcblxuICBmdW5jdGlvbiBhZGRJbXBvcnRzKG5vZGUsIHBhdGgpIHtcbiAgICBjb25zdCB1bnF1b3RlZCA9IHBhdGgucmVwbGFjZSgvJ3xcIi9nLCBcIlwiKTtcbiAgICBpY3NzSW1wb3J0c1t1bnF1b3RlZF0gPSBPYmplY3QuYXNzaWduKFxuICAgICAgaWNzc0ltcG9ydHNbdW5xdW90ZWRdIHx8IHt9LFxuICAgICAgZ2V0RGVjbHNPYmplY3Qobm9kZSlcbiAgICApO1xuXG4gICAgaWYgKHJlbW92ZVJ1bGVzKSB7XG4gICAgICBub2RlLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEV4cG9ydHMobm9kZSkge1xuICAgIE9iamVjdC5hc3NpZ24oaWNzc0V4cG9ydHMsIGdldERlY2xzT2JqZWN0KG5vZGUpKTtcbiAgICBpZiAocmVtb3ZlUnVsZXMpIHtcbiAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgfVxuICB9XG5cbiAgY3NzLmVhY2goKG5vZGUpID0+IHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcInJ1bGVcIiAmJiBtb2RlICE9PSBcImF0LXJ1bGVcIikge1xuICAgICAgaWYgKG5vZGUuc2VsZWN0b3Iuc2xpY2UoMCwgNykgPT09IFwiOmltcG9ydFwiKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBpbXBvcnRQYXR0ZXJuLmV4ZWMobm9kZS5zZWxlY3Rvcik7XG5cbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICBhZGRJbXBvcnRzKG5vZGUsIG1hdGNoZXNbMV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnNlbGVjdG9yID09PSBcIjpleHBvcnRcIikge1xuICAgICAgICBhZGRFeHBvcnRzKG5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub2RlLnR5cGUgPT09IFwiYXRydWxlXCIgJiYgbW9kZSAhPT0gXCJydWxlXCIpIHtcbiAgICAgIGlmIChub2RlLm5hbWUgPT09IFwiaWNzcy1pbXBvcnRcIikge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gYmFsYW5jZWRRdW90ZXMuZXhlYyhub2RlLnBhcmFtcyk7XG5cbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICBhZGRJbXBvcnRzKG5vZGUsIG1hdGNoZXNbMV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5uYW1lID09PSBcImljc3MtZXhwb3J0XCIpIHtcbiAgICAgICAgYWRkRXhwb3J0cyhub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7IGljc3NJbXBvcnRzLCBpY3NzRXhwb3J0cyB9O1xufTtcblxudmFyIGV4dHJhY3RJQ1NTXzEgPSBleHRyYWN0SUNTUyQyO1xuXG5jb25zdCBjcmVhdGVJbXBvcnRzID0gKGltcG9ydHMsIHBvc3Rjc3MsIG1vZGUgPSBcInJ1bGVcIikgPT4ge1xuICByZXR1cm4gT2JqZWN0LmtleXMoaW1wb3J0cykubWFwKChwYXRoKSA9PiB7XG4gICAgY29uc3QgYWxpYXNlcyA9IGltcG9ydHNbcGF0aF07XG4gICAgY29uc3QgZGVjbGFyYXRpb25zID0gT2JqZWN0LmtleXMoYWxpYXNlcykubWFwKChrZXkpID0+XG4gICAgICBwb3N0Y3NzLmRlY2woe1xuICAgICAgICBwcm9wOiBrZXksXG4gICAgICAgIHZhbHVlOiBhbGlhc2VzW2tleV0sXG4gICAgICAgIHJhd3M6IHsgYmVmb3JlOiBcIlxcbiAgXCIgfSxcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIGNvbnN0IGhhc0RlY2xhcmF0aW9ucyA9IGRlY2xhcmF0aW9ucy5sZW5ndGggPiAwO1xuXG4gICAgY29uc3QgcnVsZSA9XG4gICAgICBtb2RlID09PSBcInJ1bGVcIlxuICAgICAgICA/IHBvc3Rjc3MucnVsZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogYDppbXBvcnQoJyR7cGF0aH0nKWAsXG4gICAgICAgICAgICByYXdzOiB7IGFmdGVyOiBoYXNEZWNsYXJhdGlvbnMgPyBcIlxcblwiIDogXCJcIiB9LFxuICAgICAgICAgIH0pXG4gICAgICAgIDogcG9zdGNzcy5hdFJ1bGUoe1xuICAgICAgICAgICAgbmFtZTogXCJpY3NzLWltcG9ydFwiLFxuICAgICAgICAgICAgcGFyYW1zOiBgJyR7cGF0aH0nYCxcbiAgICAgICAgICAgIHJhd3M6IHsgYWZ0ZXI6IGhhc0RlY2xhcmF0aW9ucyA/IFwiXFxuXCIgOiBcIlwiIH0sXG4gICAgICAgICAgfSk7XG5cbiAgICBpZiAoaGFzRGVjbGFyYXRpb25zKSB7XG4gICAgICBydWxlLmFwcGVuZChkZWNsYXJhdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBydWxlO1xuICB9KTtcbn07XG5cbmNvbnN0IGNyZWF0ZUV4cG9ydHMgPSAoZXhwb3J0cywgcG9zdGNzcywgbW9kZSA9IFwicnVsZVwiKSA9PiB7XG4gIGNvbnN0IGRlY2xhcmF0aW9ucyA9IE9iamVjdC5rZXlzKGV4cG9ydHMpLm1hcCgoa2V5KSA9PlxuICAgIHBvc3Rjc3MuZGVjbCh7XG4gICAgICBwcm9wOiBrZXksXG4gICAgICB2YWx1ZTogZXhwb3J0c1trZXldLFxuICAgICAgcmF3czogeyBiZWZvcmU6IFwiXFxuICBcIiB9LFxuICAgIH0pXG4gICk7XG5cbiAgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgcnVsZSA9XG4gICAgbW9kZSA9PT0gXCJydWxlXCJcbiAgICAgID8gcG9zdGNzcy5ydWxlKHtcbiAgICAgICAgICBzZWxlY3RvcjogYDpleHBvcnRgLFxuICAgICAgICAgIHJhd3M6IHsgYWZ0ZXI6IFwiXFxuXCIgfSxcbiAgICAgICAgfSlcbiAgICAgIDogcG9zdGNzcy5hdFJ1bGUoe1xuICAgICAgICAgIG5hbWU6IFwiaWNzcy1leHBvcnRcIixcbiAgICAgICAgICByYXdzOiB7IGFmdGVyOiBcIlxcblwiIH0sXG4gICAgICAgIH0pO1xuXG4gIHJ1bGUuYXBwZW5kKGRlY2xhcmF0aW9ucyk7XG5cbiAgcmV0dXJuIFtydWxlXTtcbn07XG5cbmNvbnN0IGNyZWF0ZUlDU1NSdWxlcyQxID0gKGltcG9ydHMsIGV4cG9ydHMsIHBvc3Rjc3MsIG1vZGUpID0+IFtcbiAgLi4uY3JlYXRlSW1wb3J0cyhpbXBvcnRzLCBwb3N0Y3NzLCBtb2RlKSxcbiAgLi4uY3JlYXRlRXhwb3J0cyhleHBvcnRzLCBwb3N0Y3NzLCBtb2RlKSxcbl07XG5cbnZhciBjcmVhdGVJQ1NTUnVsZXNfMSA9IGNyZWF0ZUlDU1NSdWxlcyQxO1xuXG5jb25zdCByZXBsYWNlVmFsdWVTeW1ib2xzID0gcmVwbGFjZVZhbHVlU3ltYm9sc18xO1xuY29uc3QgcmVwbGFjZVN5bWJvbHMgPSByZXBsYWNlU3ltYm9sc18xO1xuY29uc3QgZXh0cmFjdElDU1MkMSA9IGV4dHJhY3RJQ1NTXzE7XG5jb25zdCBjcmVhdGVJQ1NTUnVsZXMgPSBjcmVhdGVJQ1NTUnVsZXNfMTtcblxudmFyIHNyYyQzID0ge1xuICByZXBsYWNlVmFsdWVTeW1ib2xzLFxuICByZXBsYWNlU3ltYm9scyxcbiAgZXh0cmFjdElDU1M6IGV4dHJhY3RJQ1NTJDEsXG4gIGNyZWF0ZUlDU1NSdWxlcyxcbn07XG5cbmNvbnN0IHNlbGVjdG9yUGFyc2VyJDEgPSBkaXN0LmV4cG9ydHM7XG5jb25zdCB2YWx1ZVBhcnNlciA9IGxpYiQxO1xuY29uc3QgeyBleHRyYWN0SUNTUyB9ID0gc3JjJDM7XG5cbmNvbnN0IGlzU3BhY2luZyA9IChub2RlKSA9PiBub2RlLnR5cGUgPT09IFwiY29tYmluYXRvclwiICYmIG5vZGUudmFsdWUgPT09IFwiIFwiO1xuXG5mdW5jdGlvbiBub3JtYWxpemVOb2RlQXJyYXkobm9kZXMpIHtcbiAgY29uc3QgYXJyYXkgPSBbXTtcblxuICBub2Rlcy5mb3JFYWNoKCh4KSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICAgIG5vcm1hbGl6ZU5vZGVBcnJheSh4KS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIGFycmF5LnB1c2goaXRlbSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHgpIHtcbiAgICAgIGFycmF5LnB1c2goeCk7XG4gICAgfVxuICB9KTtcblxuICBpZiAoYXJyYXkubGVuZ3RoID4gMCAmJiBpc1NwYWNpbmcoYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV0pKSB7XG4gICAgYXJyYXkucG9wKCk7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5mdW5jdGlvbiBsb2NhbGl6ZU5vZGUocnVsZSwgbW9kZSwgbG9jYWxBbGlhc01hcCkge1xuICBjb25zdCB0cmFuc2Zvcm0gPSAobm9kZSwgY29udGV4dCkgPT4ge1xuICAgIGlmIChjb250ZXh0Lmlnbm9yZU5leHRTcGFjaW5nICYmICFpc1NwYWNpbmcobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgd2hpdGVzcGFjZSBhZnRlciBcIiArIGNvbnRleHQuaWdub3JlTmV4dFNwYWNpbmcpO1xuICAgIH1cblxuICAgIGlmIChjb250ZXh0LmVuZm9yY2VOb1NwYWNpbmcgJiYgaXNTcGFjaW5nKG5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHdoaXRlc3BhY2UgYmVmb3JlIFwiICsgY29udGV4dC5lbmZvcmNlTm9TcGFjaW5nKTtcbiAgICB9XG5cbiAgICBsZXQgbmV3Tm9kZXM7XG5cbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcInJvb3RcIjoge1xuICAgICAgICBsZXQgcmVzdWx0aW5nR2xvYmFsO1xuXG4gICAgICAgIGNvbnRleHQuaGFzUHVyZUdsb2JhbHMgPSBmYWxzZTtcblxuICAgICAgICBuZXdOb2RlcyA9IG5vZGUubm9kZXMubWFwKChuKSA9PiB7XG4gICAgICAgICAgY29uc3QgbkNvbnRleHQgPSB7XG4gICAgICAgICAgICBnbG9iYWw6IGNvbnRleHQuZ2xvYmFsLFxuICAgICAgICAgICAgbGFzdFdhc1NwYWNpbmc6IHRydWUsXG4gICAgICAgICAgICBoYXNMb2NhbHM6IGZhbHNlLFxuICAgICAgICAgICAgZXhwbGljaXQ6IGZhbHNlLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBuID0gdHJhbnNmb3JtKG4sIG5Db250ZXh0KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0aW5nR2xvYmFsID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXN1bHRpbmdHbG9iYWwgPSBuQ29udGV4dC5nbG9iYWw7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHRpbmdHbG9iYWwgIT09IG5Db250ZXh0Lmdsb2JhbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAnSW5jb25zaXN0ZW50IHJ1bGUgZ2xvYmFsL2xvY2FsIHJlc3VsdCBpbiBydWxlIFwiJyArXG4gICAgICAgICAgICAgICAgbm9kZSArXG4gICAgICAgICAgICAgICAgJ1wiIChtdWx0aXBsZSBzZWxlY3RvcnMgbXVzdCByZXN1bHQgaW4gdGhlIHNhbWUgbW9kZSBmb3IgdGhlIHJ1bGUpJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIW5Db250ZXh0Lmhhc0xvY2Fscykge1xuICAgICAgICAgICAgY29udGV4dC5oYXNQdXJlR2xvYmFscyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnRleHQuZ2xvYmFsID0gcmVzdWx0aW5nR2xvYmFsO1xuXG4gICAgICAgIG5vZGUubm9kZXMgPSBub3JtYWxpemVOb2RlQXJyYXkobmV3Tm9kZXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJzZWxlY3RvclwiOiB7XG4gICAgICAgIG5ld05vZGVzID0gbm9kZS5tYXAoKGNoaWxkTm9kZSkgPT4gdHJhbnNmb3JtKGNoaWxkTm9kZSwgY29udGV4dCkpO1xuXG4gICAgICAgIG5vZGUgPSBub2RlLmNsb25lKCk7XG4gICAgICAgIG5vZGUubm9kZXMgPSBub3JtYWxpemVOb2RlQXJyYXkobmV3Tm9kZXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJjb21iaW5hdG9yXCI6IHtcbiAgICAgICAgaWYgKGlzU3BhY2luZyhub2RlKSkge1xuICAgICAgICAgIGlmIChjb250ZXh0Lmlnbm9yZU5leHRTcGFjaW5nKSB7XG4gICAgICAgICAgICBjb250ZXh0Lmlnbm9yZU5leHRTcGFjaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBjb250ZXh0Lmxhc3RXYXNTcGFjaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBjb250ZXh0LmVuZm9yY2VOb1NwYWNpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250ZXh0Lmxhc3RXYXNTcGFjaW5nID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJwc2V1ZG9cIjoge1xuICAgICAgICBsZXQgY2hpbGRDb250ZXh0O1xuICAgICAgICBjb25zdCBpc05lc3RlZCA9ICEhbm9kZS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGlzU2NvcGVkID0gbm9kZS52YWx1ZSA9PT0gXCI6bG9jYWxcIiB8fCBub2RlLnZhbHVlID09PSBcIjpnbG9iYWxcIjtcbiAgICAgICAgY29uc3QgaXNJbXBvcnRFeHBvcnQgPVxuICAgICAgICAgIG5vZGUudmFsdWUgPT09IFwiOmltcG9ydFwiIHx8IG5vZGUudmFsdWUgPT09IFwiOmV4cG9ydFwiO1xuXG4gICAgICAgIGlmIChpc0ltcG9ydEV4cG9ydCkge1xuICAgICAgICAgIGNvbnRleHQuaGFzTG9jYWxzID0gdHJ1ZTtcbiAgICAgICAgICAvLyA6bG9jYWwoLmZvbylcbiAgICAgICAgfSBlbHNlIGlmIChpc05lc3RlZCkge1xuICAgICAgICAgIGlmIChpc1Njb3BlZCkge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtub2RlLnZhbHVlfSgpIGNhbid0IGJlIGVtcHR5YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb250ZXh0Lmluc2lkZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYEEgJHtub2RlLnZhbHVlfSBpcyBub3QgYWxsb3dlZCBpbnNpZGUgb2YgYSAke2NvbnRleHQuaW5zaWRlfSguLi4pYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGlsZENvbnRleHQgPSB7XG4gICAgICAgICAgICAgIGdsb2JhbDogbm9kZS52YWx1ZSA9PT0gXCI6Z2xvYmFsXCIsXG4gICAgICAgICAgICAgIGluc2lkZTogbm9kZS52YWx1ZSxcbiAgICAgICAgICAgICAgaGFzTG9jYWxzOiBmYWxzZSxcbiAgICAgICAgICAgICAgZXhwbGljaXQ6IHRydWUsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBuZXdOb2RlcyA9IG5vZGVcbiAgICAgICAgICAgICAgLm1hcCgoY2hpbGROb2RlKSA9PiB0cmFuc2Zvcm0oY2hpbGROb2RlLCBjaGlsZENvbnRleHQpKVxuICAgICAgICAgICAgICAucmVkdWNlKChhY2MsIG5leHQpID0+IGFjYy5jb25jYXQobmV4dC5ub2RlcyksIFtdKTtcblxuICAgICAgICAgICAgaWYgKG5ld05vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjb25zdCB7IGJlZm9yZSwgYWZ0ZXIgfSA9IG5vZGUuc3BhY2VzO1xuXG4gICAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gbmV3Tm9kZXNbMF07XG4gICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBuZXdOb2Rlc1tuZXdOb2Rlcy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgICBmaXJzdC5zcGFjZXMgPSB7IGJlZm9yZSwgYWZ0ZXI6IGZpcnN0LnNwYWNlcy5hZnRlciB9O1xuICAgICAgICAgICAgICBsYXN0LnNwYWNlcyA9IHsgYmVmb3JlOiBsYXN0LnNwYWNlcy5iZWZvcmUsIGFmdGVyIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSBuZXdOb2RlcztcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkQ29udGV4dCA9IHtcbiAgICAgICAgICAgICAgZ2xvYmFsOiBjb250ZXh0Lmdsb2JhbCxcbiAgICAgICAgICAgICAgaW5zaWRlOiBjb250ZXh0Lmluc2lkZSxcbiAgICAgICAgICAgICAgbGFzdFdhc1NwYWNpbmc6IHRydWUsXG4gICAgICAgICAgICAgIGhhc0xvY2FsczogZmFsc2UsXG4gICAgICAgICAgICAgIGV4cGxpY2l0OiBjb250ZXh0LmV4cGxpY2l0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5ld05vZGVzID0gbm9kZS5tYXAoKGNoaWxkTm9kZSkgPT5cbiAgICAgICAgICAgICAgdHJhbnNmb3JtKGNoaWxkTm9kZSwgY2hpbGRDb250ZXh0KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2xvbmUoKTtcbiAgICAgICAgICAgIG5vZGUubm9kZXMgPSBub3JtYWxpemVOb2RlQXJyYXkobmV3Tm9kZXMpO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGRDb250ZXh0Lmhhc0xvY2Fscykge1xuICAgICAgICAgICAgICBjb250ZXh0Lmhhc0xvY2FscyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy86bG9jYWwgLmZvbyAuYmFyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNTY29wZWQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dC5pbnNpZGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYEEgJHtub2RlLnZhbHVlfSBpcyBub3QgYWxsb3dlZCBpbnNpZGUgb2YgYSAke2NvbnRleHQuaW5zaWRlfSguLi4pYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBhZGRCYWNrU3BhY2luZyA9ICEhbm9kZS5zcGFjZXMuYmVmb3JlO1xuXG4gICAgICAgICAgY29udGV4dC5pZ25vcmVOZXh0U3BhY2luZyA9IGNvbnRleHQubGFzdFdhc1NwYWNpbmdcbiAgICAgICAgICAgID8gbm9kZS52YWx1ZVxuICAgICAgICAgICAgOiBmYWxzZTtcblxuICAgICAgICAgIGNvbnRleHQuZW5mb3JjZU5vU3BhY2luZyA9IGNvbnRleHQubGFzdFdhc1NwYWNpbmdcbiAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgIDogbm9kZS52YWx1ZTtcblxuICAgICAgICAgIGNvbnRleHQuZ2xvYmFsID0gbm9kZS52YWx1ZSA9PT0gXCI6Z2xvYmFsXCI7XG4gICAgICAgICAgY29udGV4dC5leHBsaWNpdCA9IHRydWU7XG5cbiAgICAgICAgICAvLyBiZWNhdXNlIHRoaXMgbm9kZSBoYXMgc3BhY2luZyB0aGF0IGlzIGxvc3Qgd2hlbiB3ZSByZW1vdmUgaXRcbiAgICAgICAgICAvLyB3ZSBtYWtlIHVwIGZvciBpdCBieSBhZGRpbmcgYW4gZXh0cmEgY29tYmluYXRvciBpbiBzaW5jZSBhZGRpbmdcbiAgICAgICAgICAvLyBzcGFjaW5nIG9uIHRoZSBwYXJlbnQgc2VsZWN0b3IgZG9lc24ndCB3b3JrXG4gICAgICAgICAgcmV0dXJuIGFkZEJhY2tTcGFjaW5nXG4gICAgICAgICAgICA/IHNlbGVjdG9yUGFyc2VyJDEuY29tYmluYXRvcih7IHZhbHVlOiBcIiBcIiB9KVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImlkXCI6XG4gICAgICBjYXNlIFwiY2xhc3NcIjoge1xuICAgICAgICBpZiAoIW5vZGUudmFsdWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNsYXNzIG9yIGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lmdsb2JhbCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNJbXBvcnRlZFZhbHVlID0gbG9jYWxBbGlhc01hcC5oYXMobm9kZS52YWx1ZSk7XG4gICAgICAgIGNvbnN0IGlzSW1wb3J0ZWRXaXRoRXhwbGljaXRTY29wZSA9IGlzSW1wb3J0ZWRWYWx1ZSAmJiBjb250ZXh0LmV4cGxpY2l0O1xuXG4gICAgICAgIGlmICghaXNJbXBvcnRlZFZhbHVlIHx8IGlzSW1wb3J0ZWRXaXRoRXhwbGljaXRTY29wZSkge1xuICAgICAgICAgIGNvbnN0IGlubmVyTm9kZSA9IG5vZGUuY2xvbmUoKTtcbiAgICAgICAgICBpbm5lck5vZGUuc3BhY2VzID0geyBiZWZvcmU6IFwiXCIsIGFmdGVyOiBcIlwiIH07XG5cbiAgICAgICAgICBub2RlID0gc2VsZWN0b3JQYXJzZXIkMS5wc2V1ZG8oe1xuICAgICAgICAgICAgdmFsdWU6IFwiOmxvY2FsXCIsXG4gICAgICAgICAgICBub2RlczogW2lubmVyTm9kZV0sXG4gICAgICAgICAgICBzcGFjZXM6IG5vZGUuc3BhY2VzLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29udGV4dC5oYXNMb2NhbHMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29udGV4dC5sYXN0V2FzU3BhY2luZyA9IGZhbHNlO1xuICAgIGNvbnRleHQuaWdub3JlTmV4dFNwYWNpbmcgPSBmYWxzZTtcbiAgICBjb250ZXh0LmVuZm9yY2VOb1NwYWNpbmcgPSBmYWxzZTtcblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIGNvbnN0IHJvb3RDb250ZXh0ID0ge1xuICAgIGdsb2JhbDogbW9kZSA9PT0gXCJnbG9iYWxcIixcbiAgICBoYXNQdXJlR2xvYmFsczogZmFsc2UsXG4gIH07XG5cbiAgcm9vdENvbnRleHQuc2VsZWN0b3IgPSBzZWxlY3RvclBhcnNlciQxKChyb290KSA9PiB7XG4gICAgdHJhbnNmb3JtKHJvb3QsIHJvb3RDb250ZXh0KTtcbiAgfSkucHJvY2Vzc1N5bmMocnVsZSwgeyB1cGRhdGVTZWxlY3RvcjogZmFsc2UsIGxvc3NsZXNzOiB0cnVlIH0pO1xuXG4gIHJldHVybiByb290Q29udGV4dDtcbn1cblxuZnVuY3Rpb24gbG9jYWxpemVEZWNsTm9kZShub2RlLCBjb250ZXh0KSB7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIndvcmRcIjpcbiAgICAgIGlmIChjb250ZXh0LmxvY2FsaXplTmV4dEl0ZW0pIHtcbiAgICAgICAgaWYgKCFjb250ZXh0LmxvY2FsQWxpYXNNYXAuaGFzKG5vZGUudmFsdWUpKSB7XG4gICAgICAgICAgbm9kZS52YWx1ZSA9IFwiOmxvY2FsKFwiICsgbm9kZS52YWx1ZSArIFwiKVwiO1xuICAgICAgICAgIGNvbnRleHQubG9jYWxpemVOZXh0SXRlbSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgaWYgKFxuICAgICAgICBjb250ZXh0Lm9wdGlvbnMgJiZcbiAgICAgICAgY29udGV4dC5vcHRpb25zLnJld3JpdGVVcmwgJiZcbiAgICAgICAgbm9kZS52YWx1ZS50b0xvd2VyQ2FzZSgpID09PSBcInVybFwiXG4gICAgICApIHtcbiAgICAgICAgbm9kZS5ub2Rlcy5tYXAoKG5lc3RlZE5vZGUpID0+IHtcbiAgICAgICAgICBpZiAobmVzdGVkTm9kZS50eXBlICE9PSBcInN0cmluZ1wiICYmIG5lc3RlZE5vZGUudHlwZSAhPT0gXCJ3b3JkXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgbmV3VXJsID0gY29udGV4dC5vcHRpb25zLnJld3JpdGVVcmwoXG4gICAgICAgICAgICBjb250ZXh0Lmdsb2JhbCxcbiAgICAgICAgICAgIG5lc3RlZE5vZGUudmFsdWVcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgc3dpdGNoIChuZXN0ZWROb2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgaWYgKG5lc3RlZE5vZGUucXVvdGUgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICAgICAgbmV3VXJsID0gbmV3VXJsLnJlcGxhY2UoLyhcXFxcKS9nLCBcIlxcXFwkMVwiKS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobmVzdGVkTm9kZS5xdW90ZSA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgIG5ld1VybCA9IG5ld1VybC5yZXBsYWNlKC8oXFxcXCkvZywgXCJcXFxcJDFcIikucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwid29yZFwiOlxuICAgICAgICAgICAgICBuZXdVcmwgPSBuZXdVcmwucmVwbGFjZSgvKFwifCd8XFwpfFxcXFwpL2csIFwiXFxcXCQxXCIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXN0ZWROb2RlLnZhbHVlID0gbmV3VXJsO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBpc1dvcmRBRnVuY3Rpb25Bcmd1bWVudCh3b3JkTm9kZSwgZnVuY3Rpb25Ob2RlKSB7XG4gIHJldHVybiBmdW5jdGlvbk5vZGVcbiAgICA/IGZ1bmN0aW9uTm9kZS5ub2Rlcy5zb21lKFxuICAgICAgICAoZnVuY3Rpb25Ob2RlQ2hpbGQpID0+XG4gICAgICAgICAgZnVuY3Rpb25Ob2RlQ2hpbGQuc291cmNlSW5kZXggPT09IHdvcmROb2RlLnNvdXJjZUluZGV4XG4gICAgICApXG4gICAgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbG9jYWxpemVEZWNsYXJhdGlvblZhbHVlcyhsb2NhbGl6ZSwgZGVjbGFyYXRpb24sIGNvbnRleHQpIHtcbiAgY29uc3QgdmFsdWVOb2RlcyA9IHZhbHVlUGFyc2VyKGRlY2xhcmF0aW9uLnZhbHVlKTtcblxuICB2YWx1ZU5vZGVzLndhbGsoKG5vZGUsIGluZGV4LCBub2RlcykgPT4ge1xuICAgIGNvbnN0IHN1YkNvbnRleHQgPSB7XG4gICAgICBvcHRpb25zOiBjb250ZXh0Lm9wdGlvbnMsXG4gICAgICBnbG9iYWw6IGNvbnRleHQuZ2xvYmFsLFxuICAgICAgbG9jYWxpemVOZXh0SXRlbTogbG9jYWxpemUgJiYgIWNvbnRleHQuZ2xvYmFsLFxuICAgICAgbG9jYWxBbGlhc01hcDogY29udGV4dC5sb2NhbEFsaWFzTWFwLFxuICAgIH07XG4gICAgbm9kZXNbaW5kZXhdID0gbG9jYWxpemVEZWNsTm9kZShub2RlLCBzdWJDb250ZXh0KTtcbiAgfSk7XG5cbiAgZGVjbGFyYXRpb24udmFsdWUgPSB2YWx1ZU5vZGVzLnRvU3RyaW5nKCk7XG59XG5cbmZ1bmN0aW9uIGxvY2FsaXplRGVjbGFyYXRpb24oZGVjbGFyYXRpb24sIGNvbnRleHQpIHtcbiAgY29uc3QgaXNBbmltYXRpb24gPSAvYW5pbWF0aW9uJC9pLnRlc3QoZGVjbGFyYXRpb24ucHJvcCk7XG5cbiAgaWYgKGlzQW5pbWF0aW9uKSB7XG4gICAgY29uc3QgdmFsaWRJZGVudCA9IC9eLT9bX2Etel1bX2EtejAtOS1dKiQvaTtcblxuICAgIC8qXG4gICAgVGhlIHNwZWMgZGVmaW5lcyBzb21lIGtleXdvcmRzIHRoYXQgeW91IGNhbiB1c2UgdG8gZGVzY3JpYmUgcHJvcGVydGllcyBzdWNoIGFzIHRoZSB0aW1pbmdcbiAgICBmdW5jdGlvbi4gVGhlc2UgYXJlIHN0aWxsIHZhbGlkIGFuaW1hdGlvbiBuYW1lcywgc28gYXMgbG9uZyBhcyB0aGVyZSBpcyBhIHByb3BlcnR5IHRoYXQgYWNjZXB0c1xuICAgIGEga2V5d29yZCwgaXQgaXMgZ2l2ZW4gcHJpb3JpdHkuIE9ubHkgd2hlbiBhbGwgdGhlIHByb3BlcnRpZXMgdGhhdCBjYW4gdGFrZSBhIGtleXdvcmQgYXJlXG4gICAgZXhoYXVzdGVkIGNhbiB0aGUgYW5pbWF0aW9uIG5hbWUgYmUgc2V0IHRvIHRoZSBrZXl3b3JkLiBJLmUuXG4gIFxuICAgIGFuaW1hdGlvbjogaW5maW5pdGUgaW5maW5pdGU7XG4gIFxuICAgIFRoZSBhbmltYXRpb24gd2lsbCByZXBlYXQgYW4gaW5maW5pdGUgbnVtYmVyIG9mIHRpbWVzIGZyb20gdGhlIGZpcnN0IGFyZ3VtZW50LCBhbmQgd2lsbCBoYXZlIGFuXG4gICAgYW5pbWF0aW9uIG5hbWUgb2YgaW5maW5pdGUgZnJvbSB0aGUgc2Vjb25kLlxuICAgICovXG4gICAgY29uc3QgYW5pbWF0aW9uS2V5d29yZHMgPSB7XG4gICAgICAkYWx0ZXJuYXRlOiAxLFxuICAgICAgXCIkYWx0ZXJuYXRlLXJldmVyc2VcIjogMSxcbiAgICAgICRiYWNrd2FyZHM6IDEsXG4gICAgICAkYm90aDogMSxcbiAgICAgICRlYXNlOiAxLFxuICAgICAgXCIkZWFzZS1pblwiOiAxLFxuICAgICAgXCIkZWFzZS1pbi1vdXRcIjogMSxcbiAgICAgIFwiJGVhc2Utb3V0XCI6IDEsXG4gICAgICAkZm9yd2FyZHM6IDEsXG4gICAgICAkaW5maW5pdGU6IDEsXG4gICAgICAkbGluZWFyOiAxLFxuICAgICAgJG5vbmU6IEluZmluaXR5LCAvLyBObyBtYXR0ZXIgaG93IG1hbnkgdGltZXMgeW91IHdyaXRlIG5vbmUsIGl0IHdpbGwgbmV2ZXIgYmUgYW4gYW5pbWF0aW9uIG5hbWVcbiAgICAgICRub3JtYWw6IDEsXG4gICAgICAkcGF1c2VkOiAxLFxuICAgICAgJHJldmVyc2U6IDEsXG4gICAgICAkcnVubmluZzogMSxcbiAgICAgIFwiJHN0ZXAtZW5kXCI6IDEsXG4gICAgICBcIiRzdGVwLXN0YXJ0XCI6IDEsXG4gICAgICAkaW5pdGlhbDogSW5maW5pdHksXG4gICAgICAkaW5oZXJpdDogSW5maW5pdHksXG4gICAgICAkdW5zZXQ6IEluZmluaXR5LFxuICAgIH07XG4gICAgbGV0IHBhcnNlZEFuaW1hdGlvbktleXdvcmRzID0ge307XG4gICAgbGV0IHN0ZXBzRnVuY3Rpb25Ob2RlID0gbnVsbDtcbiAgICBjb25zdCB2YWx1ZU5vZGVzID0gdmFsdWVQYXJzZXIoZGVjbGFyYXRpb24udmFsdWUpLndhbGsoKG5vZGUpID0+IHtcbiAgICAgIC8qIElmIGRpdi10b2tlbiBhcHBlYXJlZCAocmVwcmVzZW50cyBhcyBjb21tYSAnLCcpLCBhIHBvc3NpYmlsaXR5IG9mIGFuIGFuaW1hdGlvbi1rZXl3b3JkcyBzaG91bGQgYmUgcmVmbGVzaC4gKi9cbiAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiZGl2XCIpIHtcbiAgICAgICAgcGFyc2VkQW5pbWF0aW9uS2V5d29yZHMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJiBub2RlLnZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IFwic3RlcHNcIikge1xuICAgICAgICBzdGVwc0Z1bmN0aW9uTm9kZSA9IG5vZGU7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9XG4gICAgICAgIG5vZGUudHlwZSA9PT0gXCJ3b3JkXCIgJiZcbiAgICAgICAgIWlzV29yZEFGdW5jdGlvbkFyZ3VtZW50KG5vZGUsIHN0ZXBzRnVuY3Rpb25Ob2RlKVxuICAgICAgICAgID8gbm9kZS52YWx1ZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgOiBudWxsO1xuXG4gICAgICBsZXQgc2hvdWxkUGFyc2VBbmltYXRpb25OYW1lID0gZmFsc2U7XG5cbiAgICAgIGlmICh2YWx1ZSAmJiB2YWxpZElkZW50LnRlc3QodmFsdWUpKSB7XG4gICAgICAgIGlmIChcIiRcIiArIHZhbHVlIGluIGFuaW1hdGlvbktleXdvcmRzKSB7XG4gICAgICAgICAgcGFyc2VkQW5pbWF0aW9uS2V5d29yZHNbXCIkXCIgKyB2YWx1ZV0gPVxuICAgICAgICAgICAgXCIkXCIgKyB2YWx1ZSBpbiBwYXJzZWRBbmltYXRpb25LZXl3b3Jkc1xuICAgICAgICAgICAgICA/IHBhcnNlZEFuaW1hdGlvbktleXdvcmRzW1wiJFwiICsgdmFsdWVdICsgMVxuICAgICAgICAgICAgICA6IDA7XG5cbiAgICAgICAgICBzaG91bGRQYXJzZUFuaW1hdGlvbk5hbWUgPVxuICAgICAgICAgICAgcGFyc2VkQW5pbWF0aW9uS2V5d29yZHNbXCIkXCIgKyB2YWx1ZV0gPj1cbiAgICAgICAgICAgIGFuaW1hdGlvbktleXdvcmRzW1wiJFwiICsgdmFsdWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNob3VsZFBhcnNlQW5pbWF0aW9uTmFtZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3ViQ29udGV4dCA9IHtcbiAgICAgICAgb3B0aW9uczogY29udGV4dC5vcHRpb25zLFxuICAgICAgICBnbG9iYWw6IGNvbnRleHQuZ2xvYmFsLFxuICAgICAgICBsb2NhbGl6ZU5leHRJdGVtOiBzaG91bGRQYXJzZUFuaW1hdGlvbk5hbWUgJiYgIWNvbnRleHQuZ2xvYmFsLFxuICAgICAgICBsb2NhbEFsaWFzTWFwOiBjb250ZXh0LmxvY2FsQWxpYXNNYXAsXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGxvY2FsaXplRGVjbE5vZGUobm9kZSwgc3ViQ29udGV4dCk7XG4gICAgfSk7XG5cbiAgICBkZWNsYXJhdGlvbi52YWx1ZSA9IHZhbHVlTm9kZXMudG9TdHJpbmcoKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGlzQW5pbWF0aW9uTmFtZSA9IC9hbmltYXRpb24oLW5hbWUpPyQvaS50ZXN0KGRlY2xhcmF0aW9uLnByb3ApO1xuXG4gIGlmIChpc0FuaW1hdGlvbk5hbWUpIHtcbiAgICByZXR1cm4gbG9jYWxpemVEZWNsYXJhdGlvblZhbHVlcyh0cnVlLCBkZWNsYXJhdGlvbiwgY29udGV4dCk7XG4gIH1cblxuICBjb25zdCBoYXNVcmwgPSAvdXJsXFwoL2kudGVzdChkZWNsYXJhdGlvbi52YWx1ZSk7XG5cbiAgaWYgKGhhc1VybCkge1xuICAgIHJldHVybiBsb2NhbGl6ZURlY2xhcmF0aW9uVmFsdWVzKGZhbHNlLCBkZWNsYXJhdGlvbiwgY29udGV4dCk7XG4gIH1cbn1cblxuc3JjJDQuZXhwb3J0cyA9IChvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKFxuICAgIG9wdGlvbnMgJiZcbiAgICBvcHRpb25zLm1vZGUgJiZcbiAgICBvcHRpb25zLm1vZGUgIT09IFwiZ2xvYmFsXCIgJiZcbiAgICBvcHRpb25zLm1vZGUgIT09IFwibG9jYWxcIiAmJlxuICAgIG9wdGlvbnMubW9kZSAhPT0gXCJwdXJlXCJcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ29wdGlvbnMubW9kZSBtdXN0IGJlIGVpdGhlciBcImdsb2JhbFwiLCBcImxvY2FsXCIgb3IgXCJwdXJlXCIgKGRlZmF1bHQgXCJsb2NhbFwiKSdcbiAgICApO1xuICB9XG5cbiAgY29uc3QgcHVyZU1vZGUgPSBvcHRpb25zICYmIG9wdGlvbnMubW9kZSA9PT0gXCJwdXJlXCI7XG4gIGNvbnN0IGdsb2JhbE1vZGUgPSBvcHRpb25zICYmIG9wdGlvbnMubW9kZSA9PT0gXCJnbG9iYWxcIjtcblxuICByZXR1cm4ge1xuICAgIHBvc3Rjc3NQbHVnaW46IFwicG9zdGNzcy1tb2R1bGVzLWxvY2FsLWJ5LWRlZmF1bHRcIixcbiAgICBwcmVwYXJlKCkge1xuICAgICAgY29uc3QgbG9jYWxBbGlhc01hcCA9IG5ldyBNYXAoKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgT25jZShyb290KSB7XG4gICAgICAgICAgY29uc3QgeyBpY3NzSW1wb3J0cyB9ID0gZXh0cmFjdElDU1Mocm9vdCwgZmFsc2UpO1xuXG4gICAgICAgICAgT2JqZWN0LmtleXMoaWNzc0ltcG9ydHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoaWNzc0ltcG9ydHNba2V5XSkuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICAgICAgICBsb2NhbEFsaWFzTWFwLnNldChwcm9wLCBpY3NzSW1wb3J0c1trZXldW3Byb3BdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcm9vdC53YWxrQXRSdWxlcygoYXRSdWxlKSA9PiB7XG4gICAgICAgICAgICBpZiAoL2tleWZyYW1lcyQvaS50ZXN0KGF0UnVsZS5uYW1lKSkge1xuICAgICAgICAgICAgICBjb25zdCBnbG9iYWxNYXRjaCA9IC9eXFxzKjpnbG9iYWxcXHMqXFwoKC4rKVxcKVxccyokLy5leGVjKFxuICAgICAgICAgICAgICAgIGF0UnVsZS5wYXJhbXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY29uc3QgbG9jYWxNYXRjaCA9IC9eXFxzKjpsb2NhbFxccypcXCgoLispXFwpXFxzKiQvLmV4ZWMoXG4gICAgICAgICAgICAgICAgYXRSdWxlLnBhcmFtc1xuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIGxldCBnbG9iYWxLZXlmcmFtZXMgPSBnbG9iYWxNb2RlO1xuXG4gICAgICAgICAgICAgIGlmIChnbG9iYWxNYXRjaCkge1xuICAgICAgICAgICAgICAgIGlmIChwdXJlTW9kZSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgYXRSdWxlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkBrZXlmcmFtZXMgOmdsb2JhbCguLi4pIGlzIG5vdCBhbGxvd2VkIGluIHB1cmUgbW9kZVwiXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhdFJ1bGUucGFyYW1zID0gZ2xvYmFsTWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgZ2xvYmFsS2V5ZnJhbWVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChsb2NhbE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgYXRSdWxlLnBhcmFtcyA9IGxvY2FsTWF0Y2hbMF07XG4gICAgICAgICAgICAgICAgZ2xvYmFsS2V5ZnJhbWVzID0gZmFsc2U7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWdsb2JhbE1vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXRSdWxlLnBhcmFtcyAmJiAhbG9jYWxBbGlhc01hcC5oYXMoYXRSdWxlLnBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICAgIGF0UnVsZS5wYXJhbXMgPSBcIjpsb2NhbChcIiArIGF0UnVsZS5wYXJhbXMgKyBcIilcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBhdFJ1bGUud2Fsa0RlY2xzKChkZWNsYXJhdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGxvY2FsaXplRGVjbGFyYXRpb24oZGVjbGFyYXRpb24sIHtcbiAgICAgICAgICAgICAgICAgIGxvY2FsQWxpYXNNYXAsXG4gICAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgZ2xvYmFsOiBnbG9iYWxLZXlmcmFtZXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhdFJ1bGUubm9kZXMpIHtcbiAgICAgICAgICAgICAgYXRSdWxlLm5vZGVzLmZvckVhY2goKGRlY2xhcmF0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9uLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgICAgICAgICAgICAgICBsb2NhbGl6ZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsQWxpYXNNYXAsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbDogZ2xvYmFsTW9kZSxcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByb290LndhbGtSdWxlcygocnVsZSkgPT4ge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBydWxlLnBhcmVudCAmJlxuICAgICAgICAgICAgICBydWxlLnBhcmVudC50eXBlID09PSBcImF0cnVsZVwiICYmXG4gICAgICAgICAgICAgIC9rZXlmcmFtZXMkL2kudGVzdChydWxlLnBhcmVudC5uYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIC8vIGlnbm9yZSBrZXlmcmFtZSBydWxlc1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBsb2NhbGl6ZU5vZGUocnVsZSwgb3B0aW9ucy5tb2RlLCBsb2NhbEFsaWFzTWFwKTtcblxuICAgICAgICAgICAgY29udGV4dC5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnRleHQubG9jYWxBbGlhc01hcCA9IGxvY2FsQWxpYXNNYXA7XG5cbiAgICAgICAgICAgIGlmIChwdXJlTW9kZSAmJiBjb250ZXh0Lmhhc1B1cmVHbG9iYWxzKSB7XG4gICAgICAgICAgICAgIHRocm93IHJ1bGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgJ1NlbGVjdG9yIFwiJyArXG4gICAgICAgICAgICAgICAgICBydWxlLnNlbGVjdG9yICtcbiAgICAgICAgICAgICAgICAgICdcIiBpcyBub3QgcHVyZSAnICtcbiAgICAgICAgICAgICAgICAgIFwiKHB1cmUgc2VsZWN0b3JzIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgbG9jYWwgY2xhc3Mgb3IgaWQpXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcnVsZS5zZWxlY3RvciA9IGNvbnRleHQuc2VsZWN0b3I7XG5cbiAgICAgICAgICAgIC8vIExlc3Mtc3ludGF4IG1peGlucyBwYXJzZSBhcyBydWxlcyB3aXRoIG5vIG5vZGVzXG4gICAgICAgICAgICBpZiAocnVsZS5ub2Rlcykge1xuICAgICAgICAgICAgICBydWxlLm5vZGVzLmZvckVhY2goKGRlY2xhcmF0aW9uKSA9PlxuICAgICAgICAgICAgICAgIGxvY2FsaXplRGVjbGFyYXRpb24oZGVjbGFyYXRpb24sIGNvbnRleHQpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0sXG4gIH07XG59O1xuc3JjJDQuZXhwb3J0cy5wb3N0Y3NzID0gdHJ1ZTtcblxudmFyIHNyYyQyID0ge2V4cG9ydHM6IHt9fTtcblxuY29uc3QgUEVSTUFORU5UX01BUktFUiA9IDI7XG5jb25zdCBURU1QT1JBUllfTUFSS0VSID0gMTtcblxuZnVuY3Rpb24gY3JlYXRlRXJyb3Iobm9kZSwgZ3JhcGgpIHtcbiAgY29uc3QgZXIgPSBuZXcgRXJyb3IoXCJOb25kZXRlcm1pbmlzdGljIGltcG9ydCdzIG9yZGVyXCIpO1xuXG4gIGNvbnN0IHJlbGF0ZWQgPSBncmFwaFtub2RlXTtcbiAgY29uc3QgcmVsYXRlZE5vZGUgPSByZWxhdGVkLmZpbmQoXG4gICAgKHJlbGF0ZWROb2RlKSA9PiBncmFwaFtyZWxhdGVkTm9kZV0uaW5kZXhPZihub2RlKSA+IC0xXG4gICk7XG5cbiAgZXIubm9kZXMgPSBbbm9kZSwgcmVsYXRlZE5vZGVdO1xuXG4gIHJldHVybiBlcjtcbn1cblxuZnVuY3Rpb24gd2Fsa0dyYXBoKG5vZGUsIGdyYXBoLCBzdGF0ZSwgcmVzdWx0LCBzdHJpY3QpIHtcbiAgaWYgKHN0YXRlW25vZGVdID09PSBQRVJNQU5FTlRfTUFSS0VSKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHN0YXRlW25vZGVdID09PSBURU1QT1JBUllfTUFSS0VSKSB7XG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVycm9yKG5vZGUsIGdyYXBoKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBzdGF0ZVtub2RlXSA9IFRFTVBPUkFSWV9NQVJLRVI7XG5cbiAgY29uc3QgY2hpbGRyZW4gPSBncmFwaFtub2RlXTtcbiAgY29uc3QgbGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBlcnJvciA9IHdhbGtHcmFwaChjaGlsZHJlbltpXSwgZ3JhcGgsIHN0YXRlLCByZXN1bHQsIHN0cmljdCk7XG5cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlW25vZGVdID0gUEVSTUFORU5UX01BUktFUjtcblxuICByZXN1bHQucHVzaChub2RlKTtcbn1cblxuZnVuY3Rpb24gdG9wb2xvZ2ljYWxTb3J0JDEoZ3JhcGgsIHN0cmljdCkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3Qgc3RhdGUgPSB7fTtcblxuICBjb25zdCBub2RlcyA9IE9iamVjdC5rZXlzKGdyYXBoKTtcbiAgY29uc3QgbGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBlciA9IHdhbGtHcmFwaChub2Rlc1tpXSwgZ3JhcGgsIHN0YXRlLCByZXN1bHQsIHN0cmljdCk7XG5cbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmV0dXJuIGVyO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciB0b3BvbG9naWNhbFNvcnRfMSA9IHRvcG9sb2dpY2FsU29ydCQxO1xuXG5jb25zdCB0b3BvbG9naWNhbFNvcnQgPSB0b3BvbG9naWNhbFNvcnRfMTtcblxuY29uc3QgbWF0Y2hJbXBvcnRzJDEgPSAvXiguKz8pXFxzK2Zyb21cXHMrKD86XCIoW15cIl0rKVwifCcoW14nXSspJ3woZ2xvYmFsKSkkLztcbmNvbnN0IGljc3NJbXBvcnQgPSAvXjppbXBvcnRcXCgoPzpcIihbXlwiXSspXCJ8JyhbXiddKyknKVxcKS87XG5cbmNvbnN0IFZJU0lURURfTUFSS0VSID0gMTtcblxuLyoqXG4gKiA6aW1wb3J0KCdHJykge31cbiAqXG4gKiBSdWxlXG4gKiAgIGNvbXBvc2VzOiAuLi4gZnJvbSAnQSdcbiAqICAgY29tcG9zZXM6IC4uLiBmcm9tICdCJ1xuXG4gKiBSdWxlXG4gKiAgIGNvbXBvc2VzOiAuLi4gZnJvbSAnQSdcbiAqICAgY29tcG9zZXM6IC4uLiBmcm9tICdBJ1xuICogICBjb21wb3NlczogLi4uIGZyb20gJ0MnXG4gKlxuICogUmVzdWx0cyBpbjpcbiAqXG4gKiBncmFwaDoge1xuICogICBHOiBbXSxcbiAqICAgQTogW10sXG4gKiAgIEI6IFsnQSddLFxuICogICBDOiBbJ0EnXSxcbiAqIH1cbiAqL1xuZnVuY3Rpb24gYWRkSW1wb3J0VG9HcmFwaChpbXBvcnRJZCwgcGFyZW50SWQsIGdyYXBoLCB2aXNpdGVkKSB7XG4gIGNvbnN0IHNpYmxpbmdzSWQgPSBwYXJlbnRJZCArIFwiX1wiICsgXCJzaWJsaW5nc1wiO1xuICBjb25zdCB2aXNpdGVkSWQgPSBwYXJlbnRJZCArIFwiX1wiICsgaW1wb3J0SWQ7XG5cbiAgaWYgKHZpc2l0ZWRbdmlzaXRlZElkXSAhPT0gVklTSVRFRF9NQVJLRVIpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmlzaXRlZFtzaWJsaW5nc0lkXSkpIHtcbiAgICAgIHZpc2l0ZWRbc2libGluZ3NJZF0gPSBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBzaWJsaW5ncyA9IHZpc2l0ZWRbc2libGluZ3NJZF07XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShncmFwaFtpbXBvcnRJZF0pKSB7XG4gICAgICBncmFwaFtpbXBvcnRJZF0gPSBncmFwaFtpbXBvcnRJZF0uY29uY2F0KHNpYmxpbmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JhcGhbaW1wb3J0SWRdID0gc2libGluZ3Muc2xpY2UoKTtcbiAgICB9XG5cbiAgICB2aXNpdGVkW3Zpc2l0ZWRJZF0gPSBWSVNJVEVEX01BUktFUjtcblxuICAgIHNpYmxpbmdzLnB1c2goaW1wb3J0SWQpO1xuICB9XG59XG5cbnNyYyQyLmV4cG9ydHMgPSAob3B0aW9ucyA9IHt9KSA9PiB7XG4gIGxldCBpbXBvcnRJbmRleCA9IDA7XG4gIGNvbnN0IGNyZWF0ZUltcG9ydGVkTmFtZSA9XG4gICAgdHlwZW9mIG9wdGlvbnMuY3JlYXRlSW1wb3J0ZWROYW1lICE9PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gKGltcG9ydE5hbWUgLyosIHBhdGgqLykgPT5cbiAgICAgICAgICBgaV9faW1wb3J0ZWRfJHtpbXBvcnROYW1lLnJlcGxhY2UoL1xcVy9nLCBcIl9cIil9XyR7aW1wb3J0SW5kZXgrK31gXG4gICAgICA6IG9wdGlvbnMuY3JlYXRlSW1wb3J0ZWROYW1lO1xuICBjb25zdCBmYWlsT25Xcm9uZ09yZGVyID0gb3B0aW9ucy5mYWlsT25Xcm9uZ09yZGVyO1xuXG4gIHJldHVybiB7XG4gICAgcG9zdGNzc1BsdWdpbjogXCJwb3N0Y3NzLW1vZHVsZXMtZXh0cmFjdC1pbXBvcnRzXCIsXG4gICAgcHJlcGFyZSgpIHtcbiAgICAgIGNvbnN0IGdyYXBoID0ge307XG4gICAgICBjb25zdCB2aXNpdGVkID0ge307XG4gICAgICBjb25zdCBleGlzdGluZ0ltcG9ydHMgPSB7fTtcbiAgICAgIGNvbnN0IGltcG9ydERlY2xzID0ge307XG4gICAgICBjb25zdCBpbXBvcnRzID0ge307XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIE9uY2Uocm9vdCwgcG9zdGNzcykge1xuICAgICAgICAgIC8vIENoZWNrIHRoZSBleGlzdGluZyBpbXBvcnRzIG9yZGVyIGFuZCBzYXZlIHJlZnNcbiAgICAgICAgICByb290LndhbGtSdWxlcygocnVsZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGljc3NJbXBvcnQuZXhlYyhydWxlLnNlbGVjdG9yKTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgWywgLyptYXRjaCovIGRvdWJsZVF1b3RlUGF0aCwgc2luZ2xlUXVvdGVQYXRoXSA9IG1hdGNoZXM7XG4gICAgICAgICAgICAgIGNvbnN0IGltcG9ydFBhdGggPSBkb3VibGVRdW90ZVBhdGggfHwgc2luZ2xlUXVvdGVQYXRoO1xuXG4gICAgICAgICAgICAgIGFkZEltcG9ydFRvR3JhcGgoaW1wb3J0UGF0aCwgXCJyb290XCIsIGdyYXBoLCB2aXNpdGVkKTtcblxuICAgICAgICAgICAgICBleGlzdGluZ0ltcG9ydHNbaW1wb3J0UGF0aF0gPSBydWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcm9vdC53YWxrRGVjbHMoL15jb21wb3NlcyQvLCAoZGVjbGFyYXRpb24pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBkZWNsYXJhdGlvbi52YWx1ZS5tYXRjaChtYXRjaEltcG9ydHMkMSk7XG5cbiAgICAgICAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB0bXBTeW1ib2xzO1xuICAgICAgICAgICAgbGV0IFtcbiAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICAvKm1hdGNoKi8gc3ltYm9scyxcbiAgICAgICAgICAgICAgZG91YmxlUXVvdGVQYXRoLFxuICAgICAgICAgICAgICBzaW5nbGVRdW90ZVBhdGgsXG4gICAgICAgICAgICAgIGdsb2JhbCxcbiAgICAgICAgICAgIF0gPSBtYXRjaGVzO1xuXG4gICAgICAgICAgICBpZiAoZ2xvYmFsKSB7XG4gICAgICAgICAgICAgIC8vIENvbXBvc2luZyBnbG9iYWxzIHNpbXBseSBtZWFucyBjaGFuZ2luZyB0aGVzZSBjbGFzc2VzIHRvIHdyYXAgdGhlbSBpbiBnbG9iYWwobmFtZSlcbiAgICAgICAgICAgICAgdG1wU3ltYm9scyA9IHN5bWJvbHMuc3BsaXQoL1xccysvKS5tYXAoKHMpID0+IGBnbG9iYWwoJHtzfSlgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IGltcG9ydFBhdGggPSBkb3VibGVRdW90ZVBhdGggfHwgc2luZ2xlUXVvdGVQYXRoO1xuXG4gICAgICAgICAgICAgIGxldCBwYXJlbnQgPSBkZWNsYXJhdGlvbi5wYXJlbnQ7XG4gICAgICAgICAgICAgIGxldCBwYXJlbnRJbmRleGVzID0gXCJcIjtcblxuICAgICAgICAgICAgICB3aGlsZSAocGFyZW50LnR5cGUgIT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50SW5kZXhlcyA9XG4gICAgICAgICAgICAgICAgICBwYXJlbnQucGFyZW50LmluZGV4KHBhcmVudCkgKyBcIl9cIiArIHBhcmVudEluZGV4ZXM7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0b3IgfSA9IGRlY2xhcmF0aW9uLnBhcmVudDtcbiAgICAgICAgICAgICAgY29uc3QgcGFyZW50UnVsZSA9IGBfJHtwYXJlbnRJbmRleGVzfSR7c2VsZWN0b3J9YDtcblxuICAgICAgICAgICAgICBhZGRJbXBvcnRUb0dyYXBoKGltcG9ydFBhdGgsIHBhcmVudFJ1bGUsIGdyYXBoLCB2aXNpdGVkKTtcblxuICAgICAgICAgICAgICBpbXBvcnREZWNsc1tpbXBvcnRQYXRoXSA9IGRlY2xhcmF0aW9uO1xuICAgICAgICAgICAgICBpbXBvcnRzW2ltcG9ydFBhdGhdID0gaW1wb3J0c1tpbXBvcnRQYXRoXSB8fCB7fTtcblxuICAgICAgICAgICAgICB0bXBTeW1ib2xzID0gc3ltYm9scy5zcGxpdCgvXFxzKy8pLm1hcCgocykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghaW1wb3J0c1tpbXBvcnRQYXRoXVtzXSkge1xuICAgICAgICAgICAgICAgICAgaW1wb3J0c1tpbXBvcnRQYXRoXVtzXSA9IGNyZWF0ZUltcG9ydGVkTmFtZShzLCBpbXBvcnRQYXRoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW1wb3J0c1tpbXBvcnRQYXRoXVtzXTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlY2xhcmF0aW9uLnZhbHVlID0gdG1wU3ltYm9scy5qb2luKFwiIFwiKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNvbnN0IGltcG9ydHNPcmRlciA9IHRvcG9sb2dpY2FsU29ydChncmFwaCwgZmFpbE9uV3JvbmdPcmRlcik7XG5cbiAgICAgICAgICBpZiAoaW1wb3J0c09yZGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGltcG9ydFBhdGggPSBpbXBvcnRzT3JkZXIubm9kZXMuZmluZCgoaW1wb3J0UGF0aCkgPT5cbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICAgICAgICBpbXBvcnREZWNscy5oYXNPd25Qcm9wZXJ0eShpbXBvcnRQYXRoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGRlY2wgPSBpbXBvcnREZWNsc1tpbXBvcnRQYXRoXTtcblxuICAgICAgICAgICAgdGhyb3cgZGVjbC5lcnJvcihcbiAgICAgICAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBvcmRlciBvZiBjb21wb3NlZCBtb2R1bGVzIFwiICtcbiAgICAgICAgICAgICAgICBpbXBvcnRzT3JkZXIubm9kZXNcbiAgICAgICAgICAgICAgICAgIC5tYXAoKGltcG9ydFBhdGgpID0+IFwiYFwiICsgaW1wb3J0UGF0aCArIFwiYFwiKVxuICAgICAgICAgICAgICAgICAgLmpvaW4oXCIsIFwiKSArXG4gICAgICAgICAgICAgICAgXCIuXCIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwbHVnaW46IFwicG9zdGNzcy1tb2R1bGVzLWV4dHJhY3QtaW1wb3J0c1wiLFxuICAgICAgICAgICAgICAgIHdvcmQ6IFwiY29tcG9zZXNcIixcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgbGFzdEltcG9ydFJ1bGU7XG5cbiAgICAgICAgICBpbXBvcnRzT3JkZXIuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW1wb3J0ZWRTeW1ib2xzID0gaW1wb3J0c1twYXRoXTtcbiAgICAgICAgICAgIGxldCBydWxlID0gZXhpc3RpbmdJbXBvcnRzW3BhdGhdO1xuXG4gICAgICAgICAgICBpZiAoIXJ1bGUgJiYgaW1wb3J0ZWRTeW1ib2xzKSB7XG4gICAgICAgICAgICAgIHJ1bGUgPSBwb3N0Y3NzLnJ1bGUoe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBgOmltcG9ydChcIiR7cGF0aH1cIilgLFxuICAgICAgICAgICAgICAgIHJhd3M6IHsgYWZ0ZXI6IFwiXFxuXCIgfSxcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKGxhc3RJbXBvcnRSdWxlKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5pbnNlcnRBZnRlcihsYXN0SW1wb3J0UnVsZSwgcnVsZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcm9vdC5wcmVwZW5kKHJ1bGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3RJbXBvcnRSdWxlID0gcnVsZTtcblxuICAgICAgICAgICAgaWYgKCFpbXBvcnRlZFN5bWJvbHMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhpbXBvcnRlZFN5bWJvbHMpLmZvckVhY2goKGltcG9ydGVkU3ltYm9sKSA9PiB7XG4gICAgICAgICAgICAgIHJ1bGUuYXBwZW5kKFxuICAgICAgICAgICAgICAgIHBvc3Rjc3MuZGVjbCh7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogaW1wb3J0ZWRTeW1ib2wsXG4gICAgICAgICAgICAgICAgICBwcm9wOiBpbXBvcnRlZFN5bWJvbHNbaW1wb3J0ZWRTeW1ib2xdLFxuICAgICAgICAgICAgICAgICAgcmF3czogeyBiZWZvcmU6IFwiXFxuICBcIiB9LFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSxcbiAgfTtcbn07XG5cbnNyYyQyLmV4cG9ydHMucG9zdGNzcyA9IHRydWU7XG5cbmNvbnN0IHNlbGVjdG9yUGFyc2VyID0gZGlzdC5leHBvcnRzO1xuXG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGdldFNpbmdsZUxvY2FsTmFtZXNGb3JDb21wb3Nlcyhyb290KSB7XG4gIHJldHVybiByb290Lm5vZGVzLm1hcCgobm9kZSkgPT4ge1xuICAgIGlmIChub2RlLnR5cGUgIT09IFwic2VsZWN0b3JcIiB8fCBub2RlLm5vZGVzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgY29tcG9zaXRpb24gaXMgb25seSBhbGxvd2VkIHdoZW4gc2VsZWN0b3IgaXMgc2luZ2xlIDpsb2NhbCBjbGFzcyBuYW1lIG5vdCBpbiBcIiR7cm9vdH1cImBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUubm9kZXNbMF07XG5cbiAgICBpZiAoXG4gICAgICBub2RlLnR5cGUgIT09IFwicHNldWRvXCIgfHxcbiAgICAgIG5vZGUudmFsdWUgIT09IFwiOmxvY2FsXCIgfHxcbiAgICAgIG5vZGUubm9kZXMubGVuZ3RoICE9PSAxXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdjb21wb3NpdGlvbiBpcyBvbmx5IGFsbG93ZWQgd2hlbiBzZWxlY3RvciBpcyBzaW5nbGUgOmxvY2FsIGNsYXNzIG5hbWUgbm90IGluIFwiJyArXG4gICAgICAgICAgcm9vdCArXG4gICAgICAgICAgJ1wiLCBcIicgK1xuICAgICAgICAgIG5vZGUgK1xuICAgICAgICAgICdcIiBpcyB3ZWlyZCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUuZmlyc3Q7XG5cbiAgICBpZiAobm9kZS50eXBlICE9PSBcInNlbGVjdG9yXCIgfHwgbm9kZS5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2NvbXBvc2l0aW9uIGlzIG9ubHkgYWxsb3dlZCB3aGVuIHNlbGVjdG9yIGlzIHNpbmdsZSA6bG9jYWwgY2xhc3MgbmFtZSBub3QgaW4gXCInICtcbiAgICAgICAgICByb290ICtcbiAgICAgICAgICAnXCIsIFwiJyArXG4gICAgICAgICAgbm9kZSArXG4gICAgICAgICAgJ1wiIGlzIHdlaXJkJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBub2RlID0gbm9kZS5maXJzdDtcblxuICAgIGlmIChub2RlLnR5cGUgIT09IFwiY2xhc3NcIikge1xuICAgICAgLy8gJ2lkJyBpcyBub3QgcG9zc2libGUsIGJlY2F1c2UgeW91IGNhbid0IGNvbXBvc2UgaWRzXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdjb21wb3NpdGlvbiBpcyBvbmx5IGFsbG93ZWQgd2hlbiBzZWxlY3RvciBpcyBzaW5nbGUgOmxvY2FsIGNsYXNzIG5hbWUgbm90IGluIFwiJyArXG4gICAgICAgICAgcm9vdCArXG4gICAgICAgICAgJ1wiLCBcIicgK1xuICAgICAgICAgIG5vZGUgK1xuICAgICAgICAgICdcIiBpcyB3ZWlyZCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gIH0pO1xufVxuXG5jb25zdCB3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiO1xuY29uc3QgdW5lc2NhcGVSZWdFeHAgPSBuZXcgUmVnRXhwKFxuICBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsXG4gIFwiaWdcIlxuKTtcblxuZnVuY3Rpb24gdW5lc2NhcGUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSh1bmVzY2FwZVJlZ0V4cCwgKF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlKSA9PiB7XG4gICAgY29uc3QgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuXG4gICAgLy8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcbiAgICAvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcbiAgICByZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZVxuICAgICAgPyBlc2NhcGVkXG4gICAgICA6IGhpZ2ggPCAwXG4gICAgICA/IC8vIEJNUCBjb2RlcG9pbnRcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShoaWdoICsgMHgxMDAwMClcbiAgICAgIDogLy8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG4gICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoKGhpZ2ggPj4gMTApIHwgMHhkODAwLCAoaGlnaCAmIDB4M2ZmKSB8IDB4ZGMwMCk7XG4gIH0pO1xufVxuXG5jb25zdCBwbHVnaW4gPSAob3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IGdlbmVyYXRlU2NvcGVkTmFtZSA9XG4gICAgKG9wdGlvbnMgJiYgb3B0aW9ucy5nZW5lcmF0ZVNjb3BlZE5hbWUpIHx8IHBsdWdpbi5nZW5lcmF0ZVNjb3BlZE5hbWU7XG4gIGNvbnN0IGdlbmVyYXRlRXhwb3J0RW50cnkgPVxuICAgIChvcHRpb25zICYmIG9wdGlvbnMuZ2VuZXJhdGVFeHBvcnRFbnRyeSkgfHwgcGx1Z2luLmdlbmVyYXRlRXhwb3J0RW50cnk7XG4gIGNvbnN0IGV4cG9ydEdsb2JhbHMgPSBvcHRpb25zICYmIG9wdGlvbnMuZXhwb3J0R2xvYmFscztcblxuICByZXR1cm4ge1xuICAgIHBvc3Rjc3NQbHVnaW46IFwicG9zdGNzcy1tb2R1bGVzLXNjb3BlXCIsXG4gICAgT25jZShyb290LCB7IHJ1bGUgfSkge1xuICAgICAgY29uc3QgZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIGZ1bmN0aW9uIGV4cG9ydFNjb3BlZE5hbWUobmFtZSwgcmF3TmFtZSkge1xuICAgICAgICBjb25zdCBzY29wZWROYW1lID0gZ2VuZXJhdGVTY29wZWROYW1lKFxuICAgICAgICAgIHJhd05hbWUgPyByYXdOYW1lIDogbmFtZSxcbiAgICAgICAgICByb290LnNvdXJjZS5pbnB1dC5mcm9tLFxuICAgICAgICAgIHJvb3Quc291cmNlLmlucHV0LmNzc1xuICAgICAgICApO1xuICAgICAgICBjb25zdCBleHBvcnRFbnRyeSA9IGdlbmVyYXRlRXhwb3J0RW50cnkoXG4gICAgICAgICAgcmF3TmFtZSA/IHJhd05hbWUgOiBuYW1lLFxuICAgICAgICAgIHNjb3BlZE5hbWUsXG4gICAgICAgICAgcm9vdC5zb3VyY2UuaW5wdXQuZnJvbSxcbiAgICAgICAgICByb290LnNvdXJjZS5pbnB1dC5jc3NcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBleHBvcnRFbnRyeTtcblxuICAgICAgICBleHBvcnRzW2tleV0gPSBleHBvcnRzW2tleV0gfHwgW107XG5cbiAgICAgICAgaWYgKGV4cG9ydHNba2V5XS5pbmRleE9mKHZhbHVlKSA8IDApIHtcbiAgICAgICAgICBleHBvcnRzW2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2NvcGVkTmFtZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbG9jYWxpemVOb2RlKG5vZGUpIHtcbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwic2VsZWN0b3JcIjpcbiAgICAgICAgICAgIG5vZGUubm9kZXMgPSBub2RlLm1hcChsb2NhbGl6ZU5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0b3JQYXJzZXIuY2xhc3NOYW1lKHtcbiAgICAgICAgICAgICAgdmFsdWU6IGV4cG9ydFNjb3BlZE5hbWUoXG4gICAgICAgICAgICAgICAgbm9kZS52YWx1ZSxcbiAgICAgICAgICAgICAgICBub2RlLnJhd3MgJiYgbm9kZS5yYXdzLnZhbHVlID8gbm9kZS5yYXdzLnZhbHVlIDogbnVsbFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgY2FzZSBcImlkXCI6IHtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RvclBhcnNlci5pZCh7XG4gICAgICAgICAgICAgIHZhbHVlOiBleHBvcnRTY29wZWROYW1lKFxuICAgICAgICAgICAgICAgIG5vZGUudmFsdWUsXG4gICAgICAgICAgICAgICAgbm9kZS5yYXdzICYmIG5vZGUucmF3cy52YWx1ZSA/IG5vZGUucmF3cy52YWx1ZSA6IG51bGxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgJHtub2RlLnR5cGV9IChcIiR7bm9kZX1cIikgaXMgbm90IGFsbG93ZWQgaW4gYSA6bG9jYWwgYmxvY2tgXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRyYXZlcnNlTm9kZShub2RlKSB7XG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcInBzZXVkb1wiOlxuICAgICAgICAgICAgaWYgKG5vZGUudmFsdWUgPT09IFwiOmxvY2FsXCIpIHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGNvbW1hIChcIixcIikgaW4gOmxvY2FsIGJsb2NrJyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGxvY2FsaXplTm9kZShub2RlLmZpcnN0KTtcbiAgICAgICAgICAgICAgLy8gbW92ZSB0aGUgc3BhY2VzIHRoYXQgd2VyZSBhcm91bmQgdGhlIHBzdWVkbyBzZWxlY3RvciB0byB0aGUgZmlyc3RcbiAgICAgICAgICAgICAgLy8gbm9uLWNvbnRhaW5lciBub2RlXG4gICAgICAgICAgICAgIHNlbGVjdG9yLmZpcnN0LnNwYWNlcyA9IG5vZGUuc3BhY2VzO1xuXG4gICAgICAgICAgICAgIGNvbnN0IG5leHROb2RlID0gbm9kZS5uZXh0KCk7XG5cbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG5leHROb2RlICYmXG4gICAgICAgICAgICAgICAgbmV4dE5vZGUudHlwZSA9PT0gXCJjb21iaW5hdG9yXCIgJiZcbiAgICAgICAgICAgICAgICBuZXh0Tm9kZS52YWx1ZSA9PT0gXCIgXCIgJiZcbiAgICAgICAgICAgICAgICAvXFxcXFtBLUYwLTldezEsNn0kLy50ZXN0KHNlbGVjdG9yLmxhc3QudmFsdWUpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yLmxhc3Quc3BhY2VzLmFmdGVyID0gXCIgXCI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBub2RlLnJlcGxhY2VXaXRoKHNlbGVjdG9yKTtcblxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgIGNhc2UgXCJyb290XCI6XG4gICAgICAgICAgY2FzZSBcInNlbGVjdG9yXCI6IHtcbiAgICAgICAgICAgIG5vZGUuZWFjaCh0cmF2ZXJzZU5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJpZFwiOlxuICAgICAgICAgIGNhc2UgXCJjbGFzc1wiOlxuICAgICAgICAgICAgaWYgKGV4cG9ydEdsb2JhbHMpIHtcbiAgICAgICAgICAgICAgZXhwb3J0c1tub2RlLnZhbHVlXSA9IFtub2RlLnZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIGFueSA6aW1wb3J0IGFuZCByZW1lbWJlciBpbXBvcnRlZCBuYW1lc1xuICAgICAgY29uc3QgaW1wb3J0ZWROYW1lcyA9IHt9O1xuXG4gICAgICByb290LndhbGtSdWxlcygvXjppbXBvcnRcXCguK1xcKSQvLCAocnVsZSkgPT4ge1xuICAgICAgICBydWxlLndhbGtEZWNscygoZGVjbCkgPT4ge1xuICAgICAgICAgIGltcG9ydGVkTmFtZXNbZGVjbC5wcm9wXSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEZpbmQgYW55IDpsb2NhbCBzZWxlY3RvcnNcbiAgICAgIHJvb3Qud2Fsa1J1bGVzKChydWxlKSA9PiB7XG4gICAgICAgIGxldCBwYXJzZWRTZWxlY3RvciA9IHNlbGVjdG9yUGFyc2VyKCkuYXN0U3luYyhydWxlKTtcblxuICAgICAgICBydWxlLnNlbGVjdG9yID0gdHJhdmVyc2VOb2RlKHBhcnNlZFNlbGVjdG9yLmNsb25lKCkpLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgcnVsZS53YWxrRGVjbHMoL2NvbXBvc2VzfGNvbXBvc2Utd2l0aC9pLCAoZGVjbCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGxvY2FsTmFtZXMgPSBnZXRTaW5nbGVMb2NhbE5hbWVzRm9yQ29tcG9zZXMocGFyc2VkU2VsZWN0b3IpO1xuICAgICAgICAgIGNvbnN0IGNsYXNzZXMgPSBkZWNsLnZhbHVlLnNwbGl0KC9cXHMrLyk7XG5cbiAgICAgICAgICBjbGFzc2VzLmZvckVhY2goKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZ2xvYmFsID0gL15nbG9iYWxcXCgoW14pXSspXFwpJC8uZXhlYyhjbGFzc05hbWUpO1xuXG4gICAgICAgICAgICBpZiAoZ2xvYmFsKSB7XG4gICAgICAgICAgICAgIGxvY2FsTmFtZXMuZm9yRWFjaCgoZXhwb3J0ZWROYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgZXhwb3J0c1tleHBvcnRlZE5hbWVdLnB1c2goZ2xvYmFsWzFdKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhhc093blByb3BlcnR5LmNhbGwoaW1wb3J0ZWROYW1lcywgY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgICBsb2NhbE5hbWVzLmZvckVhY2goKGV4cG9ydGVkTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGV4cG9ydHNbZXhwb3J0ZWROYW1lXS5wdXNoKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgICAgbG9jYWxOYW1lcy5mb3JFYWNoKChleHBvcnRlZE5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBleHBvcnRzW2NsYXNzTmFtZV0uZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgZXhwb3J0c1tleHBvcnRlZE5hbWVdLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgZGVjbC5lcnJvcihcbiAgICAgICAgICAgICAgICBgcmVmZXJlbmNlZCBjbGFzcyBuYW1lIFwiJHtjbGFzc05hbWV9XCIgaW4gJHtkZWNsLnByb3B9IG5vdCBmb3VuZGBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGRlY2wucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZpbmQgYW55IDpsb2NhbCB2YWx1ZXNcbiAgICAgICAgcnVsZS53YWxrRGVjbHMoKGRlY2wpID0+IHtcbiAgICAgICAgICBpZiAoIS86bG9jYWxcXHMqXFwoKC4rPylcXCkvLnRlc3QoZGVjbC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgdG9rZW5zID0gZGVjbC52YWx1ZS5zcGxpdCgvKCx8J1teJ10qJ3xcIlteXCJdKlwiKS8pO1xuXG4gICAgICAgICAgdG9rZW5zID0gdG9rZW5zLm1hcCgodG9rZW4sIGlkeCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlkeCA9PT0gMCB8fCB0b2tlbnNbaWR4IC0gMV0gPT09IFwiLFwiKSB7XG4gICAgICAgICAgICAgIGxldCByZXN1bHQgPSB0b2tlbjtcblxuICAgICAgICAgICAgICBjb25zdCBsb2NhbE1hdGNoID0gLzpsb2NhbFxccypcXCgoLis/KVxcKS8uZXhlYyh0b2tlbik7XG5cbiAgICAgICAgICAgICAgaWYgKGxvY2FsTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dCA9IGxvY2FsTWF0Y2guaW5wdXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hQYXR0ZXJuID0gbG9jYWxNYXRjaFswXTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaFZhbCA9IGxvY2FsTWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsID0gZXhwb3J0U2NvcGVkTmFtZShtYXRjaFZhbCk7XG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbnB1dC5yZXBsYWNlKG1hdGNoUGF0dGVybiwgbmV3VmFsKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZGVjbC52YWx1ZSA9IHRva2Vucy5qb2luKFwiXCIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBGaW5kIGFueSA6bG9jYWwga2V5ZnJhbWVzXG4gICAgICByb290LndhbGtBdFJ1bGVzKC9rZXlmcmFtZXMkL2ksIChhdFJ1bGUpID0+IHtcbiAgICAgICAgY29uc3QgbG9jYWxNYXRjaCA9IC9eXFxzKjpsb2NhbFxccypcXCgoLis/KVxcKVxccyokLy5leGVjKGF0UnVsZS5wYXJhbXMpO1xuXG4gICAgICAgIGlmICghbG9jYWxNYXRjaCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0UnVsZS5wYXJhbXMgPSBleHBvcnRTY29wZWROYW1lKGxvY2FsTWF0Y2hbMV0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIElmIHdlIGZvdW5kIGFueSA6bG9jYWxzLCBpbnNlcnQgYW4gOmV4cG9ydCBydWxlXG4gICAgICBjb25zdCBleHBvcnRlZE5hbWVzID0gT2JqZWN0LmtleXMoZXhwb3J0cyk7XG5cbiAgICAgIGlmIChleHBvcnRlZE5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgZXhwb3J0UnVsZSA9IHJ1bGUoeyBzZWxlY3RvcjogXCI6ZXhwb3J0XCIgfSk7XG5cbiAgICAgICAgZXhwb3J0ZWROYW1lcy5mb3JFYWNoKChleHBvcnRlZE5hbWUpID0+XG4gICAgICAgICAgZXhwb3J0UnVsZS5hcHBlbmQoe1xuICAgICAgICAgICAgcHJvcDogZXhwb3J0ZWROYW1lLFxuICAgICAgICAgICAgdmFsdWU6IGV4cG9ydHNbZXhwb3J0ZWROYW1lXS5qb2luKFwiIFwiKSxcbiAgICAgICAgICAgIHJhd3M6IHsgYmVmb3JlOiBcIlxcbiAgXCIgfSxcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIHJvb3QuYXBwZW5kKGV4cG9ydFJ1bGUpO1xuICAgICAgfVxuICAgIH0sXG4gIH07XG59O1xuXG5wbHVnaW4ucG9zdGNzcyA9IHRydWU7XG5cbnBsdWdpbi5nZW5lcmF0ZVNjb3BlZE5hbWUgPSBmdW5jdGlvbiAobmFtZSwgcGF0aCkge1xuICBjb25zdCBzYW5pdGlzZWRQYXRoID0gcGF0aFxuICAgIC5yZXBsYWNlKC9cXC5bXi4vXFxcXF0rJC8sIFwiXCIpXG4gICAgLnJlcGxhY2UoL1tcXFdfXSsvZywgXCJfXCIpXG4gICAgLnJlcGxhY2UoL15ffF8kL2csIFwiXCIpO1xuXG4gIHJldHVybiBgXyR7c2FuaXRpc2VkUGF0aH1fXyR7bmFtZX1gLnRyaW0oKTtcbn07XG5cbnBsdWdpbi5nZW5lcmF0ZUV4cG9ydEVudHJ5ID0gZnVuY3Rpb24gKG5hbWUsIHNjb3BlZE5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBrZXk6IHVuZXNjYXBlKG5hbWUpLFxuICAgIHZhbHVlOiB1bmVzY2FwZShzY29wZWROYW1lKSxcbiAgfTtcbn07XG5cbnZhciBzcmMkMSA9IHBsdWdpbjtcblxudmFyIHNyYyA9IHtleHBvcnRzOiB7fX07XG5cbmNvbnN0IElDU1NVdGlscyA9IHNyYyQzO1xuXG5jb25zdCBtYXRjaEltcG9ydHMgPSAvXiguKz98XFwoW1xcc1xcU10rP1xcKSlcXHMrZnJvbVxccysoXCJbXlwiXSpcInwnW14nXSonfFtcXHctXSspJC87XG5jb25zdCBtYXRjaFZhbHVlRGVmaW5pdGlvbiA9IC8oPzpcXHMrfF4pKFtcXHctXSspOj8oLio/KSQvO1xuY29uc3QgbWF0Y2hJbXBvcnQgPSAvXihbXFx3LV0rKSg/Olxccythc1xccysoW1xcdy1dKykpPy87XG5cbnNyYy5leHBvcnRzID0gKG9wdGlvbnMpID0+IHtcbiAgbGV0IGltcG9ydEluZGV4ID0gMDtcbiAgY29uc3QgY3JlYXRlSW1wb3J0ZWROYW1lID1cbiAgICAob3B0aW9ucyAmJiBvcHRpb25zLmNyZWF0ZUltcG9ydGVkTmFtZSkgfHxcbiAgICAoKGltcG9ydE5hbWUgLyosIHBhdGgqLykgPT5cbiAgICAgIGBpX19jb25zdF8ke2ltcG9ydE5hbWUucmVwbGFjZSgvXFxXL2csIFwiX1wiKX1fJHtpbXBvcnRJbmRleCsrfWApO1xuXG4gIHJldHVybiB7XG4gICAgcG9zdGNzc1BsdWdpbjogXCJwb3N0Y3NzLW1vZHVsZXMtdmFsdWVzXCIsXG4gICAgcHJlcGFyZShyZXN1bHQpIHtcbiAgICAgIGNvbnN0IGltcG9ydEFsaWFzZXMgPSBbXTtcbiAgICAgIGNvbnN0IGRlZmluaXRpb25zID0ge307XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIE9uY2Uocm9vdCwgcG9zdGNzcykge1xuICAgICAgICAgIHJvb3Qud2Fsa0F0UnVsZXMoL3ZhbHVlL2ksIChhdFJ1bGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBhdFJ1bGUucGFyYW1zLm1hdGNoKG1hdGNoSW1wb3J0cyk7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgIGxldCBbLCAvKm1hdGNoKi8gYWxpYXNlcywgcGF0aF0gPSBtYXRjaGVzO1xuXG4gICAgICAgICAgICAgIC8vIFdlIGNhbiB1c2UgY29uc3RhbnRzIGZvciBwYXRoIG5hbWVzXG4gICAgICAgICAgICAgIGlmIChkZWZpbml0aW9uc1twYXRoXSkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBkZWZpbml0aW9uc1twYXRoXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IGltcG9ydHMgPSBhbGlhc2VzXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL15cXChcXHMqKFtcXHNcXFNdKylcXHMqXFwpJC8sIFwiJDFcIilcbiAgICAgICAgICAgICAgICAuc3BsaXQoL1xccyosXFxzKi8pXG4gICAgICAgICAgICAgICAgLm1hcCgoYWxpYXMpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VucyA9IG1hdGNoSW1wb3J0LmV4ZWMoYWxpYXMpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAodG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFssIC8qbWF0Y2gqLyB0aGVpck5hbWUsIG15TmFtZSA9IHRoZWlyTmFtZV0gPSB0b2tlbnM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltcG9ydGVkTmFtZSA9IGNyZWF0ZUltcG9ydGVkTmFtZShteU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uc1tteU5hbWVdID0gaW1wb3J0ZWROYW1lO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0aGVpck5hbWUsIGltcG9ydGVkTmFtZSB9O1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAaW1wb3J0IHN0YXRlbWVudCBcIiR7YWxpYXN9XCIgaXMgaW52YWxpZCFgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBpbXBvcnRBbGlhc2VzLnB1c2goeyBwYXRoLCBpbXBvcnRzIH0pO1xuXG4gICAgICAgICAgICAgIGF0UnVsZS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhdFJ1bGUucGFyYW1zLmluZGV4T2YoXCJAdmFsdWVcIikgIT09IC0xKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC53YXJuKFwiSW52YWxpZCB2YWx1ZSBkZWZpbml0aW9uOiBcIiArIGF0UnVsZS5wYXJhbXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgWywga2V5LCB2YWx1ZV0gPSBgJHthdFJ1bGUucGFyYW1zfSR7YXRSdWxlLnJhd3MuYmV0d2Vlbn1gLm1hdGNoKFxuICAgICAgICAgICAgICBtYXRjaFZhbHVlRGVmaW5pdGlvblxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZFZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFwvXFwqKCg/IVxcKlxcLykuKj8pXFwqXFwvL2csIFwiXCIpO1xuXG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZFZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICByZXN1bHQud2FybihcIkludmFsaWQgdmFsdWUgZGVmaW5pdGlvbjogXCIgKyBhdFJ1bGUucGFyYW1zKTtcbiAgICAgICAgICAgICAgYXRSdWxlLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGlzT25seVNwYWNlID0gL15cXHMrJC8udGVzdChub3JtYWxpemVkVmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoIWlzT25seVNwYWNlKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgdG8gdGhlIGRlZmluaXRpb25zLCBrbm93aW5nIHRoYXQgdmFsdWVzIGNhbiByZWZlciB0byBlYWNoIG90aGVyXG4gICAgICAgICAgICBkZWZpbml0aW9uc1trZXldID0gSUNTU1V0aWxzLnJlcGxhY2VWYWx1ZVN5bWJvbHMoXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBkZWZpbml0aW9uc1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgYXRSdWxlLnJlbW92ZSgpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLyogSWYgd2UgaGF2ZSBubyBkZWZpbml0aW9ucywgZG9uJ3QgY29udGludWUgKi9cbiAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGRlZmluaXRpb25zKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKiBQZXJmb3JtIHJlcGxhY2VtZW50cyAqL1xuICAgICAgICAgIElDU1NVdGlscy5yZXBsYWNlU3ltYm9scyhyb290LCBkZWZpbml0aW9ucyk7XG5cbiAgICAgICAgICAvKiBXZSB3YW50IHRvIGV4cG9ydCBhbnl0aGluZyBkZWZpbmVkIGJ5IG5vdywgYnV0IGRvbid0IGFkZCBpdCB0byB0aGUgQ1NTIHlldCBvciBpdCB3ZWxsIGdldCBwaWNrZWQgdXAgYnkgdGhlIHJlcGxhY2VtZW50IHN0dWZmICovXG4gICAgICAgICAgY29uc3QgZXhwb3J0RGVjbGFyYXRpb25zID0gT2JqZWN0LmtleXMoZGVmaW5pdGlvbnMpLm1hcCgoa2V5KSA9PlxuICAgICAgICAgICAgcG9zdGNzcy5kZWNsKHtcbiAgICAgICAgICAgICAgdmFsdWU6IGRlZmluaXRpb25zW2tleV0sXG4gICAgICAgICAgICAgIHByb3A6IGtleSxcbiAgICAgICAgICAgICAgcmF3czogeyBiZWZvcmU6IFwiXFxuICBcIiB9LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLyogQWRkIGV4cG9ydCBydWxlcyBpZiBhbnkgKi9cbiAgICAgICAgICBpZiAoZXhwb3J0RGVjbGFyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cG9ydFJ1bGUgPSBwb3N0Y3NzLnJ1bGUoe1xuICAgICAgICAgICAgICBzZWxlY3RvcjogXCI6ZXhwb3J0XCIsXG4gICAgICAgICAgICAgIHJhd3M6IHsgYWZ0ZXI6IFwiXFxuXCIgfSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBleHBvcnRSdWxlLmFwcGVuZChleHBvcnREZWNsYXJhdGlvbnMpO1xuXG4gICAgICAgICAgICByb290LnByZXBlbmQoZXhwb3J0UnVsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyogQWRkIGltcG9ydCBydWxlcyAqL1xuICAgICAgICAgIGltcG9ydEFsaWFzZXMucmV2ZXJzZSgpLmZvckVhY2goKHsgcGF0aCwgaW1wb3J0cyB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbXBvcnRSdWxlID0gcG9zdGNzcy5ydWxlKHtcbiAgICAgICAgICAgICAgc2VsZWN0b3I6IGA6aW1wb3J0KCR7cGF0aH0pYCxcbiAgICAgICAgICAgICAgcmF3czogeyBhZnRlcjogXCJcXG5cIiB9LFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGltcG9ydHMuZm9yRWFjaCgoeyB0aGVpck5hbWUsIGltcG9ydGVkTmFtZSB9KSA9PiB7XG4gICAgICAgICAgICAgIGltcG9ydFJ1bGUuYXBwZW5kKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhlaXJOYW1lLFxuICAgICAgICAgICAgICAgIHByb3A6IGltcG9ydGVkTmFtZSxcbiAgICAgICAgICAgICAgICByYXdzOiB7IGJlZm9yZTogXCJcXG4gIFwiIH0sXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJvb3QucHJlcGVuZChpbXBvcnRSdWxlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSxcbiAgfTtcbn07XG5cbnNyYy5leHBvcnRzLnBvc3Rjc3MgPSB0cnVlO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoYmVoYXZpb3VycyQxLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5iZWhhdmlvdXJzJDEuYmVoYXZpb3VycyA9IHZvaWQgMDtcbmJlaGF2aW91cnMkMS5nZXREZWZhdWx0UGx1Z2lucyA9IGdldERlZmF1bHRQbHVnaW5zO1xuYmVoYXZpb3VycyQxLmlzVmFsaWRCZWhhdmlvdXIgPSBpc1ZhbGlkQmVoYXZpb3VyO1xuXG52YXIgX3Bvc3Rjc3NNb2R1bGVzTG9jYWxCeURlZmF1bHQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0JDEoc3JjJDQuZXhwb3J0cyk7XG5cbnZhciBfcG9zdGNzc01vZHVsZXNFeHRyYWN0SW1wb3J0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQkMShzcmMkMi5leHBvcnRzKTtcblxudmFyIF9wb3N0Y3NzTW9kdWxlc1Njb3BlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCQxKHNyYyQxKTtcblxudmFyIF9wb3N0Y3NzTW9kdWxlc1ZhbHVlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQkMShzcmMuZXhwb3J0cyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQkMShvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuY29uc3QgYmVoYXZpb3VycyA9IHtcbiAgTE9DQUw6IFwibG9jYWxcIixcbiAgR0xPQkFMOiBcImdsb2JhbFwiXG59O1xuYmVoYXZpb3VycyQxLmJlaGF2aW91cnMgPSBiZWhhdmlvdXJzO1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0UGx1Z2lucyh7XG4gIGJlaGF2aW91cixcbiAgZ2VuZXJhdGVTY29wZWROYW1lLFxuICBleHBvcnRHbG9iYWxzXG59KSB7XG4gIGNvbnN0IHNjb3BlID0gKDAsIF9wb3N0Y3NzTW9kdWxlc1Njb3BlLmRlZmF1bHQpKHtcbiAgICBnZW5lcmF0ZVNjb3BlZE5hbWUsXG4gICAgZXhwb3J0R2xvYmFsc1xuICB9KTtcbiAgY29uc3QgcGx1Z2lucyA9IHtcbiAgICBbYmVoYXZpb3Vycy5MT0NBTF06IFtfcG9zdGNzc01vZHVsZXNWYWx1ZXMuZGVmYXVsdCwgKDAsIF9wb3N0Y3NzTW9kdWxlc0xvY2FsQnlEZWZhdWx0LmRlZmF1bHQpKHtcbiAgICAgIG1vZGU6ICdsb2NhbCdcbiAgICB9KSwgX3Bvc3Rjc3NNb2R1bGVzRXh0cmFjdEltcG9ydHMuZGVmYXVsdCwgc2NvcGVdLFxuICAgIFtiZWhhdmlvdXJzLkdMT0JBTF06IFtfcG9zdGNzc01vZHVsZXNWYWx1ZXMuZGVmYXVsdCwgKDAsIF9wb3N0Y3NzTW9kdWxlc0xvY2FsQnlEZWZhdWx0LmRlZmF1bHQpKHtcbiAgICAgIG1vZGU6ICdnbG9iYWwnXG4gICAgfSksIF9wb3N0Y3NzTW9kdWxlc0V4dHJhY3RJbXBvcnRzLmRlZmF1bHQsIHNjb3BlXVxuICB9O1xuICByZXR1cm4gcGx1Z2luc1tiZWhhdmlvdXJdO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkQmVoYXZpb3VyKGJlaGF2aW91cikge1xuICByZXR1cm4gT2JqZWN0LmtleXMoYmVoYXZpb3VycykubWFwKGtleSA9PiBiZWhhdmlvdXJzW2tleV0pLmluZGV4T2YoYmVoYXZpb3VyKSA+IC0xO1xufVxuXG52YXIgX3Bvc3Rjc3MgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUkJDAkMSk7XG5cbnZhciBfbG9kYXNoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChsb2Rhc2hfY2FtZWxjYXNlKTtcblxudmFyIF9nZW5lcmljTmFtZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGdlbmVyaWNOYW1lcyk7XG5cbnZhciBfdW5xdW90ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQodW5xdW90ZSQxKTtcblxudmFyIF9wYXJzZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHBhcnNlciQxKTtcblxudmFyIF9sb2FkZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGxvYWRlcik7XG5cbnZhciBfZ2VuZXJhdGVTY29wZWROYW1lID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChnZW5lcmF0ZVNjb3BlZE5hbWUkMSk7XG5cbnZhciBfc2F2ZUpTT04gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHNhdmVKU09OJDEpO1xuXG52YXIgX2JlaGF2aW91cnMgPSBiZWhhdmlvdXJzJDE7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmNvbnN0IFBMVUdJTl9OQU1FID0gXCJwb3N0Y3NzLW1vZHVsZXNcIjtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdFNjb3BlQmVoYXZpb3VyKG9wdHMpIHtcbiAgaWYgKG9wdHMuc2NvcGVCZWhhdmlvdXIgJiYgKDAsIF9iZWhhdmlvdXJzLmlzVmFsaWRCZWhhdmlvdXIpKG9wdHMuc2NvcGVCZWhhdmlvdXIpKSB7XG4gICAgcmV0dXJuIG9wdHMuc2NvcGVCZWhhdmlvdXI7XG4gIH1cblxuICByZXR1cm4gX2JlaGF2aW91cnMuYmVoYXZpb3Vycy5MT0NBTDtcbn1cblxuZnVuY3Rpb24gZ2V0U2NvcGVkTmFtZUdlbmVyYXRvcihvcHRzKSB7XG4gIGNvbnN0IHNjb3BlZE5hbWVHZW5lcmF0b3IgPSBvcHRzLmdlbmVyYXRlU2NvcGVkTmFtZSB8fCBfZ2VuZXJhdGVTY29wZWROYW1lLmRlZmF1bHQ7XG4gIGlmICh0eXBlb2Ygc2NvcGVkTmFtZUdlbmVyYXRvciA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gc2NvcGVkTmFtZUdlbmVyYXRvcjtcbiAgcmV0dXJuICgwLCBfZ2VuZXJpY05hbWVzLmRlZmF1bHQpKHNjb3BlZE5hbWVHZW5lcmF0b3IsIHtcbiAgICBjb250ZXh0OiBwcm9jZXNzLmN3ZCgpLFxuICAgIGhhc2hQcmVmaXg6IG9wdHMuaGFzaFByZWZpeFxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0TG9hZGVyKG9wdHMsIHBsdWdpbnMpIHtcbiAgY29uc3Qgcm9vdCA9IHR5cGVvZiBvcHRzLnJvb3QgPT09IFwidW5kZWZpbmVkXCIgPyBcIi9cIiA6IG9wdHMucm9vdDtcbiAgcmV0dXJuIHR5cGVvZiBvcHRzLkxvYWRlciA9PT0gXCJmdW5jdGlvblwiID8gbmV3IG9wdHMuTG9hZGVyKHJvb3QsIHBsdWdpbnMpIDogbmV3IF9sb2FkZXIuZGVmYXVsdChyb290LCBwbHVnaW5zKTtcbn1cblxuZnVuY3Rpb24gaXNHbG9iYWxNb2R1bGUoZ2xvYmFsTW9kdWxlcywgaW5wdXRGaWxlKSB7XG4gIHJldHVybiBnbG9iYWxNb2R1bGVzLnNvbWUocmVnZXggPT4gaW5wdXRGaWxlLm1hdGNoKHJlZ2V4KSk7XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRQbHVnaW5zTGlzdChvcHRzLCBpbnB1dEZpbGUpIHtcbiAgY29uc3QgZ2xvYmFsTW9kdWxlc0xpc3QgPSBvcHRzLmdsb2JhbE1vZHVsZVBhdGhzIHx8IG51bGw7XG4gIGNvbnN0IGV4cG9ydEdsb2JhbHMgPSBvcHRzLmV4cG9ydEdsb2JhbHMgfHwgZmFsc2U7XG4gIGNvbnN0IGRlZmF1bHRCZWhhdmlvdXIgPSBnZXREZWZhdWx0U2NvcGVCZWhhdmlvdXIob3B0cyk7XG4gIGNvbnN0IGdlbmVyYXRlU2NvcGVkTmFtZSA9IGdldFNjb3BlZE5hbWVHZW5lcmF0b3Iob3B0cyk7XG5cbiAgaWYgKGdsb2JhbE1vZHVsZXNMaXN0ICYmIGlzR2xvYmFsTW9kdWxlKGdsb2JhbE1vZHVsZXNMaXN0LCBpbnB1dEZpbGUpKSB7XG4gICAgcmV0dXJuICgwLCBfYmVoYXZpb3Vycy5nZXREZWZhdWx0UGx1Z2lucykoe1xuICAgICAgYmVoYXZpb3VyOiBfYmVoYXZpb3Vycy5iZWhhdmlvdXJzLkdMT0JBTCxcbiAgICAgIGdlbmVyYXRlU2NvcGVkTmFtZSxcbiAgICAgIGV4cG9ydEdsb2JhbHNcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiAoMCwgX2JlaGF2aW91cnMuZ2V0RGVmYXVsdFBsdWdpbnMpKHtcbiAgICBiZWhhdmlvdXI6IGRlZmF1bHRCZWhhdmlvdXIsXG4gICAgZ2VuZXJhdGVTY29wZWROYW1lLFxuICAgIGV4cG9ydEdsb2JhbHNcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzT3VyUGx1Z2luKHBsdWdpbikge1xuICByZXR1cm4gcGx1Z2luLnBvc3Rjc3NQbHVnaW4gPT09IFBMVUdJTl9OQU1FO1xufVxuXG5mdW5jdGlvbiBkYXNoZXNDYW1lbENhc2Uoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvLSsoXFx3KS9nLCAoXywgZmlyc3RMZXR0ZXIpID0+IGZpcnN0TGV0dGVyLnRvVXBwZXJDYXNlKCkpO1xufVxuXG5idWlsZC5leHBvcnRzID0gKG9wdHMgPSB7fSkgPT4ge1xuICByZXR1cm4ge1xuICAgIHBvc3Rjc3NQbHVnaW46IFBMVUdJTl9OQU1FLFxuXG4gICAgYXN5bmMgT25jZUV4aXQoY3NzLCB7XG4gICAgICByZXN1bHRcbiAgICB9KSB7XG4gICAgICBjb25zdCBnZXRKU09OID0gb3B0cy5nZXRKU09OIHx8IF9zYXZlSlNPTi5kZWZhdWx0O1xuICAgICAgY29uc3QgaW5wdXRGaWxlID0gY3NzLnNvdXJjZS5pbnB1dC5maWxlO1xuICAgICAgY29uc3QgcGx1Z2luTGlzdCA9IGdldERlZmF1bHRQbHVnaW5zTGlzdChvcHRzLCBpbnB1dEZpbGUpO1xuICAgICAgY29uc3QgcmVzdWx0UGx1Z2luSW5kZXggPSByZXN1bHQucHJvY2Vzc29yLnBsdWdpbnMuZmluZEluZGV4KHBsdWdpbiA9PiBpc091clBsdWdpbihwbHVnaW4pKTtcblxuICAgICAgaWYgKHJlc3VsdFBsdWdpbkluZGV4ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsdWdpbiBtaXNzaW5nIGZyb20gb3B0aW9ucy4nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZWFybGllclBsdWdpbnMgPSByZXN1bHQucHJvY2Vzc29yLnBsdWdpbnMuc2xpY2UoMCwgcmVzdWx0UGx1Z2luSW5kZXgpO1xuICAgICAgY29uc3QgbG9hZGVyUGx1Z2lucyA9IFsuLi5lYXJsaWVyUGx1Z2lucywgLi4ucGx1Z2luTGlzdF07XG4gICAgICBjb25zdCBsb2FkZXIgPSBnZXRMb2FkZXIob3B0cywgbG9hZGVyUGx1Z2lucyk7XG5cbiAgICAgIGNvbnN0IGZldGNoZXIgPSAoZmlsZSwgcmVsYXRpdmVUbywgZGVwVHJhY2UpID0+IHtcbiAgICAgICAgY29uc3QgdW5xdW90ZUZpbGUgPSAoMCwgX3VucXVvdGUuZGVmYXVsdCkoZmlsZSk7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkUmVzdWx0ID0gdHlwZW9mIG9wdHMucmVzb2x2ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBvcHRzLnJlc29sdmUodW5xdW90ZUZpbGUpO1xuICAgICAgICBjb25zdCByZXNvbHZlZEZpbGUgPSByZXNvbHZlZFJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UgPyByZXNvbHZlZFJlc3VsdCA6IFByb21pc2UucmVzb2x2ZShyZXNvbHZlZFJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXNvbHZlZEZpbGUudGhlbihmID0+IHtcbiAgICAgICAgICByZXR1cm4gbG9hZGVyLmZldGNoLmNhbGwobG9hZGVyLCBgXCIke2YgfHwgdW5xdW90ZUZpbGV9XCJgLCByZWxhdGl2ZVRvLCBkZXBUcmFjZSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgcGFyc2VyID0gbmV3IF9wYXJzZXIuZGVmYXVsdChmZXRjaGVyKTtcbiAgICAgIGF3YWl0ICgwLCBfcG9zdGNzcy5kZWZhdWx0KShbLi4ucGx1Z2luTGlzdCwgcGFyc2VyLnBsdWdpbigpXSkucHJvY2Vzcyhjc3MsIHtcbiAgICAgICAgZnJvbTogaW5wdXRGaWxlXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG91dCA9IGxvYWRlci5maW5hbFNvdXJjZTtcbiAgICAgIGlmIChvdXQpIGNzcy5wcmVwZW5kKG91dCk7XG5cbiAgICAgIGlmIChvcHRzLmxvY2Fsc0NvbnZlbnRpb24pIHtcbiAgICAgICAgY29uc3QgaXNGdW5jID0gdHlwZW9mIG9wdHMubG9jYWxzQ29udmVudGlvbiA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICBwYXJzZXIuZXhwb3J0VG9rZW5zID0gT2JqZWN0LmVudHJpZXMocGFyc2VyLmV4cG9ydFRva2VucykucmVkdWNlKCh0b2tlbnMsIFtjbGFzc05hbWUsIHZhbHVlXSkgPT4ge1xuICAgICAgICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgICAgICAgIHRva2Vuc1tvcHRzLmxvY2Fsc0NvbnZlbnRpb24oY2xhc3NOYW1lLCB2YWx1ZSwgaW5wdXRGaWxlKV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3dpdGNoIChvcHRzLmxvY2Fsc0NvbnZlbnRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgXCJjYW1lbENhc2VcIjpcbiAgICAgICAgICAgICAgdG9rZW5zW2NsYXNzTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgdG9rZW5zWygwLCBfbG9kYXNoLmRlZmF1bHQpKGNsYXNzTmFtZSldID0gdmFsdWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiY2FtZWxDYXNlT25seVwiOlxuICAgICAgICAgICAgICB0b2tlbnNbKDAsIF9sb2Rhc2guZGVmYXVsdCkoY2xhc3NOYW1lKV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJkYXNoZXNcIjpcbiAgICAgICAgICAgICAgdG9rZW5zW2NsYXNzTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgdG9rZW5zW2Rhc2hlc0NhbWVsQ2FzZShjbGFzc05hbWUpXSA9IHZhbHVlO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcImRhc2hlc09ubHlcIjpcbiAgICAgICAgICAgICAgdG9rZW5zW2Rhc2hlc0NhbWVsQ2FzZShjbGFzc05hbWUpXSA9IHZhbHVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICB9LCB7fSk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5tZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJleHBvcnRcIixcbiAgICAgICAgcGx1Z2luOiBcInBvc3Rjc3MtbW9kdWxlc1wiLFxuICAgICAgICBleHBvcnRUb2tlbnM6IHBhcnNlci5leHBvcnRUb2tlbnNcbiAgICAgIH0pOyAvLyBnZXRKU09OIG1heSByZXR1cm4gYSBwcm9taXNlXG5cbiAgICAgIHJldHVybiBnZXRKU09OKGNzcy5zb3VyY2UuaW5wdXQuZmlsZSwgcGFyc2VyLmV4cG9ydFRva2VucywgcmVzdWx0Lm9wdHMudG8pO1xuICAgIH1cblxuICB9O1xufTtcblxudmFyIHBvc3Rjc3MgPSBidWlsZC5leHBvcnRzLnBvc3Rjc3MgPSB0cnVlO1xuXG52YXIgaW5kZXggPSAvKiNfX1BVUkVfXyovX21lcmdlTmFtZXNwYWNlcyh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgcG9zdGNzczogcG9zdGNzcyxcbiAgJ2RlZmF1bHQnOiBidWlsZC5leHBvcnRzXG59LCBbYnVpbGQuZXhwb3J0c10pO1xuXG5leHBvcnQgeyBpbmRleCBhcyBpIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vite/dist/node/chunks/dep-7591464a.js\n");

/***/ })

}]);